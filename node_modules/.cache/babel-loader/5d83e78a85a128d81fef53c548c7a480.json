{"ast":null,"code":"/*  This class transforms normalized logical family into levels of nodes.\n  The current approach to optimize items placement is to transform family into hierarchy of nodes and order \n  children of every node in the way minimizing number of intersections between connection lines.\n  1. Extract families into _families array of type FamilyItem. Family is sub tree of items logicalFamily. \n    In order to extract families out of logicalFamily we count from bottom to roots total number of descendants for evry item and then extract \n    sub hierarchy having minimum number of members. This process is repeated till all nodes are extracted into separate families.\n      orgPartners - When we extract families we store links to parents in other branches having the same children of \n      some already extracted item as partner in orgPartners hash\n    This hash table is used to create links collections between families\n    The orgTree collection is used to define final org hierarchy used to balance nodes in levels.\n  2. Use links in families to build family graph\n  3. Find maximum spanning tree of family graph\n  4. Since spanning tree is the tree we calculate number of descendants in every branch. So when we join families into one \n    org chart we sort them taking first child family having maximum number of links to its parent family\n    sortedFamilies collection\n  5. Using sortedFamilies collection we merge roots of families back to primary org chart. The rule of that backward merging is \n    to find ancestor in target tree having level less then root item of merged family.\n    this is done without extra collection creation via making changes in orgTree\n    If family has no links it is added to root of orgTree\n  6. Balance organizational chart in order to place items having extra connections close to each other. \n    Assign every extra link to every pair of parent nodes up to the root.\n  7. Scan orgTree hierarchy from root to bottom and balance children using extra links collected from children\n    So at the top most level we know number of links between children, so we sort them, then number of overlappings between branches should be minimal\n    Balancing algorithms finds maximum spanning tree in connections between children and groups them from bottom of that tree up to the root\n    In the way when groups having maximum mutual links placed close to each other.\n*/\nimport TreeLevels from '../../../algorithms/TreeLevels';\nimport LinkedHashItems from '../../../algorithms/LinkedHashItems';\nimport Tree from '../../../algorithms/Tree';\nimport Graph from '../../../algorithms/Graph';\nimport Pile from '../../../algorithms/Pile';\nimport SortedList from '../../../algorithms/SortedList';\nimport FamilyBalanceItem from './FamilyBalanceItem';\nimport Slot from '../../../models/Slot';\nimport TreeLevelConnectorStackSize from '../../../models/TreeLevelConnectorStackSize';\nimport VerticalConnectorBundle from '../../../connectors/VerticalConnectorBundle';\nexport default function FamilyBalance() {}\n; //var params = {\n//  logicalFamily,\n//  maximumId,\n//  items\n//};\n\nFamilyBalance.prototype.balance = function (params) {\n  var result = {\n    maximumId: null,\n    treeLevels: TreeLevels(),\n    bundles: [],\n    connectorStacks: []\n  };\n  var data = {\n    orgTree: Tree(),\n\n    /*tree OrgItem */\n    maximumId: params.maximumId,\n    orgPartners: {},\n\n    /* Creates extra partners collection of relations between visual tree items They are used to draw connectors between items in different branches of organizational chart*/\n    itemByChildrenKey: {},\n    minimumLevel: null,\n    maximumLevel: null\n  };\n  this.createOrgTree(params, data);\n  var currentLevelIndex,\n      index = -1;\n  data.orgTree.loopLevels(this, function (treeItemId, treeItem, levelIndex) {\n    var familyItem = params.logicalFamily.node(treeItemId);\n\n    if (familyItem != null) {\n      if (currentLevelIndex !== levelIndex) {\n        currentLevelIndex = levelIndex;\n        index += 1;\n      }\n\n      result.treeLevels.addItem(index, treeItemId, familyItem);\n    }\n  });\n  this.recalcLevelsDepth(result.bundles, result.connectorStacks, result.treeLevels, params.logicalFamily);\n  result.maximumId = data.maximumId;\n  return result;\n};\n\nFamilyBalance.prototype.Family = function (id) {\n  this.id = null;\n  this.familyPriority = 1;\n  this.childFamilies = [];\n  this.items = [];\n  this.links = [];\n  /* array of FamLink(s) */\n\n  this.backLinks = [];\n  /* array of FamLink(s) */\n\n  if (arguments.length == 1) {\n    this.id = id;\n  }\n};\n\nFamilyBalance.prototype.FamLink = function (fromItem, toItem) {\n  this.fromItem = fromItem;\n  /* FamilyItem.id */\n\n  this.toItem = toItem;\n  /* FamilyItem.id */\n};\n\nFamilyBalance.prototype.createOrgTree = function (params, data) {\n  var index,\n      len,\n      index2,\n      len2,\n      familiesGraph,\n\n  /* Graph */\n  link,\n      links,\n      fromFamily,\n      toFamily,\n      sortedFamilies = [],\n      sortedFamiliesHash,\n      attachedFamilies,\n      familyId,\n      family,\n      familyRootItem,\n      fromItem,\n      toItem,\n      rootItem,\n      rootItems,\n      bestRootItem,\n      bestReference,\n      spanningTree,\n      extraGravities,\n      grandChildren,\n      orgItemRoot,\n      famItemsExtracted,\n      families = [],\n      families2;\n\n  if (params.logicalFamily.hasNodes() > 0) {\n    /* create hash of extracted family items */\n    famItemsExtracted = {};\n    familyId = 0;\n    families2 = [];\n    params.logicalFamily.loopRoots(this, function (grandParentId, grandParent) {\n      //ignore jslint\n      family = new this.Family(familyId);\n      /* extractOrgChart method extracts hiearchy of family members starting from grandParent and takes only non extracted family items \n       * For every extracted item it assigns its familyId, it is used for building families relations graph and finding cross family links\n      */\n\n      this.extractOrgChart(grandParentId, params.logicalFamily, params.primaryParents, data.orgTree, data.orgPartners, data.itemByChildrenKey, famItemsExtracted, family);\n      families.push(family);\n      families2.push(family);\n      familyId += 1;\n    });\n    families2.sort(function (a, b) {\n      /* sort families by root item level ASC and size DESC */\n      var aLevel = a.items[0].level,\n          bLevel = b.items[0].level;\n      return aLevel != bLevel ? aLevel - bLevel : b.items.length - a.items.length;\n    });\n    sortedFamilies = [];\n    sortedFamiliesHash = {};\n\n    if (families.length > 0) {\n      /* Build families graph */\n      familiesGraph = Graph();\n\n      for (index = 0, len = families.length; index < len; index += 1) {\n        family = families[index];\n\n        for (index2 = 0, len2 = family.links.length; index2 < len2; index2 += 1) {\n          link = family.links[index2];\n          fromFamily = params.logicalFamily.node(link.fromItem).familyId;\n          toFamily = params.logicalFamily.node(link.toItem).familyId;\n\n          if (fromFamily != toFamily) {\n            familiesGraph.addEdge(fromFamily, toFamily, {\n              weight: 0\n            });\n            familiesGraph.edge(fromFamily, toFamily).weight += 1;\n          }\n\n          families[toFamily].backLinks.push(new this.FamLink(link.toItem, link.fromItem));\n        }\n      }\n      /* Flatten families graph into array for merging */\n\n\n      while (sortedFamilies.length < families.length) {\n        for (index = 0, len = families2.length; index < len; index += 1) {\n          family = families2[index];\n\n          if (!sortedFamiliesHash.hasOwnProperty(family.id)) {\n            /* find maximum spanning tree of families graph*/\n            spanningTree = familiesGraph.getSpanningTree(family.id, function (edge) {\n              return -edge.weight;\n            }); //ignore jslint\n\n            if (spanningTree.node(family.id) != null) {\n              /* count number of sub families for every family in spanning tree and sorts child families desc*/\n              spanningTree.loopPostOrder(this, function (nodeid, node, parentid, parent) {\n                var family = families[nodeid],\n                    parentFamily = families[parentid],\n                    children = [];\n\n                if (parentid != null) {\n                  parentFamily.familyPriority = parentFamily.familyPriority + family.familyPriority;\n                }\n\n                children = [];\n                spanningTree.loopChildren(this, nodeid, function (childid, child, index) {\n                  children.push(childid);\n                });\n                children.sort(function (a, b) {\n                  return families[a].familyPriority - families[b].familyPriority;\n                });\n                spanningTree.arrangeChildren(nodeid, children);\n              }); //ignore jslint\n\n              /* merge tree items in pre order sequence */\n\n              spanningTree.loopPreOrder(this, function (familyid, node) {\n                sortedFamilies.push(familyid);\n                sortedFamiliesHash[familyid] = true;\n              }); //ignore jslint\n            } else {\n              /* family has no links to any other family so we add it as orphant */\n              sortedFamilies.push(family.id);\n              sortedFamiliesHash[family.id] = true;\n            }\n          }\n        }\n      }\n    }\n    /* create chart root */\n\n\n    data.maximumId += 1;\n    orgItemRoot = new FamilyBalanceItem(data.maximumId, null, data.minimumLevel - 1);\n    data.orgTree.add(null, orgItemRoot.id, orgItemRoot);\n    /* Place family roots to organizational chart */\n\n    attachedFamilies = {};\n\n    for (index = 0, len = sortedFamilies.length; index < len; index += 1) {\n      family = families[sortedFamilies[index]];\n      rootItems = {}; // Hash where key = rootItem.id and value is number of references\n\n      bestRootItem = orgItemRoot;\n      bestReference = 0;\n      links = family.links.concat(family.backLinks);\n\n      for (index2 = 0; index2 < links.length; index2 += 1) {\n        link = links[index2];\n        toItem = data.orgTree.node(link.toItem);\n        fromItem = data.orgTree.node(link.fromItem);\n\n        if (attachedFamilies[toItem.familyId] === true) {\n          familyRootItem = family.items[0];\n          rootItem = toItem;\n\n          if (rootItem.level >= familyRootItem.level) {\n            data.orgTree.loopParents(this, rootItem.id, function (nodeid, node) {\n              rootItem = node;\n\n              if (node.level < familyRootItem.level) {\n                return true;\n              }\n            }); //ignore jslint\n          }\n\n          if (rootItems.hasOwnProperty(rootItem.id)) {\n            rootItems[rootItem.id] += 1;\n          } else {\n            rootItems[rootItem.id] = 1;\n          }\n          /* family may be nested to multiple places, so we select root item having maximum connections with our new sub family */\n\n\n          if (bestReference < rootItems[rootItem.id]) {\n            bestRootItem = rootItem;\n            bestReference = rootItems[rootItem.id];\n          }\n        }\n      }\n\n      this.attachFamilyToOrgChart(data, bestRootItem, family);\n      attachedFamilies[family.id] = true;\n    }\n    /* balance organizational chart in order to place items having extra connections close to each other */\n\n\n    extraGravities = this.getExtraGravity(data);\n    /* count number of vertical connections for every item */\n\n    grandChildren = this.getGrandChildren(data);\n    /* scan orgTree hierarchy from root to bottom and balance its children */\n\n    this.balanceOrgTree(data.orgTree, extraGravities, grandChildren, params.itemsPositions, params.itemsGroups);\n  }\n};\n\nFamilyBalance.prototype.getGrandChildren = function (data) {\n  var result = {};\n  /* Key = OrgItem.id, Value= Hash {} having Key = level and Value = number of grand children*/\n\n  data.orgTree.loopPostOrder(this, function (itemId, orgItem, parentId, parent) {\n    var level;\n    data.minimumLevel = data.minimumLevel != null ? Math.min(data.minimumLevel, orgItem.level) : orgItem.level;\n    data.maximumLevel = data.maximumLevel != null ? Math.max(data.maximumLevel, orgItem.level) : orgItem.level;\n\n    if (parentId != null) {\n      if (!result[parentId]) {\n        result[parentId] = {};\n      }\n\n      level = orgItem.level - 1;\n      /* project children qty to parent level, it is needed to match cross hierarchy connectors levels*/\n\n      if (!result[parentId][level]) {\n        result[parentId][level] = 1;\n      } else {\n        result[parentId][level] += 1;\n      }\n\n      if (result[itemId] != null) {\n        for (level in result[itemId]) {\n          if (result[itemId].hasOwnProperty(level)) {\n            if (!result[parentId][level]) {\n              result[parentId][level] = result[itemId][level];\n            } else {\n              result[parentId][level] += result[itemId][level];\n            }\n          }\n        }\n      }\n    }\n  });\n  return result;\n};\n\nFamilyBalance.prototype.balanceOrgTree = function (orgTree, extraGravities, grandChildren, itemsPositions, itemsGroups) {\n  var index2,\n      len2,\n      index3,\n      len3,\n      extraGravity,\n      childExtraGravities,\n      sortedChildren,\n      subChildren,\n      subOrgItem,\n      leftId = '__left__',\n      rightId = '__right__',\n      levelExtraGravities,\n      sequence;\n  orgTree.loopLevels(this, function (parentOrgItemId, parentOrgItem, levelid) {\n    var graph = Graph(),\n        graphGravities = {},\n        firstOrgItem = null,\n        toItemId;\n    /* build gravities graph for children */\n\n    sortedChildren = [];\n    orgTree.loopChildren(this, parentOrgItem.id, function (childOrgItemId, childOrgItem, index) {\n      var levelKey;\n\n      if (firstOrgItem == null) {\n        firstOrgItem = childOrgItem;\n      }\n\n      graphGravities[childOrgItem.id] = {};\n\n      if (extraGravities.hasOwnProperty(childOrgItem.id)) {\n        childExtraGravities = extraGravities[childOrgItem.id];\n\n        for (levelKey in childExtraGravities) {\n          if (childExtraGravities.hasOwnProperty(levelKey)) {\n            levelExtraGravities = childExtraGravities[levelKey];\n            graphGravities[childOrgItem.id][levelKey] = {};\n\n            for (index2 = 0, len2 = levelExtraGravities.length; index2 < len2; index2 += 1) {\n              extraGravity = levelExtraGravities[index2];\n\n              if (extraGravity.commonParent == parentOrgItem.id) {\n                /* this is link between two children */\n                toItemId = extraGravity.toParent;\n              } else {\n                /* this is external link on left or on right side, we create virtual graph item ids for external links */\n                if (orgTree.node(extraGravity.fromParent).childIndex < orgTree.node(extraGravity.toParent).childIndex) {\n                  toItemId = rightId;\n                } else {\n                  toItemId = leftId;\n                }\n              }\n              /* add connection to graph */\n\n\n              if (childOrgItem.id != toItemId) {\n                graph.addEdge(childOrgItem.id, toItemId, {\n                  weight: 0\n                });\n                graph.edge(childOrgItem.id, toItemId).weight += 1.0;\n\n                if (graphGravities[childOrgItem.id][levelKey][toItemId] == null) {\n                  graphGravities[childOrgItem.id][levelKey][toItemId] = 0;\n                }\n\n                graphGravities[childOrgItem.id][levelKey][toItemId] += 1;\n              }\n            }\n          }\n        }\n      }\n      /* add extra zero connection to graph when child org item has no connections\n        it is connected to the first item in the graph with zero link\n      */\n\n\n      if (index > 0) {\n        graph.addEdge(childOrgItem.id, firstOrgItem.id, {\n          weight: 0\n        });\n      }\n    });\n\n    if (firstOrgItem != null) {\n      /* sort items in graph from the most connected to the least */\n      sequence = [];\n      graph.getTotalWeightGrowthSequence(this, function (a) {\n        return a.weight;\n      }, function (a) {\n        sequence.push(a);\n      }); //ignore jslint\n\n      if (sequence.length === 0) {\n        sequence = [firstOrgItem.id];\n      }\n      /* sort children from top to down */\n\n\n      subChildren = this.balanceItems(sequence, leftId, rightId, graphGravities, grandChildren, itemsPositions, itemsGroups);\n      /* save items indexes for further use */\n\n      for (index3 = 0, len3 = subChildren.length; index3 < len3; index3 += 1) {\n        subOrgItem = orgTree.node(subChildren[index3]);\n        subOrgItem.childIndex = index3;\n        sortedChildren.push(subOrgItem.id);\n      }\n    }\n\n    orgTree.arrangeChildren(parentOrgItem.id, sortedChildren);\n  });\n};\n\nFamilyBalance.prototype.balanceItems = function (sequence, leftId, rightId, graphGravities, grandChildren, itemsPositions, itemsGroups) {\n  var result = [],\n      index,\n      slots = LinkedHashItems(),\n      // key = counter++, value =  slot object\n  counter = 0,\n      positions = {},\n      // hash[groupId] = SortedList, key = user defined item position, value = key in slots -- create only when user defined itemsPositions exists for items\n  startSlotKey,\n      endSlotKey,\n      key,\n      slot,\n      items = {},\n      itemid,\n      itemsToAdd,\n      bestSlotKey,\n      bestSlot,\n      bestSlotValue,\n      bestSlotDistance,\n      bestSlotBalance,\n      bestSlotCrossings,\n      slotValue,\n      slotDistance,\n      slotBalance,\n      slotCrossings,\n      itemGrandChildren,\n      itemSlot,\n      itemSlotKey,\n      level,\n      levelGravities,\n      toItemId,\n      toItemSlot,\n      userItemPosition,\n      position,\n      itemGroup,\n      groupPositions,\n      toItemSlotKey;\n  /* populate initital slots */\n\n  itemsToAdd = [leftId, null, rightId];\n\n  for (index = 0; index < itemsToAdd.length; index += 1) {\n    itemid = itemsToAdd[index];\n    key = counter++;\n    slot = new Slot(itemid);\n    slot.position = index;\n    slots.add(key, slot);\n\n    if (itemid !== null) {\n      items[itemid] = key;\n    }\n  }\n\n  for (index = 0; index < sequence.length; index += 1) {\n    itemid = sequence[index];\n    /* ignore left and right margin */\n\n    if (itemid != leftId && itemid != rightId) {\n      bestSlotKey = null;\n      bestSlot = null;\n      bestSlotValue = null;\n      bestSlotDistance = null;\n      bestSlotBalance = null;\n      bestSlotCrossings = null;\n      startSlotKey = null;\n      endSlotKey = null;\n\n      if (itemsGroups.hasOwnProperty(itemid)) {\n        itemGroup = itemsGroups[itemid];\n\n        if (positions.hasOwnProperty(itemGroup)) {\n          userItemPosition = itemsPositions[itemid];\n          groupPositions = positions[itemGroup];\n          startSlotKey = groupPositions.previousContext(userItemPosition);\n          endSlotKey = groupPositions.nextContext(userItemPosition);\n        }\n      }\n\n      slots.iterate(function (slot, slotKey) {\n        var level, toItemId, levelGravities, toItemSlot;\n\n        if (slot.itemId == null) {\n          itemGrandChildren = grandChildren[itemid];\n          slotValue = 0;\n          slotDistance = 0;\n          slotBalance = 0;\n          slotCrossings = 0;\n\n          for (level in slot.crossings) {\n            if (slot.crossings.hasOwnProperty(level)) {\n              if (itemGrandChildren && itemGrandChildren[level] != null) {\n                slotValue += slot.crossings[level] * itemGrandChildren[level];\n              }\n\n              slotCrossings += slot.crossings[level];\n            }\n          }\n\n          for (level in graphGravities[itemid]) {\n            if (graphGravities[itemid].hasOwnProperty(level)) {\n              levelGravities = graphGravities[itemid][level];\n\n              for (toItemId in levelGravities) {\n                if (levelGravities.hasOwnProperty(toItemId)) {\n                  if (items.hasOwnProperty(toItemId)) {\n                    toItemSlot = slots.item(items[toItemId]);\n\n                    if (toItemSlot != null) {\n                      if (toItemSlot.position < slot.position) {\n                        /* on the left side */\n                        slotValue += (slot.left[level] || 0.0) - (toItemSlot.left[level] || 0.0);\n                        slotBalance += Math.abs(toItemSlot.balance + 1);\n                      } else {\n                        /* on the right side */\n                        slotValue += (slot.right[level] || 0.0) - (toItemSlot.right[level] || 0.0);\n                        slotBalance += Math.abs(toItemSlot.balance - 1);\n                      }\n\n                      slotDistance += Math.abs(toItemSlot.position - slot.position);\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          if (bestSlotValue == null || bestSlotValue > slotValue || bestSlotValue == slotValue && (bestSlotDistance > slotDistance || bestSlotDistance == slotDistance && (bestSlotBalance > slotBalance || bestSlotBalance == slotBalance && bestSlotCrossings > slotCrossings))) {\n            bestSlotKey = slotKey;\n            bestSlotValue = slotValue;\n            bestSlot = slot;\n            bestSlotDistance = slotDistance;\n            bestSlotBalance = slotBalance;\n            bestSlotCrossings = slotCrossings;\n          }\n        }\n      }, startSlotKey, endSlotKey); //ignore jslint\n\n      slots.insertBefore(bestSlotKey, counter++, bestSlot.clone(null));\n      items[itemid] = counter;\n      itemSlotKey = counter;\n      itemSlot = bestSlot.clone(itemid);\n\n      if (itemsPositions.hasOwnProperty(itemid)) {\n        itemGroup = itemsGroups[itemid];\n\n        if (!positions.hasOwnProperty(itemGroup)) {\n          positions[itemGroup] = SortedList();\n        }\n\n        groupPositions = positions[itemGroup];\n        groupPositions.add(itemsPositions[itemid], counter);\n      }\n\n      slots.insertBefore(bestSlotKey, counter++, itemSlot);\n      /* add new item grand children qty to all slots to their grand totals for right & left sides */\n\n      itemSlot.position = 0;\n      position = 0;\n      slots.iterate(function (slot, slotKey) {\n        var level, itemGrandChildren;\n\n        if (slotKey != itemSlotKey) {\n          itemGrandChildren = grandChildren[itemid];\n\n          for (level in itemGrandChildren) {\n            if (itemGrandChildren.hasOwnProperty(level)) {\n              if (!slot.left[level]) {\n                slot.left[level] = itemGrandChildren[level];\n              } else {\n                slot.left[level] += itemGrandChildren[level];\n              }\n            }\n          }\n\n          position += 1;\n          slot.position = position;\n        }\n      }, itemSlotKey); //ignore jslint\n\n      position = 0;\n      slots.iterateBack(function (slot, slotKey) {\n        var level, itemGrandChildren;\n\n        if (slotKey != itemSlotKey) {\n          itemGrandChildren = grandChildren[itemid];\n\n          for (level in grandChildren[itemid]) {\n            if (grandChildren[itemid].hasOwnProperty(level)) {\n              if (!slot.right[level]) {\n                slot.right[level] = itemGrandChildren[level];\n              } else {\n                slot.right[level] += itemGrandChildren[level];\n              }\n            }\n          }\n\n          position -= 1;\n          slot.position = position;\n        }\n      }, itemSlotKey); //ignore jslint\n\n      /* add crossings */\n\n      for (level in graphGravities[itemid]) {\n        if (graphGravities[itemid].hasOwnProperty(level)) {\n          levelGravities = graphGravities[itemid][level];\n\n          for (toItemId in levelGravities) {\n            if (levelGravities.hasOwnProperty(toItemId)) {\n              if (items.hasOwnProperty(toItemId)) {\n                toItemSlotKey = items[toItemId];\n                toItemSlot = slots.item(toItemSlotKey);\n\n                if (toItemSlot != null) {\n                  if (toItemSlot.position < 0) {\n                    /* on the left side */\n                    toItemSlot.balance += 1;\n                    itemSlot.balance -= 1;\n                    slots.iterateBack(function (slot, slotKey) {\n                      if (slotKey != itemSlotKey && slotKey != toItemSlotKey) {\n                        if (!slot.crossings[level]) {\n                          slot.crossings[level] = levelGravities[toItemId];\n                        } else {\n                          slot.crossings[level] += levelGravities[toItemId];\n                        }\n                      }\n                    }, itemSlotKey, toItemSlotKey); //ignore jslint\n                  } else {\n                    /* on the right side */\n                    toItemSlot.balance -= 1;\n                    itemSlot.balance += 1;\n                    slots.iterate(function (slot, slotKey) {\n                      if (slotKey != itemSlotKey && slotKey != toItemSlotKey) {\n                        if (!slot.crossings[level]) {\n                          slot.crossings[level] = levelGravities[toItemId];\n                        } else {\n                          slot.crossings[level] += levelGravities[toItemId];\n                        }\n                      }\n                    }, itemSlotKey, toItemSlotKey); //ignore jslint\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  slots.iterate(function (slot) {\n    var itemId = slot.itemId;\n\n    if (itemId != null && itemId != leftId && itemId != rightId) {\n      result.push(itemId);\n    }\n  });\n  return result;\n};\n\nFamilyBalance.prototype.ExtraGravity = function (level) {\n  this.commonParent = null; // OrgItem.id\n\n  this.fromParent = null; // OrgItem.id\n\n  this.toParent = null; // OrgItem.id\n\n  this.level = level;\n};\n\nFamilyBalance.prototype.getExtraGravity = function (data) {\n  var orgItemId,\n      orgItem,\n      result = {},\n\n  /* Key = OrgItem.id, Value= Hash {} having Key = level and Value = [] array of ExtraGravity objects*/\n  index,\n      len,\n      extraPartners,\n      extraPartner;\n  /* collect gravities for extra partners */\n\n  for (orgItemId in data.orgPartners) {\n    if (data.orgPartners.hasOwnProperty(orgItemId)) {\n      orgItem = data.orgTree.node(orgItemId);\n      extraPartners = data.orgPartners[orgItemId];\n\n      for (index = 0, len = extraPartners.length; index < len; index += 1) {\n        extraPartner = data.orgTree.node(extraPartners[index]);\n        this.addExtraGravitiesForConnection(data.orgTree, result, extraPartner, orgItem);\n      }\n    }\n  }\n\n  return result;\n};\n\nFamilyBalance.prototype.addExtraGravitiesForConnection = function (orgTree, extraGravities, fromItem, toItem) {\n  var extraGravityFrom = new this.ExtraGravity(fromItem.level),\n      extraGravityTo = new this.ExtraGravity(toItem.level);\n  /* find common parent for evry child and orgItem and create connector for evey parent in selection path */\n\n  orgTree.zipUp(this, fromItem.id, toItem.id, function (fromItemId, parentFromItemId, toItemId, parentToItemId) {\n    /* all parent items in chain up to the common root share the same gravity object for one connector */\n    this.addExtraGravityForItem(extraGravities, fromItemId, extraGravityFrom);\n    this.addExtraGravityForItem(extraGravities, toItemId, extraGravityTo);\n    /* initialize gravity objects */\n\n    if (parentFromItemId == parentToItemId) {\n      extraGravityFrom.commonParent = parentFromItemId;\n      extraGravityFrom.fromParent = fromItemId;\n      extraGravityFrom.toParent = toItemId;\n      extraGravityTo.commonParent = parentFromItemId;\n      extraGravityTo.fromParent = toItemId;\n      extraGravityTo.toParent = fromItemId;\n      return true;\n    }\n  });\n};\n\nFamilyBalance.prototype.addExtraGravityForItem = function (extraGravities, id, extraGravity) {\n  if (!extraGravities.hasOwnProperty(id)) {\n    extraGravities[id] = {};\n  }\n\n  if (extraGravities[id][extraGravity.level] == null) {\n    extraGravities[id][extraGravity.level] = [];\n  }\n\n  extraGravities[id][extraGravity.level].push(extraGravity);\n};\n\nFamilyBalance.prototype.attachFamilyToOrgChart = function (data, parent, family) {\n  var levelIndex,\n      familyRoot = family.items[0],\n      newOrgItem = null,\n      rootItem = parent; // fill in levels between parent and family root with invisible items\n\n  for (levelIndex = parent.level + 1; levelIndex < familyRoot.level; levelIndex += 1) {\n    data.maximumId += 1;\n    newOrgItem = new FamilyBalanceItem(data.maximumId, null, levelIndex);\n    data.orgTree.add(rootItem.id, newOrgItem.id, newOrgItem);\n    family.items.push(newOrgItem);\n    rootItem = newOrgItem;\n  } // attach family root \n\n\n  familyRoot.hideParentConnection = true;\n  data.orgTree.adopt(rootItem.id, familyRoot.id, familyRoot);\n};\n\nFamilyBalance.prototype.extractOrgChart = function (grandParentId, logicalFamily, primaryParentsPath, orgTree, orgPartners, itemByChildrenKey, famItemsExtracted, family) {\n  var index,\n      len,\n      children = [],\n      tempChildren,\n      childItem,\n      rootItem = null,\n      newOrgItem,\n      grandParent = logicalFamily.node(grandParentId);\n  /* extract root item */\n\n  newOrgItem = new FamilyBalanceItem(grandParent.id, family.id, grandParent.level);\n  orgTree.add(rootItem, newOrgItem.id, newOrgItem);\n  family.items.push(newOrgItem);\n  famItemsExtracted[grandParent.id] = grandParent;\n  grandParent.familyId = family.id;\n  /* extract its children */\n\n  children = this.extractChildren(grandParent, logicalFamily, primaryParentsPath, orgTree, orgPartners, itemByChildrenKey, famItemsExtracted, family);\n\n  while (children.length > 0) {\n    tempChildren = [];\n\n    for (index = 0, len = children.length; index < len; index += 1) {\n      childItem = children[index];\n      tempChildren = tempChildren.concat(this.extractChildren(childItem, logicalFamily, primaryParentsPath, orgTree, orgPartners, itemByChildrenKey, famItemsExtracted, family));\n    }\n\n    children = tempChildren;\n  }\n};\n\nFamilyBalance.prototype.extractChildren = function (parentItem, logicalFamily, primaryParentsPath, orgTree, orgPartners, itemByChildrenKey, famItemsExtracted, family) {\n  var result = [],\n      firstChild = null,\n      partnerItem = null,\n      newOrgItem;\n\n  if (logicalFamily.countChildren(parentItem.id) == 1) {\n    firstChild = logicalFamily.firstChild(parentItem.id);\n  }\n\n  if (itemByChildrenKey[firstChild] != null) {\n    /* all children already extracted */\n    partnerItem = itemByChildrenKey[firstChild];\n\n    if (orgPartners[partnerItem.id] == null) {\n      orgPartners[partnerItem.id] = [];\n    }\n\n    orgPartners[partnerItem.id].push(parentItem.id);\n    family.links.push(new this.FamLink(parentItem.id, firstChild));\n  } else {\n    if (firstChild != null) {\n      if (primaryParentsPath.hasOwnProperty(firstChild)) {\n        var realParent = primaryParentsPath[firstChild];\n\n        if (realParent != parentItem.id) {\n          if (orgPartners[realParent] == null) {\n            orgPartners[realParent] = [];\n          }\n\n          orgPartners[realParent].push(parentItem.id);\n          family.links.push(new this.FamLink(parentItem.id, firstChild));\n          return result;\n        }\n      }\n\n      itemByChildrenKey[firstChild] = parentItem;\n    }\n\n    logicalFamily.loopChildren(this, parentItem.id, function (childid, childItem, levelIndex) {\n      if (famItemsExtracted[childItem.id]) {\n        throw \"Many to many relations should not exist at this stage\";\n      }\n\n      result.push(childItem);\n      newOrgItem = new FamilyBalanceItem(childItem.id, family.id, childItem.level);\n      orgTree.add(parentItem.id, newOrgItem.id, newOrgItem);\n      family.items.push(newOrgItem);\n      famItemsExtracted[childItem.id] = true;\n      childItem.familyId = family.id;\n      return logicalFamily.SKIP;\n    });\n  }\n\n  return result;\n};\n\nFamilyBalance.prototype.recalcLevelsDepth = function (bundles, connectorStacks, treeLevels, logicalFamily) {\n  var index2,\n      len2,\n      index3,\n      len3,\n      itemPosition,\n      bundle,\n      bundlesToStack,\n      processed = {},\n      startIndex,\n      endIndex,\n      stackSegments;\n  treeLevels.loopLevels(this, function (levelIndex, treeLevel) {\n    var stacksSizes = new TreeLevelConnectorStackSize();\n    connectorStacks[levelIndex] = stacksSizes;\n    bundlesToStack = [];\n    treeLevels.loopLevelItems(this, levelIndex, function (itemid, familyItem, position) {\n      var fromItems = [],\n          toItems = [],\n          dotId = null;\n\n      if (!processed.hasOwnProperty(itemid)) {\n        processed[itemid] = true;\n\n        if (!familyItem.hideChildrenConnection) {\n          fromItems.push(itemid);\n        } else {\n          dotId = itemid;\n        }\n\n        logicalFamily.loopChildren(this, itemid, function (childid, child, index) {\n          logicalFamily.loopParents(this, childid, function (parentid, parentItem) {\n            if (!processed.hasOwnProperty(parentid)) {\n              processed[parentid] = true;\n\n              if (!parentItem.hideChildrenConnection) {\n                fromItems.push(parentid);\n              } else {\n                dotId = parentid;\n              }\n            }\n\n            return logicalFamily.SKIP;\n          });\n\n          if (!child.hideParentConnection) {\n            toItems.push(childid);\n          } else {\n            dotId = childid;\n          }\n\n          return logicalFamily.SKIP;\n        }); //ignore jslint\n\n        if (fromItems.length > 1 || toItems.length > 0) {\n          /* if bundle has more than one parent without children we draw connection line between parents */\n\n          /* if bundles has no parents, but has children we draw connectors between children, top loop */\n          bundle = new VerticalConnectorBundle(fromItems, toItems, dotId);\n          bundles.push(bundle);\n\n          if (fromItems.length > 1) {\n            bundlesToStack.push(bundle);\n          }\n        }\n      }\n    });\n\n    if (bundlesToStack.length > 0) {\n      /* find minimum and maximum partner index at level */\n      stackSegments = Pile();\n\n      for (index2 = 0, len2 = bundlesToStack.length; index2 < len2; index2 += 1) {\n        bundle = bundlesToStack[index2];\n        startIndex = null;\n        endIndex = null;\n\n        for (index3 = 0, len3 = bundle.fromItems.length; index3 < len3; index3 += 1) {\n          itemPosition = treeLevels.getItemPosition(bundle.fromItems[index3]);\n          startIndex = startIndex != null ? Math.min(startIndex, itemPosition) : itemPosition;\n          endIndex = endIndex != null ? Math.max(endIndex, itemPosition) : itemPosition;\n        }\n\n        stackSegments.add(startIndex, endIndex, bundle);\n      }\n\n      stacksSizes.parentsStackSize = stackSegments.resolve(this, function (from, to, bundle, offset, stackSize) {\n        bundle.fromOffset = offset + 1;\n        bundle.fromStackSize = stackSize;\n      }); //ignore jslint\n    }\n  });\n};","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/tasks/transformations/familyTransformations/FamilyBalance.js"],"names":["TreeLevels","LinkedHashItems","Tree","Graph","Pile","SortedList","FamilyBalanceItem","Slot","TreeLevelConnectorStackSize","VerticalConnectorBundle","FamilyBalance","prototype","balance","params","result","maximumId","treeLevels","bundles","connectorStacks","data","orgTree","orgPartners","itemByChildrenKey","minimumLevel","maximumLevel","createOrgTree","currentLevelIndex","index","loopLevels","treeItemId","treeItem","levelIndex","familyItem","logicalFamily","node","addItem","recalcLevelsDepth","Family","id","familyPriority","childFamilies","items","links","backLinks","arguments","length","FamLink","fromItem","toItem","len","index2","len2","familiesGraph","link","fromFamily","toFamily","sortedFamilies","sortedFamiliesHash","attachedFamilies","familyId","family","familyRootItem","rootItem","rootItems","bestRootItem","bestReference","spanningTree","extraGravities","grandChildren","orgItemRoot","famItemsExtracted","families","families2","hasNodes","loopRoots","grandParentId","grandParent","extractOrgChart","primaryParents","push","sort","a","b","aLevel","level","bLevel","addEdge","weight","edge","hasOwnProperty","getSpanningTree","loopPostOrder","nodeid","parentid","parent","parentFamily","children","loopChildren","childid","child","arrangeChildren","loopPreOrder","familyid","add","concat","loopParents","attachFamilyToOrgChart","getExtraGravity","getGrandChildren","balanceOrgTree","itemsPositions","itemsGroups","itemId","orgItem","parentId","Math","min","max","index3","len3","extraGravity","childExtraGravities","sortedChildren","subChildren","subOrgItem","leftId","rightId","levelExtraGravities","sequence","parentOrgItemId","parentOrgItem","levelid","graph","graphGravities","firstOrgItem","toItemId","childOrgItemId","childOrgItem","levelKey","commonParent","toParent","fromParent","childIndex","getTotalWeightGrowthSequence","balanceItems","slots","counter","positions","startSlotKey","endSlotKey","key","slot","itemid","itemsToAdd","bestSlotKey","bestSlot","bestSlotValue","bestSlotDistance","bestSlotBalance","bestSlotCrossings","slotValue","slotDistance","slotBalance","slotCrossings","itemGrandChildren","itemSlot","itemSlotKey","levelGravities","toItemSlot","userItemPosition","position","itemGroup","groupPositions","toItemSlotKey","previousContext","nextContext","iterate","slotKey","crossings","item","left","abs","right","insertBefore","clone","iterateBack","ExtraGravity","orgItemId","extraPartners","extraPartner","addExtraGravitiesForConnection","extraGravityFrom","extraGravityTo","zipUp","fromItemId","parentFromItemId","parentToItemId","addExtraGravityForItem","familyRoot","newOrgItem","hideParentConnection","adopt","primaryParentsPath","tempChildren","childItem","extractChildren","parentItem","firstChild","partnerItem","countChildren","realParent","SKIP","itemPosition","bundle","bundlesToStack","processed","startIndex","endIndex","stackSegments","treeLevel","stacksSizes","loopLevelItems","fromItems","toItems","dotId","hideChildrenConnection","getItemPosition","parentsStackSize","resolve","from","to","offset","stackSize","fromOffset","fromStackSize"],"mappings":"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","sourcesContent":["/*  This class transforms normalized logical family into levels of nodes.\n  The current approach to optimize items placement is to transform family into hierarchy of nodes and order \n  children of every node in the way minimizing number of intersections between connection lines.\n  1. Extract families into _families array of type FamilyItem. Family is sub tree of items logicalFamily. \n    In order to extract families out of logicalFamily we count from bottom to roots total number of descendants for evry item and then extract \n    sub hierarchy having minimum number of members. This process is repeated till all nodes are extracted into separate families.\n      orgPartners - When we extract families we store links to parents in other branches having the same children of \n      some already extracted item as partner in orgPartners hash\n    This hash table is used to create links collections between families\n    The orgTree collection is used to define final org hierarchy used to balance nodes in levels.\n  2. Use links in families to build family graph\n  3. Find maximum spanning tree of family graph\n  4. Since spanning tree is the tree we calculate number of descendants in every branch. So when we join families into one \n    org chart we sort them taking first child family having maximum number of links to its parent family\n    sortedFamilies collection\n  5. Using sortedFamilies collection we merge roots of families back to primary org chart. The rule of that backward merging is \n    to find ancestor in target tree having level less then root item of merged family.\n    this is done without extra collection creation via making changes in orgTree\n    If family has no links it is added to root of orgTree\n  6. Balance organizational chart in order to place items having extra connections close to each other. \n    Assign every extra link to every pair of parent nodes up to the root.\n  7. Scan orgTree hierarchy from root to bottom and balance children using extra links collected from children\n    So at the top most level we know number of links between children, so we sort them, then number of overlappings between branches should be minimal\n    Balancing algorithms finds maximum spanning tree in connections between children and groups them from bottom of that tree up to the root\n    In the way when groups having maximum mutual links placed close to each other.\n*/\nimport TreeLevels from '../../../algorithms/TreeLevels';\nimport LinkedHashItems from '../../../algorithms/LinkedHashItems';\nimport Tree from '../../../algorithms/Tree';\nimport Graph from '../../../algorithms/Graph';\nimport Pile from '../../../algorithms/Pile';\nimport SortedList from '../../../algorithms/SortedList';\nimport FamilyBalanceItem from './FamilyBalanceItem';\nimport Slot from '../../../models/Slot';\nimport TreeLevelConnectorStackSize from '../../../models/TreeLevelConnectorStackSize';\nimport VerticalConnectorBundle from '../../../connectors/VerticalConnectorBundle';\n\nexport default function FamilyBalance() {\n\n};\n\n//var params = {\n//  logicalFamily,\n//  maximumId,\n//  items\n//};\nFamilyBalance.prototype.balance = function (params) {\n  var result = {\n    maximumId: null,\n    treeLevels: TreeLevels(),\n    bundles: [],\n    connectorStacks: []\n  };\n\n  var data = {\n    orgTree: Tree(), /*tree OrgItem */\n    maximumId: params.maximumId,\n    orgPartners: {}, /* Creates extra partners collection of relations between visual tree items They are used to draw connectors between items in different branches of organizational chart*/\n    itemByChildrenKey: {},\n    minimumLevel: null,\n    maximumLevel: null\n  };\n\n  this.createOrgTree(params, data);\n\n  var currentLevelIndex, index = -1;\n  data.orgTree.loopLevels(this, function (treeItemId, treeItem, levelIndex) {\n    var familyItem = params.logicalFamily.node(treeItemId);\n    if (familyItem != null) {\n      if (currentLevelIndex !== levelIndex) {\n        currentLevelIndex = levelIndex;\n        index += 1;\n      }\n      result.treeLevels.addItem(index, treeItemId, familyItem);\n    }\n  });\n\n  this.recalcLevelsDepth(result.bundles, result.connectorStacks, result.treeLevels, params.logicalFamily);\n\n  result.maximumId = data.maximumId;\n\n  return result;\n};\n\nFamilyBalance.prototype.Family = function (id) {\n  this.id = null;\n  this.familyPriority = 1;\n  this.childFamilies = [];\n  this.items = [];\n\n  this.links = []; /* array of FamLink(s) */\n  this.backLinks = []; /* array of FamLink(s) */\n\n  if (arguments.length == 1) {\n    this.id = id;\n  }\n};\n\nFamilyBalance.prototype.FamLink = function (fromItem, toItem) {\n  this.fromItem = fromItem; /* FamilyItem.id */\n  this.toItem = toItem; /* FamilyItem.id */\n};\n\nFamilyBalance.prototype.createOrgTree = function (params, data) {\n  var index, len, index2, len2,\n    familiesGraph, /* Graph */\n    link, links,\n    fromFamily,\n    toFamily,\n    sortedFamilies = [], sortedFamiliesHash,\n    attachedFamilies,\n    familyId,\n    family,\n    familyRootItem,\n    fromItem,\n    toItem,\n    rootItem, rootItems, bestRootItem, bestReference,\n    spanningTree,\n    extraGravities, grandChildren,\n    orgItemRoot,\n    famItemsExtracted,\n    families = [],\n    families2;\n\n  if (params.logicalFamily.hasNodes() > 0) {\n    /* create hash of extracted family items */\n    famItemsExtracted = {};\n\n    familyId = 0;\n    families2 = [];\n    params.logicalFamily.loopRoots(this, function (grandParentId, grandParent) {\n      //ignore jslint\n      family = new this.Family(familyId);\n      /* extractOrgChart method extracts hiearchy of family members starting from grandParent and takes only non extracted family items \n       * For every extracted item it assigns its familyId, it is used for building families relations graph and finding cross family links\n      */\n      this.extractOrgChart(grandParentId, params.logicalFamily, params.primaryParents, data.orgTree, data.orgPartners, data.itemByChildrenKey, famItemsExtracted, family);\n      families.push(family);\n      families2.push(family);\n      familyId += 1;\n    });\n\n    families2.sort(function (a, b) {\n      /* sort families by root item level ASC and size DESC */\n      var aLevel = a.items[0].level,\n        bLevel = b.items[0].level;\n\n      return aLevel != bLevel ? (aLevel - bLevel) : (b.items.length - a.items.length);\n    });\n\n    sortedFamilies = [];\n    sortedFamiliesHash = {};\n    if (families.length > 0) {\n\n      /* Build families graph */\n      familiesGraph = Graph();\n      for (index = 0, len = families.length; index < len; index += 1) {\n        family = families[index];\n\n        for (index2 = 0, len2 = family.links.length; index2 < len2; index2 += 1) {\n          link = family.links[index2];\n\n          fromFamily = params.logicalFamily.node(link.fromItem).familyId;\n          toFamily = params.logicalFamily.node(link.toItem).familyId;\n\n          if (fromFamily != toFamily) {\n            familiesGraph.addEdge(fromFamily, toFamily, { weight: 0 });\n            familiesGraph.edge(fromFamily, toFamily).weight += 1;\n          }\n\n          families[toFamily].backLinks.push(new this.FamLink(link.toItem, link.fromItem));\n        }\n      }\n\n      /* Flatten families graph into array for merging */\n      while (sortedFamilies.length < families.length) {\n        for (index = 0, len = families2.length; index < len; index += 1) {\n          family = families2[index];\n\n          if (!sortedFamiliesHash.hasOwnProperty(family.id)) {\n\n            /* find maximum spanning tree of families graph*/\n            spanningTree = familiesGraph.getSpanningTree(family.id, function (edge) {\n              return -edge.weight;\n            }); //ignore jslint\n\n            if (spanningTree.node(family.id) != null) {\n\n              /* count number of sub families for every family in spanning tree and sorts child families desc*/\n              spanningTree.loopPostOrder(this, function (nodeid, node, parentid, parent) {\n                var family = families[nodeid],\n                  parentFamily = families[parentid],\n                  children = [];\n\n                if (parentid != null) {\n                  parentFamily.familyPriority = parentFamily.familyPriority + family.familyPriority;\n                }\n\n                children = [];\n                spanningTree.loopChildren(this, nodeid, function (childid, child, index) {\n                  children.push(childid);\n                });\n\n                children.sort(function (a, b) { return families[a].familyPriority - families[b].familyPriority; });\n                spanningTree.arrangeChildren(nodeid, children);\n              }); //ignore jslint\n\n              /* merge tree items in pre order sequence */\n              spanningTree.loopPreOrder(this, function (familyid, node) {\n                sortedFamilies.push(familyid);\n                sortedFamiliesHash[familyid] = true;\n              }); //ignore jslint\n\n            } else {\n              /* family has no links to any other family so we add it as orphant */\n              sortedFamilies.push(family.id);\n              sortedFamiliesHash[family.id] = true;\n            }\n          }\n        }\n      }\n    }\n\n    /* create chart root */\n    data.maximumId += 1;\n    orgItemRoot = new FamilyBalanceItem(data.maximumId, null, data.minimumLevel - 1);\n    data.orgTree.add(null, orgItemRoot.id, orgItemRoot);\n\n    /* Place family roots to organizational chart */\n    attachedFamilies = {};\n    for (index = 0, len = sortedFamilies.length; index < len; index += 1) {\n      family = families[sortedFamilies[index]];\n\n      rootItems = {}; // Hash where key = rootItem.id and value is number of references\n      bestRootItem = orgItemRoot;\n      bestReference = 0;\n      links = family.links.concat(family.backLinks);\n      for (index2 = 0; index2 < links.length; index2 += 1) {\n        link = links[index2];\n\n        toItem = data.orgTree.node(link.toItem);\n        fromItem = data.orgTree.node(link.fromItem);\n\n        if (attachedFamilies[toItem.familyId] === true) {\n          familyRootItem = family.items[0];\n          rootItem = toItem;\n\n          if (rootItem.level >= familyRootItem.level) {\n            data.orgTree.loopParents(this, rootItem.id, function (nodeid, node) {\n              rootItem = node;\n              if (node.level < familyRootItem.level) {\n                return true;\n              }\n            });//ignore jslint\n          }\n\n          if (rootItems.hasOwnProperty(rootItem.id)) {\n            rootItems[rootItem.id] += 1;\n          } else {\n            rootItems[rootItem.id] = 1;\n          }\n          /* family may be nested to multiple places, so we select root item having maximum connections with our new sub family */\n          if (bestReference < rootItems[rootItem.id]) {\n            bestRootItem = rootItem;\n            bestReference = rootItems[rootItem.id];\n          }\n        }\n\n\n      }\n\n      this.attachFamilyToOrgChart(data, bestRootItem, family);\n\n      attachedFamilies[family.id] = true;\n    }\n\n    /* balance organizational chart in order to place items having extra connections close to each other */\n    extraGravities = this.getExtraGravity(data);\n\n    /* count number of vertical connections for every item */\n    grandChildren = this.getGrandChildren(data);\n\n    /* scan orgTree hierarchy from root to bottom and balance its children */\n    this.balanceOrgTree(data.orgTree, extraGravities, grandChildren, params.itemsPositions, params.itemsGroups);\n  }\n};\n\nFamilyBalance.prototype.getGrandChildren = function (data) {\n  var result = {};  /* Key = OrgItem.id, Value= Hash {} having Key = level and Value = number of grand children*/\n\n  data.orgTree.loopPostOrder(this, function (itemId, orgItem, parentId, parent) {\n    var level;\n\n    data.minimumLevel = data.minimumLevel != null ? Math.min(data.minimumLevel, orgItem.level) : orgItem.level;\n    data.maximumLevel = data.maximumLevel != null ? Math.max(data.maximumLevel, orgItem.level) : orgItem.level;\n\n    if (parentId != null) {\n      if (!result[parentId]) {\n        result[parentId] = {};\n      }\n\n      level = orgItem.level - 1; /* project children qty to parent level, it is needed to match cross hierarchy connectors levels*/\n      if (!result[parentId][level]) {\n        result[parentId][level] = 1;\n      } else {\n        result[parentId][level] += 1;\n      }\n\n      if (result[itemId] != null) {\n        for (level in result[itemId]) {\n          if (result[itemId].hasOwnProperty(level)) {\n            if (!result[parentId][level]) {\n              result[parentId][level] = result[itemId][level];\n            } else {\n              result[parentId][level] += result[itemId][level];\n            }\n          }\n        }\n      }\n    }\n  });\n\n  return result;\n};\n\nFamilyBalance.prototype.balanceOrgTree = function (orgTree, extraGravities, grandChildren, itemsPositions, itemsGroups) {\n  var index2, len2,\n    index3, len3,\n    extraGravity,\n    childExtraGravities,\n    sortedChildren,\n    subChildren, subOrgItem,\n    leftId = '__left__',\n    rightId = '__right__',\n    levelExtraGravities,\n    sequence;\n\n  orgTree.loopLevels(this, function (parentOrgItemId, parentOrgItem, levelid) {\n    var graph = Graph(),\n      graphGravities = {},\n      firstOrgItem = null,\n      toItemId;\n    /* build gravities graph for children */\n    sortedChildren = [];\n    orgTree.loopChildren(this, parentOrgItem.id, function (childOrgItemId, childOrgItem, index) {\n      var levelKey;\n      if (firstOrgItem == null) {\n        firstOrgItem = childOrgItem;\n      }\n\n      graphGravities[childOrgItem.id] = {};\n      if (extraGravities.hasOwnProperty(childOrgItem.id)) {\n        childExtraGravities = extraGravities[childOrgItem.id];\n\n        for (levelKey in childExtraGravities) {\n          if (childExtraGravities.hasOwnProperty(levelKey)) {\n            levelExtraGravities = childExtraGravities[levelKey];\n\n            graphGravities[childOrgItem.id][levelKey] = {};\n            for (index2 = 0, len2 = levelExtraGravities.length; index2 < len2; index2 += 1) {\n              extraGravity = levelExtraGravities[index2];\n\n              if (extraGravity.commonParent == parentOrgItem.id) {\n                /* this is link between two children */\n                toItemId = extraGravity.toParent;\n              } else {\n                /* this is external link on left or on right side, we create virtual graph item ids for external links */\n                if (orgTree.node(extraGravity.fromParent).childIndex < orgTree.node(extraGravity.toParent).childIndex) {\n                  toItemId = rightId;\n                } else {\n                  toItemId = leftId;\n                }\n              }\n\n              /* add connection to graph */\n              if (childOrgItem.id != toItemId) {\n                graph.addEdge(childOrgItem.id, toItemId, { weight: 0 });\n                graph.edge(childOrgItem.id, toItemId).weight += 1.0;\n\n                if (graphGravities[childOrgItem.id][levelKey][toItemId] == null) {\n                  graphGravities[childOrgItem.id][levelKey][toItemId] = 0;\n                }\n                graphGravities[childOrgItem.id][levelKey][toItemId] += 1;\n              }\n            }\n          }\n        }\n      }\n      /* add extra zero connection to graph when child org item has no connections\n        it is connected to the first item in the graph with zero link\n      */\n      if (index > 0) {\n        graph.addEdge(childOrgItem.id, firstOrgItem.id, { weight: 0 });\n      }\n    });\n\n    if (firstOrgItem != null) {\n      /* sort items in graph from the most connected to the least */\n\n      sequence = [];\n\n      graph.getTotalWeightGrowthSequence(this,\n        function (a) { return a.weight; },\n        function (a) { sequence.push(a); }\n      ); //ignore jslint\n\n      if (sequence.length === 0) {\n        sequence = [firstOrgItem.id];\n      }\n\n      /* sort children from top to down */\n      subChildren = this.balanceItems(sequence, leftId, rightId, graphGravities, grandChildren, itemsPositions, itemsGroups);\n\n      /* save items indexes for further use */\n      for (index3 = 0, len3 = subChildren.length; index3 < len3; index3 += 1) {\n        subOrgItem = orgTree.node(subChildren[index3]);\n\n        subOrgItem.childIndex = index3;\n\n        sortedChildren.push(subOrgItem.id);\n      }\n    }\n    orgTree.arrangeChildren(parentOrgItem.id, sortedChildren);\n  });\n};\n\nFamilyBalance.prototype.balanceItems = function (sequence, leftId, rightId, graphGravities, grandChildren, itemsPositions, itemsGroups) {\n  var result = [],\n    index,\n    slots = LinkedHashItems(), // key = counter++, value =  slot object\n    counter = 0,\n    positions = {}, // hash[groupId] = SortedList, key = user defined item position, value = key in slots -- create only when user defined itemsPositions exists for items\n    startSlotKey, endSlotKey,\n    key, slot,\n    items = {}, itemid, itemsToAdd,\n    bestSlotKey, bestSlot, bestSlotValue, bestSlotDistance, bestSlotBalance, bestSlotCrossings,\n    slotValue, slotDistance, slotBalance, slotCrossings,\n    itemGrandChildren,\n    itemSlot, itemSlotKey,\n    level, levelGravities, toItemId, toItemSlot,\n    userItemPosition, position, itemGroup, groupPositions,\n    toItemSlotKey;\n\n  /* populate initital slots */\n  itemsToAdd = [leftId, null, rightId];\n  for (index = 0; index < itemsToAdd.length; index += 1) {\n    itemid = itemsToAdd[index];\n    key = counter++;\n    slot = new Slot(itemid);\n    slot.position = index;\n    slots.add(key, slot);\n    if (itemid !== null) {\n      items[itemid] = key;\n    }\n  }\n\n  for (index = 0; index < sequence.length; index += 1) {\n    itemid = sequence[index];\n\n    /* ignore left and right margin */\n    if (itemid != leftId && itemid != rightId) {\n\n      bestSlotKey = null;\n      bestSlot = null;\n      bestSlotValue = null;\n      bestSlotDistance = null;\n      bestSlotBalance = null;\n      bestSlotCrossings = null;\n\n      startSlotKey = null;\n      endSlotKey = null;\n      if (itemsGroups.hasOwnProperty(itemid)) {\n        itemGroup = itemsGroups[itemid];\n        if (positions.hasOwnProperty(itemGroup)) {\n          userItemPosition = itemsPositions[itemid];\n          groupPositions = positions[itemGroup];\n          startSlotKey = groupPositions.previousContext(userItemPosition);\n          endSlotKey = groupPositions.nextContext(userItemPosition);\n        }\n      }\n\n      slots.iterate(function (slot, slotKey) {\n        var level, toItemId,\n          levelGravities,\n          toItemSlot;\n\n        if (slot.itemId == null) {\n          itemGrandChildren = grandChildren[itemid];\n          slotValue = 0;\n          slotDistance = 0;\n          slotBalance = 0;\n          slotCrossings = 0;\n\n          for (level in slot.crossings) {\n            if (slot.crossings.hasOwnProperty(level)) {\n              if (itemGrandChildren && itemGrandChildren[level] != null) {\n                slotValue += slot.crossings[level] * itemGrandChildren[level];\n              }\n              slotCrossings += slot.crossings[level];\n            }\n          }\n          for (level in graphGravities[itemid]) {\n            if (graphGravities[itemid].hasOwnProperty(level)) {\n              levelGravities = graphGravities[itemid][level];\n              for (toItemId in levelGravities) {\n                if (levelGravities.hasOwnProperty(toItemId)) {\n                  if (items.hasOwnProperty(toItemId)) {\n                    toItemSlot = slots.item(items[toItemId]);\n                    if (toItemSlot != null) {\n                      if (toItemSlot.position < slot.position) {\n                        /* on the left side */\n                        slotValue += ((slot.left[level] || 0.0) - (toItemSlot.left[level] || 0.0));\n                        slotBalance += Math.abs(toItemSlot.balance + 1);\n                      } else {\n                        /* on the right side */\n                        slotValue += ((slot.right[level] || 0.0) - (toItemSlot.right[level] || 0.0));\n                        slotBalance += Math.abs(toItemSlot.balance - 1);\n                      }\n                      slotDistance += Math.abs(toItemSlot.position - slot.position);\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          if (bestSlotValue == null ||\n            bestSlotValue > slotValue ||\n            (bestSlotValue == slotValue &&\n              (bestSlotDistance > slotDistance ||\n                (bestSlotDistance == slotDistance &&\n                  (bestSlotBalance > slotBalance ||\n                    (bestSlotBalance == slotBalance && bestSlotCrossings > slotCrossings)\n                  )\n                )\n              )\n            )\n          ) {\n            bestSlotKey = slotKey;\n            bestSlotValue = slotValue;\n            bestSlot = slot;\n            bestSlotDistance = slotDistance;\n            bestSlotBalance = slotBalance;\n            bestSlotCrossings = slotCrossings;\n          }\n        }\n      }, startSlotKey, endSlotKey); //ignore jslint\n\n      slots.insertBefore(bestSlotKey, counter++, bestSlot.clone(null));\n      items[itemid] = counter;\n      itemSlotKey = counter;\n      itemSlot = bestSlot.clone(itemid);\n      if (itemsPositions.hasOwnProperty(itemid)) {\n        itemGroup = itemsGroups[itemid];\n        if (!positions.hasOwnProperty(itemGroup)) {\n          positions[itemGroup] = SortedList();\n        }\n        groupPositions = positions[itemGroup];\n        groupPositions.add(itemsPositions[itemid], counter);\n      }\n      slots.insertBefore(bestSlotKey, counter++, itemSlot);\n\n      /* add new item grand children qty to all slots to their grand totals for right & left sides */\n      itemSlot.position = 0;\n      position = 0;\n      slots.iterate(function (slot, slotKey) {\n        var level, itemGrandChildren;\n        if (slotKey != itemSlotKey) {\n          itemGrandChildren = grandChildren[itemid];\n          for (level in itemGrandChildren) {\n            if (itemGrandChildren.hasOwnProperty(level)) {\n              if (!slot.left[level]) {\n                slot.left[level] = itemGrandChildren[level];\n              } else {\n                slot.left[level] += itemGrandChildren[level];\n              }\n            }\n          }\n          position += 1;\n          slot.position = position;\n        }\n      }, itemSlotKey); //ignore jslint\n\n      position = 0;\n      slots.iterateBack(function (slot, slotKey) {\n        var level, itemGrandChildren;\n        if (slotKey != itemSlotKey) {\n          itemGrandChildren = grandChildren[itemid];\n          for (level in grandChildren[itemid]) {\n            if (grandChildren[itemid].hasOwnProperty(level)) {\n              if (!slot.right[level]) {\n                slot.right[level] = itemGrandChildren[level];\n              } else {\n                slot.right[level] += itemGrandChildren[level];\n              }\n            }\n          }\n          position -= 1;\n          slot.position = position;\n        }\n      }, itemSlotKey); //ignore jslint\n\n      /* add crossings */\n      for (level in graphGravities[itemid]) {\n        if (graphGravities[itemid].hasOwnProperty(level)) {\n          levelGravities = graphGravities[itemid][level];\n          for (toItemId in levelGravities) {\n            if (levelGravities.hasOwnProperty(toItemId)) {\n              if (items.hasOwnProperty(toItemId)) {\n                toItemSlotKey = items[toItemId];\n                toItemSlot = slots.item(toItemSlotKey);\n                if (toItemSlot != null) {\n                  if (toItemSlot.position < 0) {\n                    /* on the left side */\n                    toItemSlot.balance += 1;\n                    itemSlot.balance -= 1;\n                    slots.iterateBack(function (slot, slotKey) {\n                      if (slotKey != itemSlotKey && slotKey != toItemSlotKey) {\n                        if (!slot.crossings[level]) {\n                          slot.crossings[level] = levelGravities[toItemId];\n                        } else {\n                          slot.crossings[level] += levelGravities[toItemId];\n                        }\n                      }\n                    }, itemSlotKey, toItemSlotKey); //ignore jslint\n                  } else {\n                    /* on the right side */\n                    toItemSlot.balance -= 1;\n                    itemSlot.balance += 1;\n                    slots.iterate(function (slot, slotKey) {\n                      if (slotKey != itemSlotKey && slotKey != toItemSlotKey) {\n                        if (!slot.crossings[level]) {\n                          slot.crossings[level] = levelGravities[toItemId];\n                        } else {\n                          slot.crossings[level] += levelGravities[toItemId];\n                        }\n                      }\n                    }, itemSlotKey, toItemSlotKey); //ignore jslint\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  slots.iterate(function (slot) {\n    var itemId = slot.itemId;\n    if (itemId != null && itemId != leftId && itemId != rightId) {\n      result.push(itemId);\n    }\n  });\n\n  return result;\n};\n\nFamilyBalance.prototype.ExtraGravity = function (level) {\n  this.commonParent = null; // OrgItem.id\n  this.fromParent = null; // OrgItem.id\n  this.toParent = null; // OrgItem.id\n  this.level = level;\n};\n\nFamilyBalance.prototype.getExtraGravity = function (data) {\n  var orgItemId, orgItem,\n    result = {}, /* Key = OrgItem.id, Value= Hash {} having Key = level and Value = [] array of ExtraGravity objects*/\n    index, len,\n    extraPartners, extraPartner;\n\n  /* collect gravities for extra partners */\n  for (orgItemId in data.orgPartners) {\n    if (data.orgPartners.hasOwnProperty(orgItemId)) {\n      orgItem = data.orgTree.node(orgItemId);\n      extraPartners = data.orgPartners[orgItemId];\n\n      for (index = 0, len = extraPartners.length; index < len; index += 1) {\n        extraPartner = data.orgTree.node(extraPartners[index]);\n\n        this.addExtraGravitiesForConnection(data.orgTree, result, extraPartner, orgItem);\n      }\n    }\n  }\n\n  return result;\n};\n\nFamilyBalance.prototype.addExtraGravitiesForConnection = function (orgTree, extraGravities, fromItem, toItem) {\n  var extraGravityFrom = new this.ExtraGravity(fromItem.level),\n    extraGravityTo = new this.ExtraGravity(toItem.level);\n\n  /* find common parent for evry child and orgItem and create connector for evey parent in selection path */\n  orgTree.zipUp(this, fromItem.id, toItem.id, function (fromItemId, parentFromItemId, toItemId, parentToItemId) {\n    /* all parent items in chain up to the common root share the same gravity object for one connector */\n    this.addExtraGravityForItem(extraGravities, fromItemId, extraGravityFrom);\n    this.addExtraGravityForItem(extraGravities, toItemId, extraGravityTo);\n\n    /* initialize gravity objects */\n    if (parentFromItemId == parentToItemId) {\n      extraGravityFrom.commonParent = parentFromItemId;\n      extraGravityFrom.fromParent = fromItemId;\n      extraGravityFrom.toParent = toItemId;\n\n      extraGravityTo.commonParent = parentFromItemId;\n      extraGravityTo.fromParent = toItemId;\n      extraGravityTo.toParent = fromItemId;\n\n      return true;\n    }\n  });\n};\n\nFamilyBalance.prototype.addExtraGravityForItem = function (extraGravities, id, extraGravity) {\n  if (!extraGravities.hasOwnProperty(id)) {\n    extraGravities[id] = {};\n  }\n  if (extraGravities[id][extraGravity.level] == null) {\n    extraGravities[id][extraGravity.level] = [];\n  }\n  extraGravities[id][extraGravity.level].push(extraGravity);\n};\n\nFamilyBalance.prototype.attachFamilyToOrgChart = function (data, parent, family) {\n  var levelIndex,\n    familyRoot = family.items[0],\n    newOrgItem = null,\n    rootItem = parent;\n\n  // fill in levels between parent and family root with invisible items\n  for (levelIndex = parent.level + 1; levelIndex < familyRoot.level; levelIndex += 1) {\n    data.maximumId += 1;\n    newOrgItem = new FamilyBalanceItem(data.maximumId, null, levelIndex);\n    data.orgTree.add(rootItem.id, newOrgItem.id, newOrgItem);\n    family.items.push(newOrgItem);\n\n    rootItem = newOrgItem;\n  }\n\n  // attach family root \n  familyRoot.hideParentConnection = true;\n  data.orgTree.adopt(rootItem.id, familyRoot.id, familyRoot);\n};\n\nFamilyBalance.prototype.extractOrgChart = function (grandParentId, logicalFamily, primaryParentsPath, orgTree, orgPartners, itemByChildrenKey, famItemsExtracted, family) {\n  var index, len,\n    children = [], tempChildren,\n    childItem,\n    rootItem = null,\n    newOrgItem,\n    grandParent = logicalFamily.node(grandParentId);\n\n  /* extract root item */\n  newOrgItem = new FamilyBalanceItem(grandParent.id, family.id, grandParent.level);\n  orgTree.add(rootItem, newOrgItem.id, newOrgItem);\n  family.items.push(newOrgItem);\n\n  famItemsExtracted[grandParent.id] = grandParent;\n  grandParent.familyId = family.id;\n\n  /* extract its children */\n  children = this.extractChildren(grandParent, logicalFamily, primaryParentsPath, orgTree, orgPartners, itemByChildrenKey, famItemsExtracted, family);\n\n  while (children.length > 0) {\n    tempChildren = [];\n    for (index = 0, len = children.length; index < len; index += 1) {\n      childItem = children[index];\n      tempChildren = tempChildren.concat(this.extractChildren(childItem, logicalFamily, primaryParentsPath, orgTree, orgPartners, itemByChildrenKey, famItemsExtracted, family));\n    }\n\n    children = tempChildren;\n  }\n};\n\nFamilyBalance.prototype.extractChildren = function (parentItem, logicalFamily, primaryParentsPath, orgTree, orgPartners, itemByChildrenKey, famItemsExtracted, family) {\n  var result = [],\n    firstChild = null,\n    partnerItem = null,\n    newOrgItem;\n\n  if (logicalFamily.countChildren(parentItem.id) == 1) {\n    firstChild = logicalFamily.firstChild(parentItem.id);\n  }\n\n  if (itemByChildrenKey[firstChild] != null) {\n    /* all children already extracted */\n    partnerItem = itemByChildrenKey[firstChild];\n\n    if (orgPartners[partnerItem.id] == null) {\n      orgPartners[partnerItem.id] = [];\n    }\n    orgPartners[partnerItem.id].push(parentItem.id);\n\n    family.links.push(new this.FamLink(parentItem.id, firstChild));\n  } else {\n    if (firstChild != null) {\n      if (primaryParentsPath.hasOwnProperty(firstChild)) {\n        var realParent = primaryParentsPath[firstChild];\n        if (realParent != parentItem.id) {\n          if (orgPartners[realParent] == null) {\n            orgPartners[realParent] = [];\n          }\n          orgPartners[realParent].push(parentItem.id);\n          family.links.push(new this.FamLink(parentItem.id, firstChild));\n          return result;\n        }\n      }\n      itemByChildrenKey[firstChild] = parentItem;\n    }\n\n    logicalFamily.loopChildren(this, parentItem.id, function (childid, childItem, levelIndex) {\n      if (famItemsExtracted[childItem.id]) {\n        throw \"Many to many relations should not exist at this stage\";\n      }\n      result.push(childItem);\n\n      newOrgItem = new FamilyBalanceItem(childItem.id, family.id, childItem.level);\n      orgTree.add(parentItem.id, newOrgItem.id, newOrgItem);\n      family.items.push(newOrgItem);\n\n      famItemsExtracted[childItem.id] = true;\n\n      childItem.familyId = family.id;\n      return logicalFamily.SKIP;\n    });\n  }\n  return result;\n};\n\nFamilyBalance.prototype.recalcLevelsDepth = function (bundles, connectorStacks, treeLevels, logicalFamily) {\n  var index2, len2,\n    index3, len3,\n    itemPosition,\n    bundle, bundlesToStack,\n    processed = {},\n    startIndex, endIndex, stackSegments;\n\n\n  treeLevels.loopLevels(this, function (levelIndex, treeLevel) {\n    var stacksSizes = new TreeLevelConnectorStackSize();\n    connectorStacks[levelIndex] = stacksSizes;\n\n    bundlesToStack = [];\n\n    treeLevels.loopLevelItems(this, levelIndex, function (itemid, familyItem, position) {\n      var fromItems = [],\n        toItems = [],\n        dotId = null;\n      if (!processed.hasOwnProperty(itemid)) {\n        processed[itemid] = true;\n        if (!familyItem.hideChildrenConnection) {\n          fromItems.push(itemid);\n        } else {\n          dotId = itemid;\n        }\n\n        logicalFamily.loopChildren(this, itemid, function (childid, child, index) {\n          logicalFamily.loopParents(this, childid, function (parentid, parentItem) {\n            if (!processed.hasOwnProperty(parentid)) {\n              processed[parentid] = true;\n              if (!parentItem.hideChildrenConnection) {\n                fromItems.push(parentid);\n              } else {\n                dotId = parentid;\n              }\n            }\n            return logicalFamily.SKIP;\n          });\n\n          if (!child.hideParentConnection) {\n            toItems.push(childid);\n          } else {\n            dotId = childid;\n          }\n          return logicalFamily.SKIP;\n        }); //ignore jslint\n\n        if (fromItems.length > 1 || toItems.length > 0) {\n          /* if bundle has more than one parent without children we draw connection line between parents */\n          /* if bundles has no parents, but has children we draw connectors between children, top loop */\n          bundle = new VerticalConnectorBundle(fromItems, toItems, dotId);\n\n          bundles.push(bundle);\n\n          if (fromItems.length > 1) {\n            bundlesToStack.push(bundle);\n          }\n        }\n      }\n    });\n\n    if (bundlesToStack.length > 0) {\n      /* find minimum and maximum partner index at level */\n      stackSegments = Pile();\n      for (index2 = 0, len2 = bundlesToStack.length; index2 < len2; index2 += 1) {\n        bundle = bundlesToStack[index2];\n\n        startIndex = null;\n        endIndex = null;\n        for (index3 = 0, len3 = bundle.fromItems.length; index3 < len3; index3 += 1) {\n          itemPosition = treeLevels.getItemPosition(bundle.fromItems[index3]);\n\n          startIndex = (startIndex != null) ? Math.min(startIndex, itemPosition) : itemPosition;\n          endIndex = (endIndex != null) ? Math.max(endIndex, itemPosition) : itemPosition;\n        }\n        stackSegments.add(startIndex, endIndex, bundle);\n      }\n\n      stacksSizes.parentsStackSize = stackSegments.resolve(this, function (from, to, bundle, offset, stackSize) {\n        bundle.fromOffset = offset + 1;\n        bundle.fromStackSize = stackSize;\n      });//ignore jslint\n    }\n  });\n};"]},"metadata":{},"sourceType":"module"}