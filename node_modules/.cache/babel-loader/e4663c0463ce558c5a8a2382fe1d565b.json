{"ast":null,"code":"import BaseShape from './BaseShape';\nimport Rect from '../structs/Rect';\nimport Vector from '../structs/Vector';\nimport MoveSegment from '../structs/MoveSegment';\nimport LineSegment from '../structs/LineSegment';\nimport { PlacementType, ConnectorShapeType, ConnectorLabelPlacementType } from '../../enums';\nexport default function ConnectorStraight() {}\n;\nConnectorStraight.prototype = new BaseShape();\n\nConnectorStraight.prototype.draw = function (buffer, linePaletteItem, fromRect, toRect, linesOffset, bundleOffset, labelSize, panelSize, connectorShapeType, labelOffset, labelPlacementType, hasLabel, connectorAnnotationOffsetResolver, onLabelPlacement, labelConfig) {\n  var fromPoint,\n      toPoint,\n      betweenPoint,\n      vector,\n      newVector,\n      offset = linesOffset / 2,\n      labelPlacement = null,\n      fromLabelPlacement = PlacementType.Auto,\n      toLabelPlacement = PlacementType.Auto,\n      self = this;\n  vector = new Vector(fromRect.centerPoint(), toRect.centerPoint());\n  fromRect.loopEdges(function (sideVector, placementType) {\n    fromPoint = sideVector.getIntersectionPoint(vector, true, 1.0);\n    fromLabelPlacement = placementType;\n    return fromPoint != null;\n  });\n  toRect.loopEdges(function (sideVector, placementType) {\n    toPoint = sideVector.getIntersectionPoint(vector, true, 1.0);\n    toLabelPlacement = placementType;\n    return toPoint != null;\n  });\n\n  if (fromPoint != null && toPoint != null) {\n    var baseVector = new Vector(fromPoint, toPoint);\n    connectorAnnotationOffsetResolver.getOffset(baseVector, function (offsetIndex, bundleSize, direction) {\n      var tempOffset = (offsetIndex * bundleOffset - (bundleSize - 1) * bundleOffset / 2.0) * direction;\n      baseVector.offset(tempOffset);\n      fromPoint = baseVector.from;\n      toPoint = baseVector.to;\n\n      switch (connectorShapeType) {\n        case ConnectorShapeType.TwoWay:\n          newVector = new Vector(toPoint.clone(), fromPoint.clone());\n          newVector.offset(offset);\n\n          self._drawLine(buffer, linePaletteItem, newVector.from, newVector.to, false);\n\n          newVector = new Vector(fromPoint.clone(), toPoint.clone());\n          newVector.offset(offset);\n\n          self._drawLine(buffer, linePaletteItem, newVector.from, newVector.to, false);\n\n          break;\n\n        case ConnectorShapeType.OneWay:\n          self._drawLine(buffer, linePaletteItem, fromPoint, toPoint, false);\n\n          break;\n\n        case ConnectorShapeType.BothWay:\n          self._drawLine(buffer, linePaletteItem, fromPoint, toPoint, true);\n\n          break;\n      }\n\n      if (hasLabel) {\n        /* end points labels placement */\n        switch (labelPlacementType) {\n          case ConnectorLabelPlacementType.From:\n            labelPlacement = self._getLabelPositionBySnapPoint(fromPoint.x, fromPoint.y, labelSize.width, labelSize.height, labelOffset, fromLabelPlacement);\n            break;\n\n          case ConnectorLabelPlacementType.Between:\n            betweenPoint = self._betweenPoint(fromPoint, toPoint);\n            labelPlacement = self._getLabelPositionBySnapPoint(betweenPoint.x, betweenPoint.y, labelSize.width, labelSize.height, labelOffset, PlacementType.Right);\n            break;\n\n          case ConnectorLabelPlacementType.To:\n            labelPlacement = self._getLabelPositionBySnapPoint(toPoint.x, toPoint.y, labelSize.width, labelSize.height, labelOffset, toLabelPlacement);\n            break;\n\n          default:\n            break;\n        }\n\n        if (onLabelPlacement != null) {\n          onLabelPlacement.call(this, labelPlacement, labelConfig);\n        }\n      }\n    });\n  }\n};\n\nConnectorStraight.prototype._drawLine = function (buffer, linePaletteItem, fromPoint, toPoint, bothWays) {\n  var polyline;\n  buffer.addInverted(function (invertedBuffer) {\n    polyline = invertedBuffer.getPolyline(linePaletteItem);\n    polyline.addSegment(new MoveSegment(fromPoint));\n    polyline.addSegment(new LineSegment(toPoint));\n    polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n      polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n    }); //ignore jslint\n  }, false); //ignore jslint\n\n  if (bothWays) {\n    polyline = buffer.getPolyline(linePaletteItem);\n    polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n      polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n    }); //ignore jslint\n  }\n};\n\nConnectorStraight.prototype._getLabelPositionBySnapPoint = function (x, y, labelWidth, labelHeight, labelOffset, placementType) {\n  var result = null;\n\n  switch (placementType) {\n    case PlacementType.Auto:\n    case PlacementType.Top:\n      result = new Rect(x - labelWidth / 2.0, y - labelOffset - labelHeight, labelWidth, labelHeight);\n      break;\n\n    case PlacementType.Right:\n      result = new Rect(x + labelOffset, y - labelHeight / 2.0, labelWidth, labelHeight);\n      break;\n\n    case PlacementType.Bottom:\n      result = new Rect(x - labelWidth / 2.0, y + labelOffset, labelWidth, labelHeight);\n      break;\n\n    case PlacementType.Left:\n      result = new Rect(x - labelWidth - labelOffset, y - labelHeight / 2.0, labelWidth, labelHeight);\n      break;\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/graphics/shapes/ConnectorStraight.js"],"names":["BaseShape","Rect","Vector","MoveSegment","LineSegment","PlacementType","ConnectorShapeType","ConnectorLabelPlacementType","ConnectorStraight","prototype","draw","buffer","linePaletteItem","fromRect","toRect","linesOffset","bundleOffset","labelSize","panelSize","connectorShapeType","labelOffset","labelPlacementType","hasLabel","connectorAnnotationOffsetResolver","onLabelPlacement","labelConfig","fromPoint","toPoint","betweenPoint","vector","newVector","offset","labelPlacement","fromLabelPlacement","Auto","toLabelPlacement","self","centerPoint","loopEdges","sideVector","placementType","getIntersectionPoint","baseVector","getOffset","offsetIndex","bundleSize","direction","tempOffset","from","to","TwoWay","clone","_drawLine","OneWay","BothWay","From","_getLabelPositionBySnapPoint","x","y","width","height","Between","_betweenPoint","Right","To","call","bothWays","polyline","addInverted","invertedBuffer","getPolyline","addSegment","addArrow","lineWidth","mergeTo","paletteItem","labelWidth","labelHeight","result","Top","Bottom","Left"],"mappings":"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","sourcesContent":["import BaseShape from './BaseShape';\nimport Rect from '../structs/Rect';\nimport Vector from '../structs/Vector';\nimport MoveSegment from '../structs/MoveSegment';\nimport LineSegment from '../structs/LineSegment';\nimport { PlacementType, ConnectorShapeType, ConnectorLabelPlacementType } from '../../enums';\n\n\nexport default function ConnectorStraight() {\n\n};\n\nConnectorStraight.prototype = new BaseShape();\n\nConnectorStraight.prototype.draw = function (buffer, linePaletteItem, fromRect, toRect, linesOffset, bundleOffset, labelSize, panelSize, connectorShapeType, labelOffset, labelPlacementType, hasLabel,\n  connectorAnnotationOffsetResolver, onLabelPlacement, labelConfig) {\n  var fromPoint, toPoint, betweenPoint,\n    vector, newVector,\n    offset = linesOffset / 2,\n    labelPlacement = null,\n    fromLabelPlacement = PlacementType.Auto,\n    toLabelPlacement = PlacementType.Auto,\n    self = this;\n\n  vector = new Vector(fromRect.centerPoint(), toRect.centerPoint());\n\n  fromRect.loopEdges(function (sideVector, placementType) {\n    fromPoint = sideVector.getIntersectionPoint(vector, true, 1.0);\n    fromLabelPlacement = placementType;\n    return (fromPoint != null);\n  });\n\n  toRect.loopEdges(function (sideVector, placementType) {\n    toPoint = sideVector.getIntersectionPoint(vector, true, 1.0);\n    toLabelPlacement = placementType;\n    return (toPoint != null);\n  });\n\n  if (fromPoint != null && toPoint != null) {\n    var baseVector = new Vector(fromPoint, toPoint);\n    connectorAnnotationOffsetResolver.getOffset(baseVector, function (offsetIndex, bundleSize, direction) {\n      var tempOffset = (offsetIndex * bundleOffset - (bundleSize - 1) * bundleOffset / 2.0) * direction;\n      baseVector.offset(tempOffset);\n      fromPoint = baseVector.from;\n      toPoint = baseVector.to;\n\n      switch (connectorShapeType) {\n        case ConnectorShapeType.TwoWay:\n          newVector = new Vector(toPoint.clone(), fromPoint.clone());\n          newVector.offset(offset);\n          self._drawLine(buffer, linePaletteItem, newVector.from, newVector.to, false);\n\n          newVector = new Vector(fromPoint.clone(), toPoint.clone());\n          newVector.offset(offset);\n          self._drawLine(buffer, linePaletteItem, newVector.from, newVector.to, false);\n          break;\n        case ConnectorShapeType.OneWay:\n          self._drawLine(buffer, linePaletteItem, fromPoint, toPoint, false);\n          break;\n        case ConnectorShapeType.BothWay:\n          self._drawLine(buffer, linePaletteItem, fromPoint, toPoint, true);\n          break;\n      }\n\n      if (hasLabel) {\n        /* end points labels placement */\n        switch (labelPlacementType) {\n          case ConnectorLabelPlacementType.From:\n            labelPlacement = self._getLabelPositionBySnapPoint(fromPoint.x, fromPoint.y, labelSize.width, labelSize.height, labelOffset, fromLabelPlacement);\n            break;\n          case ConnectorLabelPlacementType.Between:\n            betweenPoint = self._betweenPoint(fromPoint, toPoint);\n            labelPlacement = self._getLabelPositionBySnapPoint(betweenPoint.x, betweenPoint.y, labelSize.width, labelSize.height, labelOffset, PlacementType.Right);\n            break;\n          case ConnectorLabelPlacementType.To:\n            labelPlacement = self._getLabelPositionBySnapPoint(toPoint.x, toPoint.y, labelSize.width, labelSize.height, labelOffset, toLabelPlacement);\n            break;\n          default:\n            break;\n        }\n\n        if (onLabelPlacement != null) {\n          onLabelPlacement.call(this, labelPlacement, labelConfig);\n        }\n      }\n    });\n\n  }\n};\n\nConnectorStraight.prototype._drawLine = function (buffer, linePaletteItem, fromPoint, toPoint, bothWays) {\n  var polyline;\n\n  buffer.addInverted(function (invertedBuffer) {\n    polyline = invertedBuffer.getPolyline(linePaletteItem);\n    polyline.addSegment(new MoveSegment(fromPoint));\n    polyline.addSegment(new LineSegment(toPoint));\n\n    polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n      polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n    }); //ignore jslint\n  }, false);//ignore jslint\n\n  if (bothWays) {\n    polyline = buffer.getPolyline(linePaletteItem);\n    polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n      polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n    }); //ignore jslint\n  }\n};\n\nConnectorStraight.prototype._getLabelPositionBySnapPoint = function (x, y, labelWidth, labelHeight, labelOffset, placementType) {\n  var result = null;\n  switch (placementType) {\n    case PlacementType.Auto:\n    case PlacementType.Top:\n      result = new Rect(x - labelWidth / 2.0, y - labelOffset - labelHeight, labelWidth, labelHeight);\n      break;\n    case PlacementType.Right:\n      result = new Rect(x + labelOffset, y - labelHeight / 2.0, labelWidth, labelHeight);\n      break;\n    case PlacementType.Bottom:\n      result = new Rect(x - labelWidth / 2.0, y + labelOffset, labelWidth, labelHeight);\n      break;\n    case PlacementType.Left:\n      result = new Rect(x - labelWidth - labelOffset, y - labelHeight / 2.0, labelWidth, labelHeight);\n      break;\n  }\n  return result;\n};"]},"metadata":{},"sourceType":"module"}