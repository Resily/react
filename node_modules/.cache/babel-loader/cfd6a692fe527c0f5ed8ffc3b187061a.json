{"ast":null,"code":"import Point from '../graphics/structs/Point';\nimport Vector from '../graphics/structs/Vector';\nimport LinkedHashItems from './LinkedHashItems';\n/**\n * Callback function to iterate over result shapes\n * \n * @callback onMergedRectangleItemCallback\n * @param {Point[]} points Collection of points tracing margin around result area formed via merge of rectangles.\n * The outer shape margin has clock wise sequence of data points. Internal holes inside of the shape are formed by counter clock wise \n * sequence of data points.\n */\n\n/**\n * Merges collection of rectangles into shapes. Calls callback function to pass result sequences of data points.\n * \n * @param {Object} thisArg The callback function invocation context\n * @param {Rect[]} items Collection of rectangles.\n * @param {onMergedRectangleItemCallback} onItem Callback function to pass result sequences of margin data points.\n */\n\nexport default function getMergedRectangles(thisArg, items, onItem) {\n  var index, len, index2, len2, point;\n  items.sort(function (a, b) {\n    if (a.x == b.x) {\n      return a.y - b.y;\n    }\n\n    return a.x - b.x;\n  });\n  var points = [];\n  var pointsHash = {};\n\n  for (index = 0, len = items.length; index < len; index += 1) {\n    var item = items[index];\n    var xs = [item.x, item.right()];\n\n    for (var k = 0; k < xs.length; k += 1) {\n      var x = xs[k];\n      point = pointsHash[x];\n\n      if (point == null) {\n        point = {\n          x: x,\n          add: [],\n          remove: []\n        };\n        pointsHash[x] = point;\n        points.push(point);\n      }\n\n      if (x == item.x) {\n        point.add.push(index);\n      } else {\n        point.remove.push(index);\n      }\n    }\n  }\n\n  points.sort(function (a, b) {\n    return a.x - b.x;\n  });\n\n  function Range(start, end) {\n    this.start = start;\n    this.startHead = null;\n    this.end = end;\n    this.endHead = null;\n\n    this.overlap = function (range) {\n      return !(this.end < range.start || this.start > range.end);\n    };\n  }\n\n  function Stripe(x, ranges) {\n    this.x = x;\n    this.ranges = ranges;\n  }\n\n  var active = {};\n  var stripes = [];\n  stripes.push(new Stripe(null, []));\n\n  for (index = 0, len = points.length; index < len; index += 1) {\n    point = points[index];\n\n    for (index2 = 0, len2 = point.add.length; index2 < len2; index2 += 1) {\n      active[point.add[index2]] = true;\n    }\n\n    for (index2 = 0, len2 = point.remove.length; index2 < len2; index2 += 1) {\n      delete active[point.remove[index2]];\n    }\n\n    var activeRects = [];\n\n    for (var key in active) {\n      if (active.hasOwnProperty(key)) {\n        activeRects.push(items[key]);\n      }\n    }\n\n    activeRects.sort(function (a, b) {\n      return a.y - b.y;\n    });\n    var ranges = [];\n    var start = null;\n    var end = null;\n\n    for (index2 = 0, len2 = activeRects.length; index2 < len2; index2 += 1) {\n      var activeRect = activeRects[index2];\n\n      if (start == null) {\n        start = activeRect.y;\n        end = activeRect.bottom();\n      } else {\n        if (end < activeRect.y) {\n          ranges.push(new Range(start, end));\n          start = activeRect.y;\n          end = activeRect.bottom();\n        } else {\n          end = Math.max(end, activeRect.bottom());\n        }\n      }\n    }\n\n    if (start != null) {\n      ranges.push(new Range(start, end));\n    }\n\n    stripes.push(new Stripe(point.x, ranges));\n  }\n\n  var lists = [];\n  var heads = {};\n  var counter = 1;\n\n  function Head(isHead, list) {\n    this.isHead = isHead;\n    this.list = list;\n\n    if (!heads.hasOwnProperty(list)) {\n      heads[list] = [];\n    }\n\n    heads[list].push(this);\n\n    this.add = function (segment) {\n      if (!segment.from.equalTo(segment.to)) {\n        if (this.isHead) {\n          lists[this.list].add(counter, segment);\n          counter += 1;\n        } else {\n          lists[this.list].unshift(counter, segment);\n          counter += 1;\n        }\n      }\n    };\n\n    this.getTail = function () {\n      return new Head(!this.isHead, this.list);\n    };\n\n    this.attach = function (head) {\n      if (this.list != head.list) {\n        lists[this.list].attach(lists[head.list]);\n        var refs = heads[head.list];\n        delete heads[head.list];\n\n        if (refs != null) {\n          for (var index = 0, len = refs.length; index < len; index += 1) {\n            var ref = refs[index];\n\n            if (ref != head) {\n              ref.list = this.list;\n              heads[this.list].push(ref);\n            }\n          }\n        }\n      }\n    };\n  }\n\n  function createHead(isHead) {\n    lists.push(new LinkedHashItems());\n    return new Head(isHead, lists.length - 1);\n  }\n\n  for (index = 1, len = stripes.length; index < len; index += 1) {\n    var prev = stripes[index - 1];\n    var curr = stripes[index];\n    var pi = 0,\n        ci = 0;\n\n    while (pi < prev.ranges.length || ci < curr.ranges.length) {\n      var pr = pi < prev.ranges.length ? prev.ranges[pi] : null;\n      var cr = ci < curr.ranges.length ? curr.ranges[ci] : null;\n\n      if (cr == null) {\n        // close pr\n        points = [new Point(prev.x, pr.end), new Point(curr.x, pr.end), new Point(curr.x, pr.start), new Point(prev.x, pr.start)];\n\n        for (var pindex = 1; pindex < points.length; pindex += 1) {\n          pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\n        }\n\n        pr.endHead.attach(pr.startHead);\n        pi += 1;\n        continue;\n      }\n\n      if (pr == null) {\n        // open cr\n        cr.endHead = createHead(true);\n        cr.endHead.add(new Vector(new Point(curr.x, cr.start), new Point(curr.x, cr.end)));\n        cr.startHead = cr.endHead.getTail();\n        ci += 1;\n        continue;\n      }\n\n      if (!cr.overlap(pr)) {\n        if (pr.start < cr.start) {\n          // close pr\n          points = [new Point(prev.x, pr.end), new Point(curr.x, pr.end), new Point(curr.x, pr.start), new Point(prev.x, pr.start)];\n\n          for (pindex = 1; pindex < points.length; pindex += 1) {\n            pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\n          }\n\n          pr.endHead.attach(pr.startHead);\n          pi += 1;\n          continue;\n        } else {\n          // open cr\n          cr.endHead = createHead(true);\n          cr.endHead.add(new Vector(new Point(curr.x, cr.start), new Point(curr.x, cr.end)));\n          cr.startHead = cr.endHead.getTail();\n          ci += 1;\n          continue;\n        }\n      } else {\n        // ovelaps\n        // extend pr.start to cr.start\n        points = [new Point(prev.x, pr.start), new Point(curr.x, pr.start), new Point(curr.x, cr.start)];\n\n        for (pindex = 1; pindex < points.length; pindex += 1) {\n          pr.startHead.add(new Vector(points[pindex], points[pindex - 1]));\n        }\n\n        cr.startHead = pr.startHead;\n        var loop = true;\n\n        while (loop) {\n          loop = false;\n\n          if (pr.end > cr.end) {\n            var nextcr = ci + 1 < curr.ranges.length ? curr.ranges[ci + 1] : null;\n\n            if (nextcr != null && nextcr.overlap(pr)) {\n              // open loop cr.end to nextcr.start\n              var p1 = new Point(curr.x, nextcr.start);\n              var p2 = new Point(curr.x, cr.end);\n              cr.endHead = createHead(true);\n              cr.endHead.add(new Vector(p1, p2));\n              nextcr.startHead = cr.endHead.getTail();\n              ci += 1;\n              cr = nextcr;\n              loop = true;\n            }\n          } else {\n            var nextpr = pi + 1 < prev.ranges.length ? prev.ranges[pi + 1] : null;\n\n            if (nextpr != null && nextpr.overlap(cr)) {\n              // close loop pr.end to nextpr.start\n              points = [new Point(prev.x, pr.end), new Point(curr.x, pr.end), new Point(curr.x, nextpr.start), new Point(prev.x, nextpr.start)];\n\n              for (pindex = 1; pindex < points.length; pindex += 1) {\n                pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\n              }\n\n              pr.endHead.attach(nextpr.startHead);\n              pi += 1;\n              pr = nextpr;\n              loop = true;\n            }\n          }\n        } // extend pr.end to cr.end\n\n\n        points = [new Point(prev.x, pr.end), new Point(curr.x, pr.end), new Point(curr.x, cr.end)];\n\n        for (pindex = 1; pindex < points.length; pindex += 1) {\n          pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\n        }\n\n        cr.endHead = pr.endHead;\n        pi += 1;\n        ci += 1;\n      }\n    }\n  }\n\n  if (onItem != null) {\n    for (index = 0; index < lists.length; index += 1) {\n      if (heads.hasOwnProperty(index)) {\n        var list = lists[index];\n        points = [];\n        list.iterate(function (segment, key) {\n          if (points.length == 0) {\n            points.push(segment.from);\n            points.push(segment.to);\n          } else {\n            points.push(segment.to);\n          }\n        });\n        onItem.call(thisArg, points);\n      }\n    }\n  }\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/getMergedRectangles.js"],"names":["Point","Vector","LinkedHashItems","getMergedRectangles","thisArg","items","onItem","index","len","index2","len2","point","sort","a","b","x","y","points","pointsHash","length","item","xs","right","k","add","remove","push","Range","start","end","startHead","endHead","overlap","range","Stripe","ranges","active","stripes","activeRects","key","hasOwnProperty","activeRect","bottom","Math","max","lists","heads","counter","Head","isHead","list","segment","from","equalTo","to","unshift","getTail","attach","head","refs","ref","createHead","prev","curr","pi","ci","pr","cr","pindex","loop","nextcr","p1","p2","nextpr","iterate","call"],"mappings":"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","sourcesContent":["import Point from '../graphics/structs/Point';\nimport Vector from '../graphics/structs/Vector';\nimport LinkedHashItems from './LinkedHashItems';\n/**\n * Callback function to iterate over result shapes\n * \n * @callback onMergedRectangleItemCallback\n * @param {Point[]} points Collection of points tracing margin around result area formed via merge of rectangles.\n * The outer shape margin has clock wise sequence of data points. Internal holes inside of the shape are formed by counter clock wise \n * sequence of data points.\n */\n\n/**\n * Merges collection of rectangles into shapes. Calls callback function to pass result sequences of data points.\n * \n * @param {Object} thisArg The callback function invocation context\n * @param {Rect[]} items Collection of rectangles.\n * @param {onMergedRectangleItemCallback} onItem Callback function to pass result sequences of margin data points.\n */\nexport default function getMergedRectangles(thisArg, items, onItem) {\n  var index, len,\n    index2, len2,\n    point;\n\n  items.sort(function (a, b) {\n    if (a.x == b.x) {\n      return a.y - b.y;\n    }\n    return a.x - b.x;\n  });\n\n  var points = [];\n  var pointsHash = {};\n\n  for (index = 0, len = items.length; index < len; index += 1) {\n    var item = items[index];\n    var xs = [item.x, item.right()];\n    for (var k = 0; k < xs.length; k += 1) {\n      var x = xs[k];\n      point = pointsHash[x];\n      if (point == null) {\n        point = {\n          x: x,\n          add: [],\n          remove: []\n        };\n        pointsHash[x] = point;\n        points.push(point);\n      }\n      if (x == item.x) {\n        point.add.push(index);\n      } else {\n        point.remove.push(index);\n      }\n    }\n  }\n\n  points.sort(function (a, b) {\n    return a.x - b.x;\n  });\n\n  function Range(start, end) {\n    this.start = start;\n    this.startHead = null;\n\n    this.end = end;\n    this.endHead = null;\n\n    this.overlap = function (range) {\n      return !(this.end < range.start || this.start > range.end);\n    };\n  }\n\n  function Stripe(x, ranges) {\n    this.x = x;\n    this.ranges = ranges;\n  }\n\n  var active = {};\n  var stripes = [];\n  stripes.push(new Stripe(null, []));\n\n  for (index = 0, len = points.length; index < len; index += 1) {\n    point = points[index];\n\n    for (index2 = 0, len2 = point.add.length; index2 < len2; index2 += 1) {\n      active[point.add[index2]] = true;\n    }\n    for (index2 = 0, len2 = point.remove.length; index2 < len2; index2 += 1) {\n      delete active[point.remove[index2]];\n    }\n\n    var activeRects = [];\n    for (var key in active) {\n      if (active.hasOwnProperty(key)) {\n        activeRects.push(items[key]);\n      }\n    }\n\n    activeRects.sort(function (a, b) {\n      return a.y - b.y;\n    });\n\n    var ranges = [];\n\n    var start = null;\n    var end = null;\n\n    for (index2 = 0, len2 = activeRects.length; index2 < len2; index2 += 1) {\n      var activeRect = activeRects[index2];\n\n      if (start == null) {\n        start = activeRect.y;\n        end = activeRect.bottom();\n      } else {\n        if (end < activeRect.y) {\n          ranges.push(new Range(start, end));\n          start = activeRect.y;\n          end = activeRect.bottom();\n        } else {\n          end = Math.max(end, activeRect.bottom());\n        }\n      }\n    }\n    if (start != null) {\n      ranges.push(new Range(start, end));\n    }\n\n    stripes.push(new Stripe(point.x, ranges));\n  }\n\n  var lists = [];\n  var heads = {};\n  var counter = 1;\n\n  function Head(isHead, list) {\n    this.isHead = isHead;\n    this.list = list;\n\n    if (!heads.hasOwnProperty(list)) {\n      heads[list] = [];\n    }\n    heads[list].push(this);\n\n    this.add = function (segment) {\n      if (!segment.from.equalTo(segment.to)) {\n        if (this.isHead) {\n          lists[this.list].add(counter, segment);\n          counter += 1;\n        } else {\n          lists[this.list].unshift(counter, segment);\n          counter += 1;\n        }\n      }\n    };\n\n    this.getTail = function () {\n      return new Head(!this.isHead, this.list);\n    };\n\n    this.attach = function (head) {\n      if (this.list != head.list) {\n        lists[this.list].attach(lists[head.list]);\n\n        var refs = heads[head.list];\n        delete heads[head.list];\n        if (refs != null) {\n          for (var index = 0, len = refs.length; index < len; index += 1) {\n            var ref = refs[index];\n            if (ref != head) {\n              ref.list = this.list;\n              heads[this.list].push(ref);\n            }\n          }\n        }\n      }\n    };\n  }\n\n  function createHead(isHead) {\n    lists.push(new LinkedHashItems());\n    return new Head(isHead, lists.length - 1);\n  }\n\n  for (index = 1, len = stripes.length; index < len; index += 1) {\n    var prev = stripes[index - 1];\n    var curr = stripes[index];\n\n    var pi = 0, ci = 0;\n    while (pi < prev.ranges.length || ci < curr.ranges.length) {\n      var pr = pi < prev.ranges.length ? prev.ranges[pi] : null;\n      var cr = ci < curr.ranges.length ? curr.ranges[ci] : null;\n\n      if (cr == null) {\n        // close pr\n        points = [\n          new Point(prev.x, pr.end),\n          new Point(curr.x, pr.end),\n          new Point(curr.x, pr.start),\n          new Point(prev.x, pr.start)\n        ];\n        for (var pindex = 1; pindex < points.length; pindex += 1) {\n          pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\n        }\n        pr.endHead.attach(pr.startHead);\n        pi += 1;\n        continue;\n      }\n\n      if (pr == null) {\n        // open cr\n        cr.endHead = createHead(true);\n        cr.endHead.add(new Vector(new Point(curr.x, cr.start), new Point(curr.x, cr.end)));\n        cr.startHead = cr.endHead.getTail();\n        ci += 1;\n        continue;\n      }\n\n      if (!cr.overlap(pr)) {\n        if (pr.start < cr.start) {\n          // close pr\n          points = [\n            new Point(prev.x, pr.end),\n            new Point(curr.x, pr.end),\n            new Point(curr.x, pr.start),\n            new Point(prev.x, pr.start)\n          ];\n          for (pindex = 1; pindex < points.length; pindex += 1) {\n            pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\n          }\n          pr.endHead.attach(pr.startHead);\n          pi += 1;\n          continue;\n        } else {\n          // open cr\n          cr.endHead = createHead(true);\n          cr.endHead.add(new Vector(new Point(curr.x, cr.start), new Point(curr.x, cr.end)));\n          cr.startHead = cr.endHead.getTail();\n          ci += 1;\n          continue;\n        }\n      } else {\n        // ovelaps\n        // extend pr.start to cr.start\n        points = [\n          new Point(prev.x, pr.start),\n          new Point(curr.x, pr.start),\n          new Point(curr.x, cr.start)\n        ];\n        for (pindex = 1; pindex < points.length; pindex += 1) {\n          pr.startHead.add(new Vector(points[pindex], points[pindex - 1]));\n        }\n        cr.startHead = pr.startHead;\n\n        var loop = true;\n        while (loop) {\n          loop = false;\n\n          if (pr.end > cr.end) {\n            var nextcr = (ci + 1) < curr.ranges.length ? curr.ranges[ci + 1] : null;\n            if (nextcr != null && nextcr.overlap(pr)) {\n              // open loop cr.end to nextcr.start\n              var p1 = new Point(curr.x, nextcr.start);\n              var p2 = new Point(curr.x, cr.end);\n              cr.endHead = createHead(true);\n              cr.endHead.add(new Vector(p1, p2));\n              nextcr.startHead = cr.endHead.getTail();\n\n              ci += 1;\n              cr = nextcr;\n              loop = true;\n            }\n          } else {\n            var nextpr = (pi + 1) < prev.ranges.length ? prev.ranges[pi + 1] : null;\n            if (nextpr != null && nextpr.overlap(cr)) {\n              // close loop pr.end to nextpr.start\n              points = [\n                new Point(prev.x, pr.end),\n                new Point(curr.x, pr.end),\n                new Point(curr.x, nextpr.start),\n                new Point(prev.x, nextpr.start)\n              ];\n              for (pindex = 1; pindex < points.length; pindex += 1) {\n                pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\n              }\n              pr.endHead.attach(nextpr.startHead);\n              pi += 1;\n              pr = nextpr;\n              loop = true;\n            }\n          }\n        }\n        // extend pr.end to cr.end\n        points = [\n          new Point(prev.x, pr.end),\n          new Point(curr.x, pr.end),\n          new Point(curr.x, cr.end)\n        ];\n        for (pindex = 1; pindex < points.length; pindex += 1) {\n          pr.endHead.add(new Vector(points[pindex - 1], points[pindex]));\n        }\n        cr.endHead = pr.endHead;\n        pi += 1;\n        ci += 1;\n      }\n    }\n  }\n  if (onItem != null) {\n    for (index = 0; index < lists.length; index += 1) {\n      if (heads.hasOwnProperty(index)) {\n        var list = lists[index];\n        points = [];\n        list.iterate(function (segment, key) {\n          if (points.length == 0) {\n            points.push(segment.from);\n            points.push(segment.to);\n          } else {\n            points.push(segment.to);\n          }\n        });\n        onItem.call(thisArg, points);\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"module"}