{"ast":null,"code":"import BaseTransformer from './BaseTransformer';\nimport FamilyItem from '../../../models/FamilyItem';\nimport { GroupByType } from '../../../enums';\nimport { isEmptyObject } from '../../../common';\nexport default function FamilyNormalizer(debug) {\n  this.parent = BaseTransformer.prototype;\n  this.parent.constructor.apply(this, arguments);\n}\n;\nFamilyNormalizer.prototype = new BaseTransformer();\n\nFamilyNormalizer.prototype.normalize = function (options, logicalFamily, maximumId) {\n  if (logicalFamily.hasNodes() > 0) {\n    /* Distribute FamilyItem-s by levels. Item levels aligned to bottom. */\n    logicalFamily.loopLevels(this, options.groupByType == GroupByType.Parents, function (itemid, item, levelIndex) {\n      item.level = levelIndex;\n    });\n    /* Optimize family references. Bundle connectors where it is possible */\n\n    logicalFamily.optimizeReferences(function () {\n      maximumId += 1;\n      return new FamilyItem({\n        id: maximumId,\n        isVisible: false,\n        isActive: false,\n        itemConfig: {\n          title: \"bundle #\" + maximumId,\n          description: \" This item was created by references optimizer.\"\n        },\n        levelGravity: GroupByType.Children\n      });\n    }); //ignore jslint\n\n    if (this.debug && !logicalFamily.validate()) {\n      throw \"References are broken in family structure!\";\n    }\n\n    if (this.debug && logicalFamily.hasLoops()) {\n      throw \"Structure has loops!\";\n    }\n    /* eliminate many to many connections in chart, every connection should be ether child or parent relation. */\n\n\n    logicalFamily.eliminateManyToMany(function () {\n      maximumId += 1;\n      return new FamilyItem({\n        id: maximumId,\n        isVisible: false,\n        isActive: false,\n        itemConfig: {\n          title: \"dummy #\" + maximumId,\n          description: \"This is item used to eliminate M:M relations.\"\n        },\n        levelGravity: GroupByType.Children,\n        hideParentConnection: false,\n        hideChildrenConnection: false\n      });\n    } //ignore jslint\n    );\n\n    if (this.debug && !logicalFamily.validate()) {\n      throw \"References are broken in family structure!\";\n    }\n    /* enumerate */\n\n\n    if (options.alignBylevels) {\n      /* Distribute FamilyItem-s by levels. The original family items visible to user should keep their levels after all transformations */\n      this.resortItemsBylevels(logicalFamily);\n    } else {\n      logicalFamily.loopLevels(this, options.groupByType == GroupByType.Parents, function (itemid, item, levelIndex) {\n        item.level = levelIndex;\n      });\n    }\n\n    if (this.debug) {\n      this.validate(logicalFamily, false);\n    }\n    /* Fill in items between parent/child relations having gaps in levels */\n\n\n    this.fillInItems(logicalFamily, function (famItem) {\n      var result;\n      maximumId += 1;\n      result = new FamilyItem({\n        id: maximumId,\n        levelGravity: GroupByType.Children,\n        isVisible: false,\n        isActive: false,\n        itemConfig: {\n          title: \"extension #\" + maximumId,\n          description: \"This is item used to fill gaps in levels.\"\n        }\n      });\n      return result;\n    } //ignore jslint\n    );\n\n    if (this.debug) {\n      this.validate(logicalFamily, true);\n    }\n  }\n\n  return maximumId;\n};\n\nFamilyNormalizer.prototype.resortItemsBylevels = function (logicalFamily) {\n  var itemsAtLevels = [],\n      minimumLevel = null,\n      maximumLevel = null,\n      index,\n      itemsAtLevel;\n  logicalFamily.loop(this, function (famItemId, famItem) {\n    famItem.originalLevel = famItem.level;\n    famItem.level = null;\n\n    if (famItem.originalLevel != null) {\n      if (!itemsAtLevels[famItem.originalLevel]) {\n        itemsAtLevels[famItem.originalLevel] = {};\n      }\n\n      itemsAtLevels[famItem.originalLevel][famItemId] = famItem;\n      minimumLevel = minimumLevel != null ? Math.min(famItem.originalLevel, minimumLevel) : famItem.originalLevel;\n      maximumLevel = maximumLevel != null ? Math.max(famItem.originalLevel, maximumLevel) : famItem.originalLevel;\n    }\n  });\n  /* assign levels*/\n\n  for (index = minimumLevel; index <= maximumLevel; index += 1) {\n    itemsAtLevel = itemsAtLevels[index];\n    this.setLevelsForItems(itemsAtLevel, logicalFamily);\n  }\n\n  logicalFamily.loopTopo(this, function (famItemId, famItem, position) {\n    var level;\n\n    if (famItem.levelGravity == GroupByType.Parents) {\n      level = null;\n      logicalFamily.loopParents(this, famItemId, function (childItemId, childFamItem, levelIndex) {\n        level = level == null ? childFamItem.level + 1 : Math.max(childFamItem.level + 1, level);\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n\n      famItem.level = !level ? famItem.level : level;\n    }\n  });\n};\n\nFamilyNormalizer.prototype.setLevelsForItems = function (items, logicalFamily) {\n  var level = 0,\n      key,\n      famItem,\n      nextItems;\n\n  for (key in items) {\n    if (items.hasOwnProperty(key)) {\n      logicalFamily.loopParents(this, key, function (parentid, parent, levelIndex) {\n        level = Math.max(parent.level + 1, level);\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n    }\n  }\n\n  for (key in items) {\n    if (items.hasOwnProperty(key)) {\n      famItem = items[key];\n      famItem.level = level;\n    }\n  }\n\n  while (!isEmptyObject(items)) {\n    nextItems = {};\n\n    for (key in items) {\n      if (items.hasOwnProperty(key)) {\n        famItem = items[key];\n        logicalFamily.loopChildren(this, key, function (childid, child, levelIndex) {\n          if (child.originalLevel == null || child.isLevelNeutral) {\n            child.level = child.level == null ? famItem.level + 1 : Math.max(child.level, famItem.level + 1);\n            nextItems[childid] = child;\n          }\n\n          return logicalFamily.SKIP;\n        }); //ignore jslint\n      }\n    }\n\n    items = nextItems;\n  }\n};\n\nFamilyNormalizer.prototype.fillInItems = function (logicalFamily, createFamItem) {\n  var bundleItem;\n  logicalFamily.loop(this, function (famItemId, famItem) {\n    var extNeeded = true,\n        itemsToBundle;\n\n    while (extNeeded) {\n      extNeeded = false;\n      /* extend children down */\n\n      itemsToBundle = [];\n      logicalFamily.loopParents(this, famItemId, function (parentItemId, parentItem, level) {\n        if (famItem.level - 1 > parentItem.level) {\n          itemsToBundle.push(parentItemId);\n        }\n\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n\n      if (itemsToBundle.length > 1) {\n        bundleItem = createFamItem(famItem);\n        bundleItem.level = famItem.level - 1;\n        bundleItem.hideParentConnection = false;\n        bundleItem.hideChildrenConnection = false;\n        logicalFamily.bundleParents(famItemId, itemsToBundle, bundleItem.id, bundleItem);\n        extNeeded = true;\n        famItemId = bundleItem.id;\n        famItem = bundleItem;\n      }\n    }\n  });\n  logicalFamily.loop(this, function (famItemId, famItem) {\n    var extNeeded = true,\n        itemsToBundle,\n        isSingleExtension = true;\n\n    while (extNeeded) {\n      extNeeded = false;\n      /* extend children down */\n\n      itemsToBundle = [];\n      logicalFamily.loopChildren(this, famItemId, function (childItemId, childItem, level) {\n        if (famItem.level + 1 < childItem.level) {\n          itemsToBundle.push(childItemId);\n        } else {\n          isSingleExtension = false;\n        }\n\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n\n      if (itemsToBundle.length > 1) {\n        bundleItem = createFamItem(famItem);\n        bundleItem.level = famItem.level + 1;\n\n        if (isSingleExtension) {\n          bundleItem.hideParentConnection = false;\n          bundleItem.hideChildrenConnection = false;\n        }\n\n        logicalFamily.bundleChildren(famItemId, itemsToBundle, bundleItem.id, bundleItem);\n        extNeeded = true;\n        famItemId = bundleItem.id;\n        famItem = bundleItem;\n      }\n    }\n  });\n  logicalFamily.loop(this, function (famItemId, famItem) {\n    var extNeeded = true,\n        itemsToBundle;\n\n    while (extNeeded) {\n      extNeeded = false;\n      /* extend children down */\n\n      itemsToBundle = [];\n      logicalFamily.loopParents(this, famItemId, function (parentItemId, parentItem, level) {\n        if (famItem.level - 1 > parentItem.level) {\n          itemsToBundle.push(parentItemId);\n        }\n\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n\n      if (itemsToBundle.length > 0) {\n        bundleItem = createFamItem(famItem);\n        bundleItem.level = famItem.level - 1;\n        bundleItem.hideParentConnection = false;\n        bundleItem.hideChildrenConnection = false;\n        logicalFamily.bundleParents(famItemId, itemsToBundle, bundleItem.id, bundleItem);\n        extNeeded = true;\n        famItemId = bundleItem.id;\n        famItem = bundleItem;\n      }\n    }\n  });\n};","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/tasks/transformations/familyTransformations/FamilyNormalizer.js"],"names":["BaseTransformer","FamilyItem","GroupByType","isEmptyObject","FamilyNormalizer","debug","parent","prototype","constructor","apply","arguments","normalize","options","logicalFamily","maximumId","hasNodes","loopLevels","groupByType","Parents","itemid","item","levelIndex","level","optimizeReferences","id","isVisible","isActive","itemConfig","title","description","levelGravity","Children","validate","hasLoops","eliminateManyToMany","hideParentConnection","hideChildrenConnection","alignBylevels","resortItemsBylevels","fillInItems","famItem","result","itemsAtLevels","minimumLevel","maximumLevel","index","itemsAtLevel","loop","famItemId","originalLevel","Math","min","max","setLevelsForItems","loopTopo","position","loopParents","childItemId","childFamItem","SKIP","items","key","nextItems","hasOwnProperty","parentid","loopChildren","childid","child","isLevelNeutral","createFamItem","bundleItem","extNeeded","itemsToBundle","parentItemId","parentItem","push","length","bundleParents","isSingleExtension","childItem","bundleChildren"],"mappings":"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","sourcesContent":["import BaseTransformer from './BaseTransformer';\nimport FamilyItem from '../../../models/FamilyItem';\nimport { GroupByType } from '../../../enums';\nimport { isEmptyObject } from '../../../common';\n\nexport default function FamilyNormalizer(debug) {\n  this.parent = BaseTransformer.prototype;\n  this.parent.constructor.apply(this, arguments);\n};\n\nFamilyNormalizer.prototype = new BaseTransformer();\n\nFamilyNormalizer.prototype.normalize = function (options, logicalFamily, maximumId) {\n  if (logicalFamily.hasNodes() > 0) {\n\n    /* Distribute FamilyItem-s by levels. Item levels aligned to bottom. */\n    logicalFamily.loopLevels(this, options.groupByType == GroupByType.Parents, function (itemid, item, levelIndex) {\n      item.level = levelIndex;\n    });\n\n    /* Optimize family references. Bundle connectors where it is possible */\n    logicalFamily.optimizeReferences(function () {\n      maximumId += 1;\n\n      return new FamilyItem({\n        id: maximumId,\n        isVisible: false,\n        isActive: false,\n        itemConfig: { title: \"bundle #\" + maximumId, description: \" This item was created by references optimizer.\" },\n        levelGravity: GroupByType.Children\n      });\n    }); //ignore jslint\n\n    if (this.debug && !logicalFamily.validate()) {\n      throw \"References are broken in family structure!\";\n    }\n    if (this.debug && logicalFamily.hasLoops()) {\n      throw \"Structure has loops!\";\n    }\n\n    /* eliminate many to many connections in chart, every connection should be ether child or parent relation. */\n    logicalFamily.eliminateManyToMany(function () {\n      maximumId += 1;\n\n      return new FamilyItem({\n        id: maximumId,\n        isVisible: false,\n        isActive: false,\n        itemConfig: { title: \"dummy #\" + maximumId, description: \"This is item used to eliminate M:M relations.\" },\n        levelGravity: GroupByType.Children,\n        hideParentConnection: false,\n        hideChildrenConnection: false\n      });\n    } //ignore jslint\n    );\n\n    if (this.debug && !logicalFamily.validate()) {\n      throw \"References are broken in family structure!\";\n    }\n\n    /* enumerate */\n\n    if (options.alignBylevels) {\n      /* Distribute FamilyItem-s by levels. The original family items visible to user should keep their levels after all transformations */\n      this.resortItemsBylevels(logicalFamily);\n    } else {\n      logicalFamily.loopLevels(this, options.groupByType == GroupByType.Parents, function (itemid, item, levelIndex) {\n        item.level = levelIndex;\n      });\n    }\n\n    if (this.debug) {\n      this.validate(logicalFamily, false);\n    }\n\n    /* Fill in items between parent/child relations having gaps in levels */\n    this.fillInItems(logicalFamily,\n      function (famItem) {\n        var result;\n\n        maximumId += 1;\n\n        result = new FamilyItem({\n          id: maximumId,\n          levelGravity: GroupByType.Children,\n          isVisible: false,\n          isActive: false,\n          itemConfig: { title: \"extension #\" + maximumId, description: \"This is item used to fill gaps in levels.\" }\n        });\n\n        return result;\n      } //ignore jslint\n    );\n\n    if (this.debug) {\n      this.validate(logicalFamily, true);\n    }\n  }\n  return maximumId;\n};\n\nFamilyNormalizer.prototype.resortItemsBylevels = function (logicalFamily) {\n  var itemsAtLevels = [],\n    minimumLevel = null,\n    maximumLevel = null,\n    index, itemsAtLevel;\n\n  logicalFamily.loop(this, function (famItemId, famItem) {\n    famItem.originalLevel = famItem.level;\n    famItem.level = null;\n    if (famItem.originalLevel != null) {\n      if (!itemsAtLevels[famItem.originalLevel]) {\n        itemsAtLevels[famItem.originalLevel] = {};\n      }\n      itemsAtLevels[famItem.originalLevel][famItemId] = famItem;\n\n      minimumLevel = minimumLevel != null ? Math.min(famItem.originalLevel, minimumLevel) : famItem.originalLevel;\n      maximumLevel = maximumLevel != null ? Math.max(famItem.originalLevel, maximumLevel) : famItem.originalLevel;\n    }\n  });\n\n  /* assign levels*/\n  for (index = minimumLevel; index <= maximumLevel; index += 1) {\n    itemsAtLevel = itemsAtLevels[index];\n\n    this.setLevelsForItems(itemsAtLevel, logicalFamily);\n  }\n\n  logicalFamily.loopTopo(this, function (famItemId, famItem, position) {\n    var level;\n    if (famItem.levelGravity == GroupByType.Parents) {\n      level = null;\n      logicalFamily.loopParents(this, famItemId, function (childItemId, childFamItem, levelIndex) {\n        level = level == null ? childFamItem.level + 1 : Math.max(childFamItem.level + 1, level);\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n      famItem.level = !level ? famItem.level : level;\n    }\n  });\n};\n\nFamilyNormalizer.prototype.setLevelsForItems = function (items, logicalFamily) {\n  var level = 0,\n    key, famItem,\n    nextItems;\n\n  for (key in items) {\n    if (items.hasOwnProperty(key)) {\n      logicalFamily.loopParents(this, key, function (parentid, parent, levelIndex) {\n        level = Math.max(parent.level + 1, level);\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n    }\n  }\n\n  for (key in items) {\n    if (items.hasOwnProperty(key)) {\n      famItem = items[key];\n      famItem.level = level;\n    }\n  }\n\n  while (!isEmptyObject(items)) {\n    nextItems = {};\n\n    for (key in items) {\n      if (items.hasOwnProperty(key)) {\n        famItem = items[key];\n        logicalFamily.loopChildren(this, key, function (childid, child, levelIndex) {\n          if (child.originalLevel == null || child.isLevelNeutral) {\n            child.level = child.level == null ? famItem.level + 1 : Math.max(child.level, famItem.level + 1);\n            nextItems[childid] = child;\n          }\n          return logicalFamily.SKIP;\n        }); //ignore jslint\n      }\n    }\n    items = nextItems;\n  }\n};\n\nFamilyNormalizer.prototype.fillInItems = function (logicalFamily, createFamItem) {\n  var bundleItem;\n\n  logicalFamily.loop(this, function (famItemId, famItem) {\n    var extNeeded = true,\n      itemsToBundle;\n    while (extNeeded) {\n      extNeeded = false;\n\n      /* extend children down */\n      itemsToBundle = [];\n\n      logicalFamily.loopParents(this, famItemId, function (parentItemId, parentItem, level) {\n        if (famItem.level - 1 > parentItem.level) {\n          itemsToBundle.push(parentItemId);\n        }\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n\n      if (itemsToBundle.length > 1) {\n        bundleItem = createFamItem(famItem);\n        bundleItem.level = famItem.level - 1;\n\n        bundleItem.hideParentConnection = false;\n        bundleItem.hideChildrenConnection = false;\n\n        logicalFamily.bundleParents(famItemId, itemsToBundle, bundleItem.id, bundleItem);\n\n        extNeeded = true;\n\n        famItemId = bundleItem.id;\n        famItem = bundleItem;\n      }\n    }\n  });\n\n  logicalFamily.loop(this, function (famItemId, famItem) {\n    var extNeeded = true,\n      itemsToBundle,\n      isSingleExtension = true;\n    while (extNeeded) {\n      extNeeded = false;\n\n      /* extend children down */\n      itemsToBundle = [];\n      logicalFamily.loopChildren(this, famItemId, function (childItemId, childItem, level) {\n        if (famItem.level + 1 < childItem.level) {\n          itemsToBundle.push(childItemId);\n        } else {\n          isSingleExtension = false;\n        }\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n\n      if (itemsToBundle.length > 1) {\n        bundleItem = createFamItem(famItem);\n        bundleItem.level = famItem.level + 1;\n\n        if (isSingleExtension) {\n          bundleItem.hideParentConnection = false;\n          bundleItem.hideChildrenConnection = false;\n        }\n\n        logicalFamily.bundleChildren(famItemId, itemsToBundle, bundleItem.id, bundleItem);\n\n        extNeeded = true;\n\n        famItemId = bundleItem.id;\n        famItem = bundleItem;\n      }\n    }\n  });\n\n  logicalFamily.loop(this, function (famItemId, famItem) {\n    var extNeeded = true,\n      itemsToBundle;\n    while (extNeeded) {\n      extNeeded = false;\n\n      /* extend children down */\n      itemsToBundle = [];\n\n      logicalFamily.loopParents(this, famItemId, function (parentItemId, parentItem, level) {\n        if (famItem.level - 1 > parentItem.level) {\n          itemsToBundle.push(parentItemId);\n        }\n        return logicalFamily.SKIP;\n      }); //ignore jslint\n\n      if (itemsToBundle.length > 0) {\n        bundleItem = createFamItem(famItem);\n        bundleItem.level = famItem.level - 1;\n\n        bundleItem.hideParentConnection = false;\n        bundleItem.hideChildrenConnection = false;\n\n        logicalFamily.bundleParents(famItemId, itemsToBundle, bundleItem.id, bundleItem);\n\n        extNeeded = true;\n\n        famItemId = bundleItem.id;\n        famItem = bundleItem;\n      }\n    }\n  });\n};"]},"metadata":{},"sourceType":"module"}