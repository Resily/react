{"ast":null,"code":"import getMergedIntervals from '../../algorithms/getMergedIntervals';\nimport Interval from '../../graphics/structs/Interval';\nexport default function FamLogicalLevelsPlacementTask(orderFamilyNodesTask, alignDiagramTask) {\n  var _data = {\n    positions: []\n  };\n\n  function process() {\n    _data.positions = null;\n    return true;\n  }\n\n  function createPositions() {\n    var intervals = [],\n        treeLevels = orderFamilyNodesTask.getTreeLevels(),\n        itemsPositions = alignDiagramTask.getItemsPositions(),\n        index = 0;\n    treeLevels.loopLevels(this, function (levelIndex, level) {\n      treeLevels.loopLevelItems(this, levelIndex, function (nodeId, node, position) {\n        if (node.isVisible && node.isActive) {\n          var itemPosition = itemsPositions[nodeId];\n\n          if (itemPosition) {\n            var interval = new Interval(itemPosition.topConnectorShift || itemPosition.actualPosition.y, itemPosition.bottomConnectorShift - 1, index++);\n            intervals.push(interval);\n          }\n\n          return true;\n          /* only one item per level is needed */\n        }\n      });\n    });\n    var mergedIntervals = [];\n    getMergedIntervals(this, intervals, function (interval) {\n      mergedIntervals.push(interval);\n    });\n    intervals = mergedIntervals;\n    /* merge intervals having equal logical levels */\n\n    mergedIntervals = [];\n    var currentInterval = null;\n\n    for (var index = 0, len = intervals.length; index < len; index += 1) {\n      var interval = intervals[index];\n\n      if (!currentInterval) {\n        currentInterval = interval;\n        mergedIntervals.push(interval);\n      } else {\n        if (currentInterval.context === interval.context) {\n          currentInterval.to = interval.to;\n        } else {\n          currentInterval = interval;\n          mergedIntervals.push(interval);\n        }\n      }\n    }\n\n    intervals = mergedIntervals;\n    /* extend first level to the top */\n\n    if (intervals.length > 0) {\n      intervals[0].from = 0;\n    }\n    /* fill gaps between levels */\n\n\n    for (var index = 0, len = intervals.length - 1; index < len; index += 1) {\n      var prev = intervals[index];\n      var next = intervals[index + 1];\n      prev.to = next.from;\n    }\n    /* find minimal level */\n\n\n    var minLevelIndex = null;\n\n    for (var index = 0, len = intervals.length; index < len; index += 1) {\n      var interval = intervals[index];\n      minLevelIndex = minLevelIndex === null ? interval.context : Math.min(minLevelIndex, interval.context);\n    }\n    /* group intervals by logical levels */\n\n\n    var result = {};\n\n    for (var index = 0, len = intervals.length; index < len; index += 1) {\n      var interval = intervals[index];\n      var levelIndex = interval.context - minLevelIndex;\n      var logicalLevelPosition = result[levelIndex];\n\n      if (!logicalLevelPosition) {\n        result[levelIndex] = [interval];\n      } else {\n        logicalLevelPosition.push(interval);\n      }\n    }\n\n    return result;\n  }\n\n  function getPositions() {\n    if (!_data.positions) {\n      _data.positions = createPositions();\n    }\n\n    return _data.positions;\n  }\n\n  return {\n    getPositions: getPositions,\n    process: process\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/tasks/layout/FamLogicalLevelsPlacementTask.js"],"names":["getMergedIntervals","Interval","FamLogicalLevelsPlacementTask","orderFamilyNodesTask","alignDiagramTask","_data","positions","process","createPositions","intervals","treeLevels","getTreeLevels","itemsPositions","getItemsPositions","index","loopLevels","levelIndex","level","loopLevelItems","nodeId","node","position","isVisible","isActive","itemPosition","interval","topConnectorShift","actualPosition","y","bottomConnectorShift","push","mergedIntervals","currentInterval","len","length","context","to","from","prev","next","minLevelIndex","Math","min","result","logicalLevelPosition","getPositions"],"mappings":"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","sourcesContent":["import getMergedIntervals from '../../algorithms/getMergedIntervals';\nimport Interval from '../../graphics/structs/Interval';\n\nexport default function FamLogicalLevelsPlacementTask(orderFamilyNodesTask, alignDiagramTask) {\n  var _data = {\n    positions: []\n  };\n\n  function process() {\n    _data.positions = null;\n    return true;\n  }\n\n  function createPositions() {\n    var intervals = [],\n      treeLevels = orderFamilyNodesTask.getTreeLevels(),\n      itemsPositions = alignDiagramTask.getItemsPositions(),\n      index = 0;\n    treeLevels.loopLevels(this, function(levelIndex, level) {\n      treeLevels.loopLevelItems(this, levelIndex, function(nodeId, node, position) {\n        if(node.isVisible && node.isActive) {\n          var itemPosition = itemsPositions[nodeId];\n          if(itemPosition) {\n            var interval = new Interval(itemPosition.topConnectorShift || itemPosition.actualPosition.y, itemPosition.bottomConnectorShift - 1, index++)\n            intervals.push(interval);\n          }\n          return true; /* only one item per level is needed */\n        }\n      })\n    });\n\n    var mergedIntervals = [];\n    getMergedIntervals(this, intervals, function(interval) {\n      mergedIntervals.push(interval);\n    });\n    intervals = mergedIntervals;\n\n    /* merge intervals having equal logical levels */\n    mergedIntervals = [];\n    var currentInterval = null;\n    for(var index = 0, len = intervals.length; index < len; index+=1) {\n      var interval = intervals[index];\n      if(!currentInterval) {\n        currentInterval = interval;\n        mergedIntervals.push(interval);\n      } else {\n        if(currentInterval.context === interval.context) {\n          currentInterval.to = interval.to;\n        } else {\n          currentInterval = interval;\n          mergedIntervals.push(interval);\n        }\n      }\n    }\n    intervals = mergedIntervals;\n\n    /* extend first level to the top */\n    if(intervals.length > 0) {\n      intervals[0].from = 0;\n    }\n\n    /* fill gaps between levels */\n    for(var index = 0, len = intervals.length - 1; index < len; index+=1) {\n      var prev = intervals[index];\n      var next = intervals[index + 1];\n\n      prev.to = next.from;\n    }\n\n    /* find minimal level */\n    var minLevelIndex = null;\n    for(var index = 0, len = intervals.length; index < len; index+=1) {\n      var interval = intervals[index];\n      minLevelIndex = (minLevelIndex === null) ? interval.context : Math.min(minLevelIndex, interval.context);\n    }\n\n    /* group intervals by logical levels */ \n    var result = {};\n    for(var index = 0, len = intervals.length; index < len; index+=1) {\n      var interval = intervals[index];\n      var levelIndex = interval.context - minLevelIndex;\n      var logicalLevelPosition = result[levelIndex];\n      if(!logicalLevelPosition) {\n        result[levelIndex] = [interval];\n      } else {\n        logicalLevelPosition.push(interval);\n      }\n    }\n    return result;\n  }\n\n\n  function getPositions() {\n    if(!_data.positions) {\n      _data.positions = createPositions();\n    }\n    return _data.positions;\n  }\n\n  return {\n    getPositions:getPositions,\n    process: process\n  };\n};"]},"metadata":{},"sourceType":"module"}