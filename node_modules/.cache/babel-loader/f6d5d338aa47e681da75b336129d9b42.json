{"ast":null,"code":"import BaseConnectorBundle from './BaseConnectorBundle';\nimport { ConnectorType, Visibility } from '../enums';\nimport Polyline from '../graphics/structs/Polyline';\nimport MoveSegment from '../graphics/structs/MoveSegment';\nimport LineSegment from '../graphics/structs/LineSegment';\nexport default function VerticalConnectorBundle(fromItems, toItems, dotId) {\n  this.fromItems = fromItems;\n  this.toItems = toItems;\n  this.dotId = dotId || null;\n  this.fromOffset = 0;\n  this.fromStackSize = 0;\n}\n;\nVerticalConnectorBundle.prototype = new BaseConnectorBundle();\n\nVerticalConnectorBundle.prototype.trace = function (data, params, options) {\n  var parents,\n      children,\n      items,\n      treeItemId,\n      treeItemPosition,\n      index,\n      len,\n      isSquared,\n      hasSquared,\n      parentHorizontalCenter,\n      parentsConnectorOffset,\n      childrenConnectorOffset,\n      connectorPoint,\n      connectorStep,\n      chartHasSquaredConnectors = options.connectorType === ConnectorType.Squared;\n  /* Draw fork for parents */\n\n  parents = [];\n\n  if (this.fromItems.length > 0) {\n    items = this.fromItems;\n\n    for (index = 0, len = items.length; index < len; index += 1) {\n      treeItemId = items[index];\n      treeItemPosition = params.treeItemsPositions[treeItemId];\n      connectorPoint = new this.ConnectorDestination({\n        id: params.nestedLayoutBottomConnectorIds.hasOwnProperty(treeItemId) ? params.nestedLayoutBottomConnectorIds[treeItemId] : treeItemId,\n        bundleid: this.getId(data),\n        x: treeItemPosition.actualPosition.horizontalCenter(),\n        y: treeItemPosition.actualPosition.bottom(),\n        isSquared: true,\n        visibility: treeItemPosition.actualVisibility\n      });\n      parents.push(connectorPoint);\n    }\n\n    parents.sort(function (a, b) {\n      return a.x - b.x;\n    });\n    /* Find offset of horizontal connector line between parents */\n\n    parentsConnectorOffset = treeItemPosition.bottomConnectorShift - treeItemPosition.bottomConnectorInterval * (this.fromStackSize - this.fromOffset + 1);\n  }\n\n  children = [];\n\n  if (this.toItems.length > 0) {\n    hasSquared = false;\n    items = this.toItems;\n\n    for (index = 0; index < items.length; index += 1) {\n      treeItemId = items[index];\n      treeItemPosition = params.treeItemsPositions[treeItemId];\n      isSquared = true;\n\n      if (params.hasGraphics) {\n        switch (treeItemPosition.actualVisibility) {\n          case Visibility.Dot:\n          case Visibility.Line:\n            isSquared = chartHasSquaredConnectors;\n            break;\n        }\n      }\n\n      connectorStep = 0;\n      connectorPoint = new this.ConnectorDestination({\n        id: treeItemId,\n        bundleid: this.getId(data),\n        x: treeItemPosition.actualPosition.horizontalCenter() + connectorStep,\n        y: treeItemPosition.actualPosition.top(),\n        isSquared: isSquared,\n        visibility: treeItemPosition.actualVisibility\n      });\n      children.push(connectorPoint);\n      /* is true if any child point has squared connector */\n\n      hasSquared = hasSquared || connectorPoint.isSquared;\n    }\n\n    children.sort(function (a, b) {\n      return a.x - b.x;\n    });\n    /* Find offset of horizontal connector line between children */\n\n    childrenConnectorOffset = treeItemPosition.topConnectorShift;\n  }\n\n  if (children.length == 1) {\n    parentHorizontalCenter = children[0].x;\n  } else if (parents.length == 1) {\n    parentHorizontalCenter = parents[0].x;\n  } else if (children.length > 0 && parents.length > 0) {\n    parentHorizontalCenter = (parents[0].x + parents[parents.length - 1].x + children[0].x + children[children.length - 1].x) / 4.0;\n  } else if (children.length > 0) {\n    parentHorizontalCenter = (children[0].x + children[children.length - 1].x) / 2.0;\n  } else {\n    parentHorizontalCenter = (parents[0].x + parents[parents.length - 1].x) / 2.0;\n  }\n\n  var topCenterPoint = null;\n\n  if (parents.length > 0) {\n    topCenterPoint = new this.ConnectorDestination({\n      id: children.length == 0 ? this.dotId : this.getId(data),\n      x: parentHorizontalCenter,\n      y: parentsConnectorOffset\n    });\n    this.traceFork(data, params, options, topCenterPoint, parents, true, true, this.fromOffset, options.showExtraArrows);\n  }\n\n  var bottomCenterPoint = null;\n\n  if (children.length > 0) {\n    bottomCenterPoint = new this.ConnectorDestination({\n      id: parents.length == 0 ? this.dotId : this.getId(data),\n      x: parentHorizontalCenter,\n      y: childrenConnectorOffset\n    });\n\n    if (topCenterPoint != null && bottomCenterPoint.y == topCenterPoint.y) {\n      bottomCenterPoint = topCenterPoint;\n    }\n\n    this.traceFork(data, params, options, bottomCenterPoint, children, hasSquared, false, 0, options.showExtraArrows);\n  }\n  /* draw connector line between children and parents */\n\n\n  if (topCenterPoint != null && bottomCenterPoint != null && topCenterPoint.id != bottomCenterPoint.id) {\n    params.transform.transformPoints(topCenterPoint.x, topCenterPoint.y, bottomCenterPoint.x, bottomCenterPoint.y, true, this, function (fromX, fromY, toX, toY) {\n      var polyline = new Polyline();\n      polyline.addSegment(new MoveSegment(fromX, fromY));\n      polyline.addSegment(new LineSegment(toX, toY));\n      data.graph.addEdge(topCenterPoint.id, bottomCenterPoint.id, new this.ConnectorEdge(topCenterPoint.id, bottomCenterPoint.id, polyline, null, null, null, 0\n      /* weight */\n      ));\n    });\n  }\n};","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/connectors/VerticalConnectorBundle.js"],"names":["BaseConnectorBundle","ConnectorType","Visibility","Polyline","MoveSegment","LineSegment","VerticalConnectorBundle","fromItems","toItems","dotId","fromOffset","fromStackSize","prototype","trace","data","params","options","parents","children","items","treeItemId","treeItemPosition","index","len","isSquared","hasSquared","parentHorizontalCenter","parentsConnectorOffset","childrenConnectorOffset","connectorPoint","connectorStep","chartHasSquaredConnectors","connectorType","Squared","length","treeItemsPositions","ConnectorDestination","id","nestedLayoutBottomConnectorIds","hasOwnProperty","bundleid","getId","x","actualPosition","horizontalCenter","y","bottom","visibility","actualVisibility","push","sort","a","b","bottomConnectorShift","bottomConnectorInterval","hasGraphics","Dot","Line","top","topConnectorShift","topCenterPoint","traceFork","showExtraArrows","bottomCenterPoint","transform","transformPoints","fromX","fromY","toX","toY","polyline","addSegment","graph","addEdge","ConnectorEdge"],"mappings":"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","sourcesContent":["import BaseConnectorBundle from './BaseConnectorBundle';\nimport { ConnectorType, Visibility } from '../enums';\nimport Polyline from '../graphics/structs/Polyline';\nimport MoveSegment from '../graphics/structs/MoveSegment';\nimport LineSegment from '../graphics/structs/LineSegment';\n\nexport default function VerticalConnectorBundle(fromItems, toItems, dotId) {\n  this.fromItems = fromItems;\n  this.toItems = toItems;\n\n  this.dotId = dotId || null;\n\n  this.fromOffset = 0;\n  this.fromStackSize = 0;\n};\n\nVerticalConnectorBundle.prototype = new BaseConnectorBundle();\n\nVerticalConnectorBundle.prototype.trace = function (data, params, options) {\n  var parents, children, items,\n    treeItemId, treeItemPosition,\n    index, len,\n    isSquared, hasSquared,\n    parentHorizontalCenter,\n    parentsConnectorOffset,\n    childrenConnectorOffset,\n    connectorPoint,\n    connectorStep,\n    chartHasSquaredConnectors = (options.connectorType === ConnectorType.Squared);\n\n  /* Draw fork for parents */\n  parents = [];\n  if (this.fromItems.length > 0) {\n    items = this.fromItems;\n    for (index = 0, len = items.length; index < len; index += 1) {\n      treeItemId = items[index];\n      treeItemPosition = params.treeItemsPositions[treeItemId];\n\n      connectorPoint = new this.ConnectorDestination({\n        id: params.nestedLayoutBottomConnectorIds.hasOwnProperty(treeItemId) ? params.nestedLayoutBottomConnectorIds[treeItemId] : treeItemId,\n        bundleid: this.getId(data),\n        x: treeItemPosition.actualPosition.horizontalCenter(),\n        y: treeItemPosition.actualPosition.bottom(),\n        isSquared: true,\n        visibility: treeItemPosition.actualVisibility\n      });\n      parents.push(connectorPoint);\n    }\n    parents.sort(function (a, b) { return a.x - b.x; });\n\n    /* Find offset of horizontal connector line between parents */\n    parentsConnectorOffset = treeItemPosition.bottomConnectorShift - treeItemPosition.bottomConnectorInterval * (this.fromStackSize - this.fromOffset + 1);\n  }\n\n  children = [];\n  if (this.toItems.length > 0) {\n    hasSquared = false;\n\n    items = this.toItems;\n    for (index = 0; index < items.length; index += 1) {\n      treeItemId = items[index];\n      treeItemPosition = params.treeItemsPositions[treeItemId];\n\n      isSquared = true;\n      if (params.hasGraphics) {\n        switch (treeItemPosition.actualVisibility) {\n          case Visibility.Dot:\n          case Visibility.Line:\n            isSquared = chartHasSquaredConnectors;\n            break;\n        }\n      }\n      connectorStep = 0;\n      connectorPoint = new this.ConnectorDestination({\n        id: treeItemId,\n        bundleid: this.getId(data),\n        x: (treeItemPosition.actualPosition.horizontalCenter() + connectorStep),\n        y: treeItemPosition.actualPosition.top(),\n        isSquared: isSquared,\n        visibility: treeItemPosition.actualVisibility\n      });\n      children.push(connectorPoint);\n\n      /* is true if any child point has squared connector */\n      hasSquared = hasSquared || connectorPoint.isSquared;\n    }\n    children.sort(function (a, b) { return a.x - b.x; });\n\n    /* Find offset of horizontal connector line between children */\n    childrenConnectorOffset = treeItemPosition.topConnectorShift;\n  }\n\n  if (children.length == 1) {\n    parentHorizontalCenter = children[0].x;\n  } else if (parents.length == 1) {\n    parentHorizontalCenter = parents[0].x;\n  } else if (children.length > 0 && parents.length > 0) {\n    parentHorizontalCenter = (parents[0].x + parents[parents.length - 1].x + children[0].x + children[children.length - 1].x) / 4.0;\n  } else if (children.length > 0) {\n    parentHorizontalCenter = (children[0].x + children[children.length - 1].x) / 2.0;\n  } else {\n    parentHorizontalCenter = (parents[0].x + parents[parents.length - 1].x) / 2.0;\n  }\n\n  var topCenterPoint = null;\n  if (parents.length > 0) {\n    topCenterPoint = new this.ConnectorDestination({\n      id: (children.length == 0 ? this.dotId : this.getId(data)),\n      x: parentHorizontalCenter,\n      y: parentsConnectorOffset\n    });\n    this.traceFork(data, params, options, topCenterPoint, parents, true, true, this.fromOffset, options.showExtraArrows);\n  }\n\n  var bottomCenterPoint = null;\n  if (children.length > 0) {\n    bottomCenterPoint = new this.ConnectorDestination({\n      id: (parents.length == 0 ? this.dotId : this.getId(data)),\n      x: parentHorizontalCenter,\n      y: childrenConnectorOffset\n    });\n    if (topCenterPoint != null && bottomCenterPoint.y == topCenterPoint.y) {\n      bottomCenterPoint = topCenterPoint;\n    }\n    this.traceFork(data, params, options, bottomCenterPoint, children, hasSquared, false, 0, options.showExtraArrows);\n  }\n\n  /* draw connector line between children and parents */\n  if (topCenterPoint != null && bottomCenterPoint != null && topCenterPoint.id != bottomCenterPoint.id) {\n    params.transform.transformPoints(topCenterPoint.x, topCenterPoint.y, bottomCenterPoint.x, bottomCenterPoint.y,\n      true, this, function (fromX, fromY, toX, toY) {\n        var polyline = new Polyline();\n        polyline.addSegment(new MoveSegment(fromX, fromY));\n        polyline.addSegment(new LineSegment(toX, toY));\n\n        data.graph.addEdge(topCenterPoint.id, bottomCenterPoint.id, new this.ConnectorEdge(topCenterPoint.id, bottomCenterPoint.id, polyline,\n          null,\n          null,\n          null, 0/* weight */));\n      });\n  }\n};"]},"metadata":{},"sourceType":"module"}