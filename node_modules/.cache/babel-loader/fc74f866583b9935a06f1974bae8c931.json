{"ast":null,"code":"import { ElbowType, Visibility, ConnectorType } from '../enums';\nimport Rect from '../graphics/structs/Rect';\nimport Point from '../graphics/structs/Point';\nimport Polyline from '../graphics/structs/Polyline';\nimport MoveSegment from '../graphics/structs/MoveSegment';\nimport LineSegment from '../graphics/structs/LineSegment';\nimport CubicArcSegment from '../graphics/structs/CubicArcSegment';\nimport QuadraticArcSegment from '../graphics/structs/QuadraticArcSegment';\nexport default function BaseConnectorBundle() {\n  this.NORMAL_ITEM_WEIGHT = 10010;\n  this.LINE_ITEM_WEIGHT = 10000;\n}\n;\n\nBaseConnectorBundle.prototype.trace = function (data, params, options) {//var data = {\n  //  graph: null, //Graph\n  //  nodeid: 0\n  //};\n  //var params = {\n  //  treeItemsPositions: [],\n  //  transform: null,\n  //  hasGraphics: true\n  //};\n  //var options = {\n  //  connectorType: ConnectorType.Squared,\n  //  showExtraArrows: true,\n  //  bevelSize: 4,\n  //  elbowType: ElbowType.None\n  //};\n};\n\nBaseConnectorBundle.prototype.getId = function (data) {\n  var result = \"_\" + data.nodeid;\n  data.nodeid += 1;\n  return result;\n};\n\nBaseConnectorBundle.prototype.ConnectorEdge = function (from, to, polyline, parentsArrowId, childrenArrowId, dotId, weight, fromOffset, hasMiddle, middleParent, hasArrow) {\n  this.polyline = polyline;\n  this.from = from;\n  this.to = to;\n  this.weight = weight || 0;\n  this.fromOffset = fromOffset || 0;\n  this.hasArrow = hasArrow || false;\n  this.parentsArrowId = parentsArrowId;\n  this.childrenArrowId = childrenArrowId;\n  this.dotId = dotId;\n  /* draw extra arrows along long segments, the hasMiddle should be true and middleParent is parent point id */\n\n  this.hasMiddle = hasMiddle;\n  this.middleParent = middleParent;\n  this.isOppositeFlow = false;\n};\n\nBaseConnectorBundle.prototype.ConnectorDestination = function (options) {\n  this.id = null;\n  this.x = null;\n  this.y = null;\n  this.bundleid = null;\n  this.hasElbow = false;\n  this.elbowPoint1 = null;\n  this.elbowPoint2 = null;\n  this.visibility = null;\n  this.isSquared = true;\n\n  for (var key in options) {\n    if (options.hasOwnProperty(key)) {\n      this[key] = options[key];\n    }\n  }\n};\n\nBaseConnectorBundle.prototype.traceFork = function (data, params, options, parentPoint, points, hasSquared, isParents, fromOffset, showHorizontalArrows) {\n  var startIndex,\n      endIndex,\n      len,\n      connectorPoint,\n      curvedPoints = [],\n      bundlePoint,\n      connectorDestination,\n      index,\n      polyline,\n      bevelSize,\n      fromPoint,\n      fromPointId,\n      toPoint,\n      toPointId;\n\n  if (hasSquared) {\n    /* draw curved or angular lines on left side of pack */\n    curvedPoints = [];\n\n    for (startIndex = 0, len = points.length; startIndex < len; startIndex += 1) {\n      connectorPoint = points[startIndex];\n\n      if (connectorPoint.x < parentPoint.x && !connectorPoint.isSquared) {\n        curvedPoints.push(connectorPoint);\n      } else {\n        break;\n      }\n    }\n\n    len = curvedPoints.length;\n\n    if (len > 0) {\n      connectorDestination = curvedPoints[len - 1];\n      bundlePoint = connectorDestination.x == parentPoint.x ? parentPoint : new this.ConnectorDestination({\n        id: connectorDestination.bundleid,\n        x: connectorDestination.x,\n        y: parentPoint.y\n      });\n      this.traceAngularSegments(data, params, options, bundlePoint, curvedPoints, false);\n    }\n    /* draw curved or angular lines on right side of pack */\n\n\n    curvedPoints = [];\n\n    for (endIndex = points.length - 1; endIndex >= startIndex; endIndex -= 1) {\n      connectorPoint = points[endIndex];\n\n      if (connectorPoint.x > parentPoint.x && !connectorPoint.isSquared) {\n        curvedPoints.push(connectorPoint);\n      } else {\n        break;\n      }\n    }\n\n    len = curvedPoints.length;\n\n    if (len > 0) {\n      connectorDestination = curvedPoints[len - 1];\n      bundlePoint = connectorDestination.x == parentPoint.x ? parentPoint : new this.ConnectorDestination({\n        id: connectorDestination.bundleid,\n        x: connectorDestination.x,\n        y: parentPoint.y\n      });\n      this.traceAngularSegments(data, params, options, bundlePoint, curvedPoints, false);\n    }\n    /* calculate elbows of vertical connectors */\n\n\n    for (index = startIndex; index <= endIndex; index += 1) {\n      connectorPoint = points[index];\n      bevelSize = options.bevelSize;\n\n      if (bevelSize < 2) {\n        bevelSize = 0;\n      }\n\n      if (params.hasGraphics) {\n        switch (options.elbowType) {\n          case ElbowType.Bevel:\n          case ElbowType.Round:\n            if (bevelSize > 0 && Math.abs(parentPoint.x - connectorPoint.x) > bevelSize && Math.abs(parentPoint.y - connectorPoint.y) > bevelSize) {\n              connectorPoint.hasElbow = true;\n              connectorPoint.elbowPoint1 = new Point(connectorPoint.x, parentPoint.y + (parentPoint.y > connectorPoint.y ? -bevelSize : bevelSize));\n              connectorPoint.elbowPoint2 = new Point(connectorPoint.x + (parentPoint.x > connectorPoint.x ? bevelSize : -bevelSize), parentPoint.y);\n            }\n\n            break;\n\n          default:\n            break;\n        }\n      }\n      /* draw vertical segment */\n\n\n      polyline = new Polyline();\n\n      if (connectorPoint.hasElbow) {\n        params.transform.transform3Points(connectorPoint.elbowPoint2.x, connectorPoint.elbowPoint2.y, connectorPoint.elbowPoint1.x, connectorPoint.elbowPoint2.y, connectorPoint.elbowPoint1.x, connectorPoint.elbowPoint1.y, true, this, function (fromX, fromY, toX, toY, toX2, toY2) {\n          switch (options.elbowType) {\n            case ElbowType.Bevel:\n              polyline.addSegment(new MoveSegment(fromX, fromY));\n              polyline.addSegment(new LineSegment(toX2, toY2));\n              break;\n\n            case ElbowType.Round:\n              polyline.addSegment(new MoveSegment(fromX, fromY));\n              polyline.addSegment(new CubicArcSegment(fromX, fromY, toX, toY, toX2, toY2));\n              break;\n          }\n        }); //ignore jslint\n\n        params.transform.transformPoints(connectorPoint.elbowPoint1.x, connectorPoint.elbowPoint1.y, connectorPoint.x, connectorPoint.y, true, this, function (fromX, fromY, toX, toY) {\n          polyline.addSegment(new LineSegment(toX, toY));\n        }); //ignore jslint\n      } else {\n        params.transform.transformPoints(connectorPoint.x, parentPoint.y, connectorPoint.x, connectorPoint.y, true, this, function (fromX, fromY, toX, toY) {\n          polyline.addSegment(new MoveSegment(fromX, fromY));\n          polyline.addSegment(new LineSegment(toX, toY));\n        }); //ignore jslint\n      }\n\n      var bundleid = connectorPoint.x == parentPoint.x ? parentPoint.id : connectorPoint.bundleid;\n      var isVisible = connectorPoint.visibility !== Visibility.Invisible;\n      data.graph.addEdge(bundleid, connectorPoint.id, new this.ConnectorEdge(bundleid, connectorPoint.id, polyline, isParents ? connectorPoint.id : null, !isParents ? connectorPoint.id : null, null, isVisible ? this.NORMAL_ITEM_WEIGHT : this.LINE_ITEM_WEIGHT\n      /* weight*/\n      , fromOffset, null, null, isVisible));\n    }\n    /* draw segments on the right of parent point */\n\n\n    startIndex = Math.max(startIndex - 1, 0);\n    endIndex = Math.min(endIndex + 1, points.length - 1);\n    fromPoint = parentPoint;\n    fromPointId = parentPoint.id;\n\n    for (index = startIndex; index <= endIndex; index += 1) {\n      toPoint = points[index];\n      toPointId = toPoint.bundleid;\n\n      if (toPoint.x > fromPoint.x) {\n        polyline = new Polyline();\n        params.transform.transformPoints(fromPoint.x, parentPoint.y, toPoint.elbowPoint2 != null ? toPoint.elbowPoint2.x : toPoint.x, parentPoint.y, true, this, function (startX, startY, endX, endY) {\n          polyline.addSegment(new MoveSegment(startX, startY));\n          polyline.addSegment(new LineSegment(endX, endY));\n        }); //ignore jslint\n\n        data.graph.addEdge(fromPointId, toPointId, new this.ConnectorEdge(fromPointId, toPointId, polyline, null, null, fromPointId, Math.abs(toPoint.x - fromPoint.x) / 10000.0\n        /* weight */\n        , fromOffset,\n        /* draw middle arrows */\n        showHorizontalArrows, isParents ? toPointId : fromPointId));\n        fromPoint = toPoint.elbowPoint2 || toPoint;\n        fromPointId = toPointId;\n      }\n    }\n    /* draw segments on the left of parent point */\n\n\n    fromPoint = parentPoint;\n    fromPointId = parentPoint.id;\n\n    for (index = endIndex; index >= startIndex; index -= 1) {\n      toPoint = points[index];\n      toPointId = toPoint.bundleid;\n\n      if (toPoint.x < fromPoint.x) {\n        polyline = new Polyline();\n        params.transform.transformPoints(fromPoint.x, parentPoint.y, toPoint.elbowPoint2 != null ? toPoint.elbowPoint2.x : toPoint.x, parentPoint.y, true, this, function (startX, startY, endX, endY) {\n          polyline.addSegment(new MoveSegment(startX, startY));\n          polyline.addSegment(new LineSegment(endX, endY));\n        }); //ignore jslint\n\n        data.graph.addEdge(fromPointId, toPointId, new this.ConnectorEdge(fromPointId, toPointId, polyline, null, null, fromPointId, Math.abs(toPoint.x - fromPoint.x) / 10000.0\n        /* weight */\n        , fromOffset,\n        /* draw middle arrows */\n        showHorizontalArrows, isParents ? toPointId : fromPointId));\n        fromPoint = toPoint.elbowPoint2 || toPoint;\n        fromPointId = toPointId;\n      }\n    }\n  } else {\n    /* all lines are angular or curved */\n    this.traceAngularSegments(data, params, options, parentPoint, points, true);\n  }\n};\n\nBaseConnectorBundle.prototype.traceAngularSegments = function (data, params, options, bundlePoint, points, drawToBundle) {\n  var index, len, rect, point, polyline;\n\n  for (index = 0, len = points.length; index < len; index += 1) {\n    point = points[index];\n    polyline = new Polyline();\n    params.transform.transformPoint(bundlePoint.x, bundlePoint.y, true, this, function (x, y) {\n      polyline.addSegment(new MoveSegment(x, y));\n    }); //ignore jslint\n\n    switch (options.connectorType) {\n      case ConnectorType.Angular:\n        params.transform.transformPoint(point.x, point.y, true, this, function (x, y) {\n          polyline.addSegment(new LineSegment(x, y));\n        }); //ignore jslint\n\n        break;\n\n      case ConnectorType.Curved:\n        rect = new Rect(bundlePoint, point);\n\n        if (drawToBundle) {\n          if (bundlePoint.x > rect.x) {\n            params.transform.transform3Points(rect.right(), rect.verticalCenter(), rect.x, rect.verticalCenter(), rect.x, rect.bottom(), true, this, function (cpX1, cpY1, cpX2, cpY2, x, y) {\n              polyline.addSegment(new CubicArcSegment(cpX1, cpY1, cpX2, cpY2, x, y));\n            }); //ignore jslint\n          } else {\n            params.transform.transform3Points(rect.x, rect.verticalCenter(), rect.right(), rect.verticalCenter(), rect.right(), rect.bottom(), true, this, function (cpX1, cpY1, cpX2, cpY2, x, y) {\n              polyline.addSegment(new CubicArcSegment(cpX1, cpY1, cpX2, cpY2, x, y));\n            }); //ignore jslint\n          }\n        } else {\n          if (bundlePoint.x > rect.x) {\n            params.transform.transformPoints(rect.x, rect.y, rect.x, rect.bottom(), true, this, function (cpX, cpY, x, y) {\n              polyline.addSegment(new QuadraticArcSegment(cpX, cpY, x, y));\n            }); //ignore jslint\n          } else {\n            params.transform.transformPoints(rect.right(), rect.y, rect.right(), rect.bottom(), true, this, function (cpX, cpY, x, y) {\n              polyline.addSegment(new QuadraticArcSegment(cpX, cpY, x, y));\n            }); //ignore jslint\n          }\n        }\n\n        break;\n    }\n\n    var isVisible = point.visibility !== Visibility.Invisible;\n    data.graph.addEdge(bundlePoint.id, point.id, new this.ConnectorEdge(bundlePoint.id, point.id, polyline, null, isVisible ? point.id : null, isVisible ? this.NORMAL_ITEM_WEIGHT : this.LINE_ITEM_WEIGHT, null, null, null, true));\n  }\n};","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/connectors/BaseConnectorBundle.js"],"names":["ElbowType","Visibility","ConnectorType","Rect","Point","Polyline","MoveSegment","LineSegment","CubicArcSegment","QuadraticArcSegment","BaseConnectorBundle","NORMAL_ITEM_WEIGHT","LINE_ITEM_WEIGHT","prototype","trace","data","params","options","getId","result","nodeid","ConnectorEdge","from","to","polyline","parentsArrowId","childrenArrowId","dotId","weight","fromOffset","hasMiddle","middleParent","hasArrow","isOppositeFlow","ConnectorDestination","id","x","y","bundleid","hasElbow","elbowPoint1","elbowPoint2","visibility","isSquared","key","hasOwnProperty","traceFork","parentPoint","points","hasSquared","isParents","showHorizontalArrows","startIndex","endIndex","len","connectorPoint","curvedPoints","bundlePoint","connectorDestination","index","bevelSize","fromPoint","fromPointId","toPoint","toPointId","length","push","traceAngularSegments","hasGraphics","elbowType","Bevel","Round","Math","abs","transform","transform3Points","fromX","fromY","toX","toY","toX2","toY2","addSegment","transformPoints","isVisible","Invisible","graph","addEdge","max","min","startX","startY","endX","endY","drawToBundle","rect","point","transformPoint","connectorType","Angular","Curved","right","verticalCenter","bottom","cpX1","cpY1","cpX2","cpY2","cpX","cpY"],"mappings":"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","sourcesContent":["import { ElbowType, Visibility, ConnectorType } from '../enums';\nimport Rect from '../graphics/structs/Rect';\nimport Point from '../graphics/structs/Point';\nimport Polyline from '../graphics/structs/Polyline';\nimport MoveSegment from '../graphics/structs/MoveSegment';\nimport LineSegment from '../graphics/structs/LineSegment';\nimport CubicArcSegment from '../graphics/structs/CubicArcSegment';\nimport QuadraticArcSegment from '../graphics/structs/QuadraticArcSegment';\n\nexport default function BaseConnectorBundle() {\n  this.NORMAL_ITEM_WEIGHT = 10010;\n  this.LINE_ITEM_WEIGHT = 10000;\n};\n\n\nBaseConnectorBundle.prototype.trace = function (data, params, options) {\n  //var data = {\n  //  graph: null, //Graph\n  //  nodeid: 0\n  //};\n\n  //var params = {\n  //  treeItemsPositions: [],\n  //  transform: null,\n  //  hasGraphics: true\n  //};\n\n  //var options = {\n  //  connectorType: ConnectorType.Squared,\n  //  showExtraArrows: true,\n  //  bevelSize: 4,\n  //  elbowType: ElbowType.None\n  //};\n};\n\nBaseConnectorBundle.prototype.getId = function (data) {\n  var result = \"_\" + data.nodeid;\n  data.nodeid += 1;\n  return result;\n};\n\nBaseConnectorBundle.prototype.ConnectorEdge = function (from, to, polyline, parentsArrowId, childrenArrowId, dotId, weight, fromOffset, hasMiddle, middleParent, hasArrow) {\n  this.polyline = polyline;\n  this.from = from;\n  this.to = to;\n\n  this.weight = weight || 0;\n  this.fromOffset = fromOffset || 0;\n\n  this.hasArrow = hasArrow || false;\n  this.parentsArrowId = parentsArrowId;\n  this.childrenArrowId = childrenArrowId;\n  this.dotId = dotId;\n\n  /* draw extra arrows along long segments, the hasMiddle should be true and middleParent is parent point id */\n  this.hasMiddle = hasMiddle;\n  this.middleParent = middleParent;\n  this.isOppositeFlow = false;\n};\n\nBaseConnectorBundle.prototype.ConnectorDestination = function (options) {\n  this.id = null;\n  this.x = null;\n  this.y = null;\n  this.bundleid = null;\n  this.hasElbow = false;\n  this.elbowPoint1 = null;\n  this.elbowPoint2 = null;\n  this.visibility = null;\n  this.isSquared = true;\n\n  for (var key in options) {\n    if (options.hasOwnProperty(key)) {\n      this[key] = options[key];\n    }\n  }\n};\n\nBaseConnectorBundle.prototype.traceFork = function (data, params, options, parentPoint, points, hasSquared, isParents, fromOffset, showHorizontalArrows) {\n  var startIndex, endIndex, len,\n    connectorPoint, curvedPoints = [], bundlePoint, connectorDestination,\n    index,\n    polyline,\n    bevelSize,\n    fromPoint, fromPointId, toPoint, toPointId;\n\n  if (hasSquared) {\n    /* draw curved or angular lines on left side of pack */\n    curvedPoints = [];\n    for (startIndex = 0, len = points.length; startIndex < len; startIndex += 1) {\n      connectorPoint = points[startIndex];\n      if (connectorPoint.x < parentPoint.x && !connectorPoint.isSquared) {\n        curvedPoints.push(connectorPoint);\n      } else {\n        break;\n      }\n    }\n    len = curvedPoints.length;\n    if (len > 0) {\n      connectorDestination = curvedPoints[len - 1];\n      bundlePoint = (connectorDestination.x == parentPoint.x) ? parentPoint : new this.ConnectorDestination({\n        id: connectorDestination.bundleid,\n        x: connectorDestination.x,\n        y: parentPoint.y\n      });\n      this.traceAngularSegments(data, params, options, bundlePoint, curvedPoints, false);\n    }\n\n    /* draw curved or angular lines on right side of pack */\n    curvedPoints = [];\n    for (endIndex = points.length - 1; endIndex >= startIndex; endIndex -= 1) {\n      connectorPoint = points[endIndex];\n\n      if (connectorPoint.x > parentPoint.x && !connectorPoint.isSquared) {\n        curvedPoints.push(connectorPoint);\n      } else {\n        break;\n      }\n    }\n\n    len = curvedPoints.length;\n    if (len > 0) {\n      connectorDestination = curvedPoints[len - 1];\n      bundlePoint = (connectorDestination.x == parentPoint.x) ? parentPoint : new this.ConnectorDestination({\n        id: connectorDestination.bundleid,\n        x: connectorDestination.x,\n        y: parentPoint.y\n      });\n      this.traceAngularSegments(data, params, options, bundlePoint, curvedPoints, false);\n    }\n\n    /* calculate elbows of vertical connectors */\n    for (index = startIndex; index <= endIndex; index += 1) {\n      connectorPoint = points[index];\n\n      bevelSize = options.bevelSize;\n      if (bevelSize < 2) {\n        bevelSize = 0;\n      }\n\n      if (params.hasGraphics) {\n        switch (options.elbowType) {\n          case ElbowType.Bevel:\n          case ElbowType.Round:\n            if (bevelSize > 0 && Math.abs(parentPoint.x - connectorPoint.x) > bevelSize && Math.abs(parentPoint.y - connectorPoint.y) > bevelSize) {\n              connectorPoint.hasElbow = true;\n              connectorPoint.elbowPoint1 = new Point(connectorPoint.x, parentPoint.y + (parentPoint.y > connectorPoint.y ? -bevelSize : bevelSize));\n              connectorPoint.elbowPoint2 = new Point(connectorPoint.x + (parentPoint.x > connectorPoint.x ? bevelSize : -bevelSize), parentPoint.y);\n            }\n            break;\n          default:\n            break;\n        }\n      }\n\n      /* draw vertical segment */\n      polyline = new Polyline();\n      if (connectorPoint.hasElbow) {\n        params.transform.transform3Points(connectorPoint.elbowPoint2.x, connectorPoint.elbowPoint2.y,\n          connectorPoint.elbowPoint1.x, connectorPoint.elbowPoint2.y,\n          connectorPoint.elbowPoint1.x, connectorPoint.elbowPoint1.y, true, this,\n          function (fromX, fromY, toX, toY, toX2, toY2) {\n            switch (options.elbowType) {\n              case ElbowType.Bevel:\n                polyline.addSegment(new MoveSegment(fromX, fromY));\n                polyline.addSegment(new LineSegment(toX2, toY2));\n                break;\n              case ElbowType.Round:\n                polyline.addSegment(new MoveSegment(fromX, fromY));\n                polyline.addSegment(new CubicArcSegment(fromX, fromY, toX, toY, toX2, toY2));\n                break;\n            }\n          });//ignore jslint\n\n        params.transform.transformPoints(connectorPoint.elbowPoint1.x, connectorPoint.elbowPoint1.y, connectorPoint.x, connectorPoint.y, true, this, function (fromX, fromY, toX, toY) {\n          polyline.addSegment(new LineSegment(toX, toY));\n        }); //ignore jslint\n      } else {\n        params.transform.transformPoints(connectorPoint.x, parentPoint.y, connectorPoint.x, connectorPoint.y, true, this, function (fromX, fromY, toX, toY) {\n          polyline.addSegment(new MoveSegment(fromX, fromY));\n          polyline.addSegment(new LineSegment(toX, toY));\n        }); //ignore jslint\n      }\n\n      var bundleid = (connectorPoint.x == parentPoint.x) ? parentPoint.id : connectorPoint.bundleid;\n      var isVisible = (connectorPoint.visibility !== Visibility.Invisible);\n      data.graph.addEdge(bundleid, connectorPoint.id, new this.ConnectorEdge(bundleid, connectorPoint.id, polyline,\n        isParents ? connectorPoint.id : null,\n        !isParents ? connectorPoint.id : null,\n        null,\n        isVisible ? this.NORMAL_ITEM_WEIGHT : this.LINE_ITEM_WEIGHT /* weight*/, fromOffset, null, null,\n        isVisible));\n    }\n\n    /* draw segments on the right of parent point */\n    startIndex = Math.max(startIndex - 1, 0);\n    endIndex = Math.min(endIndex + 1, points.length - 1);\n\n    fromPoint = parentPoint;\n    fromPointId = parentPoint.id;\n    for (index = startIndex; index <= endIndex; index += 1) {\n      toPoint = points[index];\n      toPointId = toPoint.bundleid;\n      if (toPoint.x > fromPoint.x) {\n        polyline = new Polyline();\n        params.transform.transformPoints(fromPoint.x, parentPoint.y, toPoint.elbowPoint2 != null ? toPoint.elbowPoint2.x : toPoint.x, parentPoint.y, true, this, function (startX, startY, endX, endY) {\n          polyline.addSegment(new MoveSegment(startX, startY));\n          polyline.addSegment(new LineSegment(endX, endY));\n        }); //ignore jslint\n        data.graph.addEdge(fromPointId, toPointId, new this.ConnectorEdge(fromPointId, toPointId, polyline,\n          null,\n          null,\n          fromPointId, Math.abs(toPoint.x - fromPoint.x) / 10000.0 /* weight */,\n          fromOffset,\n          /* draw middle arrows */\n          showHorizontalArrows, isParents ? toPointId : fromPointId)\n        );\n\n        fromPoint = toPoint.elbowPoint2 || toPoint;\n        fromPointId = toPointId;\n      }\n    }\n\n    /* draw segments on the left of parent point */\n    fromPoint = parentPoint;\n    fromPointId = parentPoint.id;\n    for (index = endIndex; index >= startIndex; index -= 1) {\n      toPoint = points[index];\n      toPointId = toPoint.bundleid;\n      if (toPoint.x < fromPoint.x) {\n        polyline = new Polyline();\n        params.transform.transformPoints(fromPoint.x, parentPoint.y, toPoint.elbowPoint2 != null ? toPoint.elbowPoint2.x : toPoint.x, parentPoint.y, true, this, function (startX, startY, endX, endY) {\n          polyline.addSegment(new MoveSegment(startX, startY));\n          polyline.addSegment(new LineSegment(endX, endY));\n        }); //ignore jslint\n        data.graph.addEdge(fromPointId, toPointId, new this.ConnectorEdge(fromPointId, toPointId, polyline, null, null, fromPointId,\n          Math.abs(toPoint.x - fromPoint.x) / 10000.0 /* weight */, fromOffset,\n          /* draw middle arrows */\n          showHorizontalArrows, isParents ? toPointId : fromPointId)\n        );\n\n        fromPoint = toPoint.elbowPoint2 || toPoint;\n        fromPointId = toPointId;\n      }\n    }\n  } else {\n    /* all lines are angular or curved */\n    this.traceAngularSegments(data, params, options, parentPoint, points, true);\n  }\n};\n\nBaseConnectorBundle.prototype.traceAngularSegments = function (data, params, options, bundlePoint, points, drawToBundle) {\n  var index, len,\n    rect,\n    point,\n    polyline;\n\n  for (index = 0, len = points.length; index < len; index += 1) {\n    point = points[index];\n\n    polyline = new Polyline();\n\n    params.transform.transformPoint(bundlePoint.x, bundlePoint.y, true, this, function (x, y) {\n      polyline.addSegment(new MoveSegment(x, y));\n    });//ignore jslint\n\n    switch (options.connectorType) {\n      case ConnectorType.Angular:\n        params.transform.transformPoint(point.x, point.y, true, this, function (x, y) {\n          polyline.addSegment(new LineSegment(x, y));\n        });//ignore jslint\n        break;\n      case ConnectorType.Curved:\n        rect = new Rect(bundlePoint, point);\n\n        if (drawToBundle) {\n          if (bundlePoint.x > rect.x) {\n            params.transform.transform3Points(rect.right(), rect.verticalCenter(), rect.x, rect.verticalCenter(), rect.x, rect.bottom(), true,\n              this, function (cpX1, cpY1, cpX2, cpY2, x, y) {\n                polyline.addSegment(new CubicArcSegment(cpX1, cpY1, cpX2, cpY2, x, y));\n              });//ignore jslint\n          }\n          else {\n            params.transform.transform3Points(rect.x, rect.verticalCenter(), rect.right(), rect.verticalCenter(), rect.right(), rect.bottom(), true,\n              this, function (cpX1, cpY1, cpX2, cpY2, x, y) {\n                polyline.addSegment(new CubicArcSegment(cpX1, cpY1, cpX2, cpY2, x, y));\n              });//ignore jslint\n          }\n        } else {\n          if (bundlePoint.x > rect.x) {\n            params.transform.transformPoints(rect.x, rect.y, rect.x, rect.bottom(), true,\n              this, function (cpX, cpY, x, y) {\n                polyline.addSegment(new QuadraticArcSegment(cpX, cpY, x, y));\n              });//ignore jslint\n          } else {\n            params.transform.transformPoints(rect.right(), rect.y, rect.right(), rect.bottom(), true,\n              this, function (cpX, cpY, x, y) {\n                polyline.addSegment(new QuadraticArcSegment(cpX, cpY, x, y));\n              });//ignore jslint\n          }\n        }\n        break;\n    }\n    var isVisible = (point.visibility !== Visibility.Invisible);\n    data.graph.addEdge(bundlePoint.id, point.id, new this.ConnectorEdge(bundlePoint.id, point.id, polyline,\n      null,\n      isVisible ? point.id : null,\n      isVisible ? this.NORMAL_ITEM_WEIGHT : this.LINE_ITEM_WEIGHT, null, null, null,\n      true));\n  }\n};"]},"metadata":{},"sourceType":"module"}