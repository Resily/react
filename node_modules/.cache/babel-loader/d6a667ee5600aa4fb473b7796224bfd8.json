{"ast":null,"code":"import Polyline from '../graphics/structs/Polyline';\nimport MoveSegment from '../graphics/structs/MoveSegment';\nimport LineSegment from '../graphics/structs/LineSegment';\nimport { Visibility } from '../enums';\nimport BaseConnectorBundle from './BaseConnectorBundle';\nexport default function MatrixConnectorBundle(isChildren, items, matrixNodeId, connectionId, matrixWidth) {\n  this.isChildren = isChildren;\n  this.items = items;\n  this.len = items.length;\n  this.matrixNodeId = matrixNodeId;\n  this.connectionId = connectionId;\n  this.matrixWidth = matrixWidth;\n  this.blocksCount = Math.ceil(this.matrixWidth / 2);\n  this.rowsCount = Math.ceil(this.len / this.matrixWidth);\n}\n;\nMatrixConnectorBundle.prototype = new BaseConnectorBundle();\n\nMatrixConnectorBundle.prototype.trace = function (data, params, options) {\n  if (this.isChildren) {\n    this.traceChildrenLayout(data, params, options);\n  } else {\n    this.traceParentsLayout(data, params, options);\n  }\n};\n\nMatrixConnectorBundle.prototype.traceChildrenLayout = function (data, params, options) {\n  var actualPosition,\n      forkItems = [];\n\n  for (var blockIndex = 0; blockIndex < this.blocksCount; blockIndex += 1) {\n    var prevMedianPoint = null;\n\n    for (var rowIndex = this.rowsCount - 1; rowIndex >= 0; rowIndex -= 1) {\n      var leftNodeIndex = this.getNodeIndex(blockIndex, rowIndex, true, true);\n      var leftNodeId = null;\n      var leftTreeItemPosition = null;\n\n      if (leftNodeIndex < this.len) {\n        leftNodeId = this.items[leftNodeIndex];\n        leftTreeItemPosition = params.treeItemsPositions[leftNodeId];\n      }\n\n      var rightNodeIndex = this.getNodeIndex(blockIndex, rowIndex, false, true);\n      var rightNodeId = null;\n      var rightTreeItemPosition = null;\n\n      if (rightNodeIndex < this.len) {\n        rightNodeId = this.items[rightNodeIndex];\n        rightTreeItemPosition = params.treeItemsPositions[rightNodeId];\n      }\n\n      var medianPoint = null;\n\n      if (medianPoint == null && leftTreeItemPosition != null) {\n        medianPoint = new this.ConnectorDestination({\n          id: this.getId(data),\n          x: leftTreeItemPosition.actualPosition.horizontalCenter() + leftTreeItemPosition.rightMedianOffset,\n          y: leftTreeItemPosition.horizontalConnectorsShift\n        });\n      }\n\n      if (medianPoint == null && rightTreeItemPosition != null) {\n        medianPoint = new this.ConnectorDestination({\n          id: this.getId(data),\n          x: rightTreeItemPosition.actualPosition.horizontalCenter() - rightTreeItemPosition.leftMedianOffset,\n          y: rightTreeItemPosition.horizontalConnectorsShift\n        });\n      }\n\n      if (leftTreeItemPosition != null) {\n        actualPosition = leftTreeItemPosition.actualPosition;\n        params.transform.transformPoints(actualPosition.right(), actualPosition.verticalCenter(), medianPoint.x, medianPoint.y, true, this, function (fromX, fromY, toX, toY) {\n          var polyline = new Polyline();\n          polyline.addSegment(new MoveSegment(fromX, fromY));\n          polyline.addSegment(new LineSegment(toX, toY));\n          data.graph.addEdge(leftNodeId, medianPoint.id, new this.ConnectorEdge(leftNodeId, medianPoint.id, polyline, null, leftNodeId, null, 10\n          /* weight */\n          , null, null, null, true));\n        });\n      }\n\n      if (rightTreeItemPosition != null) {\n        actualPosition = rightTreeItemPosition.actualPosition;\n        params.transform.transformPoints(actualPosition.left(), actualPosition.verticalCenter(), medianPoint.x, medianPoint.y, true, this, function (fromX, fromY, toX, toY) {\n          var polyline = new Polyline();\n          polyline.addSegment(new MoveSegment(fromX, fromY));\n          polyline.addSegment(new LineSegment(toX, toY));\n          data.graph.addEdge(rightNodeId, medianPoint.id, new this.ConnectorEdge(rightNodeId, medianPoint.id, polyline, null, rightNodeId, null, 10\n          /* weight */\n          , null, null, null, true));\n        });\n      }\n\n      if (prevMedianPoint != null && medianPoint != null) {\n        // draw segment between previous and current row median points\n        params.transform.transformPoints(prevMedianPoint.x, prevMedianPoint.y, medianPoint.x, medianPoint.y, true, this, function (fromX, fromY, toX, toY) {\n          var polyline = new Polyline();\n          polyline.addSegment(new MoveSegment(fromX, fromY));\n          polyline.addSegment(new LineSegment(toX, toY));\n          data.graph.addEdge(prevMedianPoint.id, medianPoint.id, new this.ConnectorEdge(prevMedianPoint.id, medianPoint.id, polyline, null, null, null, 0\n          /* weight */\n          ));\n        });\n      }\n\n      if (medianPoint != null) {\n        prevMedianPoint = medianPoint;\n      }\n    }\n\n    if (prevMedianPoint != null) {\n      forkItems.push(new this.ConnectorDestination({\n        id: prevMedianPoint.id,\n        bundleid: this.getId(data),\n        x: prevMedianPoint.x,\n        y: prevMedianPoint.y,\n        isSquared: true,\n        visibility: Visibility.Invisible\n      }));\n    }\n  } // draw parents fork\n\n\n  var parentTreeItemPosition = params.treeItemsPositions[this.matrixNodeId];\n  actualPosition = parentTreeItemPosition.actualPosition;\n  var parentPoint = new this.ConnectorDestination({\n    id: this.matrixNodeId,\n    x: actualPosition.horizontalCenter(),\n    y: actualPosition.top()\n  });\n  this.traceFork(data, params, options, parentPoint, forkItems, true, false, 0, options.showExtraArrows);\n};\n\nMatrixConnectorBundle.prototype.traceParentsLayout = function (data, params, options) {\n  var actualPosition,\n      forkItems = [];\n\n  for (var blockIndex = 0; blockIndex <= this.blocksCount; blockIndex += 1) {\n    var prevMedianPoint = null;\n\n    for (var rowIndex = 0; rowIndex < this.rowsCount; rowIndex += 1) {\n      var leftNodeIndex = this.getNodeIndex(blockIndex, rowIndex, true, false);\n      var leftNodeId = null;\n      var leftTreeItemPosition = null;\n\n      if (leftNodeIndex < this.len) {\n        leftNodeId = this.items[leftNodeIndex];\n        leftTreeItemPosition = params.treeItemsPositions[leftNodeId];\n      }\n\n      var rightNodeIndex = this.getNodeIndex(blockIndex, rowIndex, false, false);\n      var rightNodeId = null;\n      var rightTreeItemPosition = null;\n\n      if (rightNodeIndex < this.len) {\n        rightNodeId = this.items[rightNodeIndex];\n        rightTreeItemPosition = params.treeItemsPositions[rightNodeId];\n      }\n\n      var medianPoint = null;\n\n      if (medianPoint == null && leftTreeItemPosition != null) {\n        medianPoint = new this.ConnectorDestination({\n          id: this.getId(data),\n          x: leftTreeItemPosition.actualPosition.horizontalCenter() + leftTreeItemPosition.rightMedianOffset,\n          y: leftTreeItemPosition.horizontalConnectorsShift\n        });\n      }\n\n      if (medianPoint == null && rightTreeItemPosition != null) {\n        medianPoint = new this.ConnectorDestination({\n          id: this.getId(data),\n          x: rightTreeItemPosition.actualPosition.horizontalCenter() - rightTreeItemPosition.leftMedianOffset,\n          y: rightTreeItemPosition.horizontalConnectorsShift\n        });\n      }\n\n      if (leftTreeItemPosition != null) {\n        actualPosition = leftTreeItemPosition.actualPosition;\n        params.transform.transformPoints(actualPosition.right(), actualPosition.verticalCenter(), medianPoint.x, medianPoint.y, true, this, function (fromX, fromY, toX, toY) {\n          var polyline = new Polyline();\n          polyline.addSegment(new MoveSegment(fromX, fromY));\n          polyline.addSegment(new LineSegment(toX, toY));\n          data.graph.addEdge(leftNodeId, medianPoint.id, new this.ConnectorEdge(leftNodeId, medianPoint.id, polyline, leftNodeId, null, null, 10\n          /* weight */\n          , null, null, null, true));\n        });\n      }\n\n      if (rightTreeItemPosition != null) {\n        actualPosition = rightTreeItemPosition.actualPosition;\n        params.transform.transformPoints(actualPosition.left(), actualPosition.verticalCenter(), medianPoint.x, medianPoint.y, true, this, function (fromX, fromY, toX, toY) {\n          var polyline = new Polyline();\n          polyline.addSegment(new MoveSegment(fromX, fromY));\n          polyline.addSegment(new LineSegment(toX, toY));\n          data.graph.addEdge(rightNodeId, medianPoint.id, new this.ConnectorEdge(rightNodeId, medianPoint.id, polyline, rightNodeId, null, null, 10\n          /* weight */\n          , null, null, null, true));\n        });\n      }\n\n      if (prevMedianPoint != null && medianPoint != null) {\n        // draw segment between previous and current row median points\n        params.transform.transformPoints(prevMedianPoint.x, prevMedianPoint.y, medianPoint.x, medianPoint.y, true, this, function (fromX, fromY, toX, toY) {\n          var polyline = new Polyline();\n          polyline.addSegment(new MoveSegment(fromX, fromY));\n          polyline.addSegment(new LineSegment(toX, toY));\n          data.graph.addEdge(prevMedianPoint.id, medianPoint.id, new this.ConnectorEdge(prevMedianPoint.id, medianPoint.id, polyline, null, null, null, 0\n          /* weight */\n          , null, null, null, true));\n        });\n      }\n\n      if (medianPoint != null) {\n        prevMedianPoint = medianPoint;\n      }\n    }\n\n    if (prevMedianPoint != null) {\n      forkItems.push(new this.ConnectorDestination({\n        id: prevMedianPoint.id,\n        bundleid: this.getId(data),\n        x: prevMedianPoint.x,\n        y: prevMedianPoint.y,\n        isSquared: true,\n        visibility: Visibility.Invisible\n      }));\n    }\n  } // draw parents fork\n\n\n  var parentTreeItemPosition = params.treeItemsPositions[this.matrixNodeId];\n  actualPosition = parentTreeItemPosition.actualPosition;\n  var parentPoint = new this.ConnectorDestination({\n    id: this.connectionId,\n    x: actualPosition.horizontalCenter(),\n    y: actualPosition.bottom()\n  });\n  this.traceFork(data, params, options, parentPoint, forkItems, true, true, 0, options.showExtraArrows);\n};\n\nMatrixConnectorBundle.prototype.getNodeIndex = function (blockIndex, row, isLeft, isChild) {\n  var result = null,\n      column;\n\n  if (isChild) {\n    column = blockIndex * 2 + (isLeft ? 0 : 1);\n\n    if (this.matrixWidth > column) {\n      result = row * this.matrixWidth + column;\n    }\n  } else {\n    column = blockIndex * 2 + (isLeft ? -1 : 0);\n\n    if (column >= 0 && column < this.matrixWidth) {\n      result = row * this.matrixWidth + column;\n    }\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/connectors/MatrixConnectorBundle.js"],"names":["Polyline","MoveSegment","LineSegment","Visibility","BaseConnectorBundle","MatrixConnectorBundle","isChildren","items","matrixNodeId","connectionId","matrixWidth","len","length","blocksCount","Math","ceil","rowsCount","prototype","trace","data","params","options","traceChildrenLayout","traceParentsLayout","actualPosition","forkItems","blockIndex","prevMedianPoint","rowIndex","leftNodeIndex","getNodeIndex","leftNodeId","leftTreeItemPosition","treeItemsPositions","rightNodeIndex","rightNodeId","rightTreeItemPosition","medianPoint","ConnectorDestination","id","getId","x","horizontalCenter","rightMedianOffset","y","horizontalConnectorsShift","leftMedianOffset","transform","transformPoints","right","verticalCenter","fromX","fromY","toX","toY","polyline","addSegment","graph","addEdge","ConnectorEdge","left","push","bundleid","isSquared","visibility","Invisible","parentTreeItemPosition","parentPoint","top","traceFork","showExtraArrows","bottom","row","isLeft","isChild","result","column"],"mappings":"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","sourcesContent":["import Polyline from '../graphics/structs/Polyline';\nimport MoveSegment from '../graphics/structs/MoveSegment';\nimport LineSegment from '../graphics/structs/LineSegment';\nimport { Visibility } from '../enums';\nimport BaseConnectorBundle from './BaseConnectorBundle';\n\nexport default function MatrixConnectorBundle(isChildren, items, matrixNodeId, connectionId, matrixWidth) {\n  this.isChildren = isChildren;\n  this.items = items;\n  this.len = items.length;\n  this.matrixNodeId = matrixNodeId;\n  this.connectionId = connectionId;\n  this.matrixWidth = matrixWidth;\n\n  this.blocksCount = Math.ceil(this.matrixWidth / 2);\n  this.rowsCount = Math.ceil(this.len / this.matrixWidth);\n};\n\nMatrixConnectorBundle.prototype = new BaseConnectorBundle();\n\nMatrixConnectorBundle.prototype.trace = function (data, params, options) {\n  if (this.isChildren) {\n    this.traceChildrenLayout(data, params, options);\n  } else {\n    this.traceParentsLayout(data, params, options);\n  }\n};\n\nMatrixConnectorBundle.prototype.traceChildrenLayout = function (data, params, options) {\n  var actualPosition,\n    forkItems = [];\n  for (var blockIndex = 0; blockIndex < this.blocksCount; blockIndex += 1) {\n    var prevMedianPoint = null;\n    for (var rowIndex = this.rowsCount - 1; rowIndex >= 0; rowIndex -= 1) {\n\n      var leftNodeIndex = this.getNodeIndex(blockIndex, rowIndex, true, true);\n      var leftNodeId = null;\n      var leftTreeItemPosition = null;\n      if (leftNodeIndex < this.len) {\n        leftNodeId = this.items[leftNodeIndex];\n        leftTreeItemPosition = params.treeItemsPositions[leftNodeId];\n      }\n\n      var rightNodeIndex = this.getNodeIndex(blockIndex, rowIndex, false, true);\n      var rightNodeId = null;\n      var rightTreeItemPosition = null;\n      if (rightNodeIndex < this.len) {\n        rightNodeId = this.items[rightNodeIndex];\n        rightTreeItemPosition = params.treeItemsPositions[rightNodeId];\n      }\n\n      var medianPoint = null;\n      if (medianPoint == null && leftTreeItemPosition != null) {\n        medianPoint = new this.ConnectorDestination({\n          id: this.getId(data),\n          x: leftTreeItemPosition.actualPosition.horizontalCenter() + leftTreeItemPosition.rightMedianOffset,\n          y: leftTreeItemPosition.horizontalConnectorsShift\n        });\n      }\n\n      if (medianPoint == null && rightTreeItemPosition != null) {\n        medianPoint = new this.ConnectorDestination({\n          id: this.getId(data),\n          x: rightTreeItemPosition.actualPosition.horizontalCenter() - rightTreeItemPosition.leftMedianOffset,\n          y: rightTreeItemPosition.horizontalConnectorsShift\n        });\n      }\n\n      if (leftTreeItemPosition != null) {\n        actualPosition = leftTreeItemPosition.actualPosition;\n        params.transform.transformPoints(actualPosition.right(), actualPosition.verticalCenter(), medianPoint.x, medianPoint.y,\n          true, this, function (fromX, fromY, toX, toY) {\n            var polyline = new Polyline();\n            polyline.addSegment(new MoveSegment(fromX, fromY));\n            polyline.addSegment(new LineSegment(toX, toY));\n\n            data.graph.addEdge(leftNodeId, medianPoint.id, new this.ConnectorEdge(leftNodeId, medianPoint.id, polyline,\n              null,\n              leftNodeId,\n              null, 10/* weight */, null, null, null,\n              true));\n          });\n      }\n\n      if (rightTreeItemPosition != null) {\n        actualPosition = rightTreeItemPosition.actualPosition;\n        params.transform.transformPoints(actualPosition.left(), actualPosition.verticalCenter(), medianPoint.x, medianPoint.y,\n          true, this, function (fromX, fromY, toX, toY) {\n            var polyline = new Polyline();\n            polyline.addSegment(new MoveSegment(fromX, fromY));\n            polyline.addSegment(new LineSegment(toX, toY));\n\n            data.graph.addEdge(rightNodeId, medianPoint.id, new this.ConnectorEdge(rightNodeId, medianPoint.id, polyline,\n              null,\n              rightNodeId,\n              null, 10/* weight */, null, null, null,\n              true));\n          });\n      }\n\n      if (prevMedianPoint != null && medianPoint != null) {\n        // draw segment between previous and current row median points\n        params.transform.transformPoints(prevMedianPoint.x, prevMedianPoint.y, medianPoint.x, medianPoint.y,\n          true, this, function (fromX, fromY, toX, toY) {\n            var polyline = new Polyline();\n            polyline.addSegment(new MoveSegment(fromX, fromY));\n            polyline.addSegment(new LineSegment(toX, toY));\n\n            data.graph.addEdge(prevMedianPoint.id, medianPoint.id, new this.ConnectorEdge(prevMedianPoint.id, medianPoint.id, polyline,\n              null,\n              null,\n              null, 0/* weight */));\n          });\n      }\n\n      if (medianPoint != null) {\n        prevMedianPoint = medianPoint;\n      }\n    }\n    if (prevMedianPoint != null) {\n      forkItems.push(new this.ConnectorDestination({\n        id: prevMedianPoint.id,\n        bundleid: this.getId(data),\n        x: prevMedianPoint.x,\n        y: prevMedianPoint.y,\n        isSquared: true,\n        visibility: Visibility.Invisible\n      }));\n    }\n  }\n  // draw parents fork\n  var parentTreeItemPosition = params.treeItemsPositions[this.matrixNodeId];\n  actualPosition = parentTreeItemPosition.actualPosition;\n  var parentPoint = new this.ConnectorDestination({\n    id: this.matrixNodeId,\n    x: actualPosition.horizontalCenter(),\n    y: actualPosition.top()\n  });\n  this.traceFork(data, params, options, parentPoint, forkItems, true, false, 0, options.showExtraArrows);\n};\n\nMatrixConnectorBundle.prototype.traceParentsLayout = function (data, params, options) {\n  var actualPosition,\n    forkItems = [];\n  for (var blockIndex = 0; blockIndex <= this.blocksCount; blockIndex += 1) {\n    var prevMedianPoint = null;\n    for (var rowIndex = 0; rowIndex < this.rowsCount; rowIndex += 1) {\n\n      var leftNodeIndex = this.getNodeIndex(blockIndex, rowIndex, true, false);\n      var leftNodeId = null;\n      var leftTreeItemPosition = null;\n      if (leftNodeIndex < this.len) {\n        leftNodeId = this.items[leftNodeIndex];\n        leftTreeItemPosition = params.treeItemsPositions[leftNodeId];\n      }\n\n      var rightNodeIndex = this.getNodeIndex(blockIndex, rowIndex, false, false);\n      var rightNodeId = null;\n      var rightTreeItemPosition = null;\n      if (rightNodeIndex < this.len) {\n        rightNodeId = this.items[rightNodeIndex];\n        rightTreeItemPosition = params.treeItemsPositions[rightNodeId];\n      }\n\n      var medianPoint = null;\n      if (medianPoint == null && leftTreeItemPosition != null) {\n        medianPoint = new this.ConnectorDestination({\n          id: this.getId(data),\n          x: leftTreeItemPosition.actualPosition.horizontalCenter() + leftTreeItemPosition.rightMedianOffset,\n          y: leftTreeItemPosition.horizontalConnectorsShift\n        });\n      }\n\n      if (medianPoint == null && rightTreeItemPosition != null) {\n        medianPoint = new this.ConnectorDestination({\n          id: this.getId(data),\n          x: rightTreeItemPosition.actualPosition.horizontalCenter() - rightTreeItemPosition.leftMedianOffset,\n          y: rightTreeItemPosition.horizontalConnectorsShift\n        });\n      }\n\n      if (leftTreeItemPosition != null) {\n        actualPosition = leftTreeItemPosition.actualPosition;\n        params.transform.transformPoints(actualPosition.right(), actualPosition.verticalCenter(), medianPoint.x, medianPoint.y,\n          true, this, function (fromX, fromY, toX, toY) {\n            var polyline = new Polyline();\n            polyline.addSegment(new MoveSegment(fromX, fromY));\n            polyline.addSegment(new LineSegment(toX, toY));\n\n            data.graph.addEdge(leftNodeId, medianPoint.id, new this.ConnectorEdge(leftNodeId, medianPoint.id, polyline,\n              leftNodeId,\n              null,\n              null, 10/* weight */, null, null, null,\n              true));\n          });\n      }\n\n      if (rightTreeItemPosition != null) {\n        actualPosition = rightTreeItemPosition.actualPosition;\n        params.transform.transformPoints(actualPosition.left(), actualPosition.verticalCenter(), medianPoint.x, medianPoint.y,\n          true, this, function (fromX, fromY, toX, toY) {\n            var polyline = new Polyline();\n            polyline.addSegment(new MoveSegment(fromX, fromY));\n            polyline.addSegment(new LineSegment(toX, toY));\n\n            data.graph.addEdge(rightNodeId, medianPoint.id, new this.ConnectorEdge(rightNodeId, medianPoint.id, polyline,\n              rightNodeId,\n              null,\n              null, 10/* weight */, null, null, null,\n              true));\n          });\n      }\n\n      if (prevMedianPoint != null && medianPoint != null) {\n        // draw segment between previous and current row median points\n        params.transform.transformPoints(prevMedianPoint.x, prevMedianPoint.y, medianPoint.x, medianPoint.y,\n          true, this, function (fromX, fromY, toX, toY) {\n            var polyline = new Polyline();\n            polyline.addSegment(new MoveSegment(fromX, fromY));\n            polyline.addSegment(new LineSegment(toX, toY));\n\n            data.graph.addEdge(prevMedianPoint.id, medianPoint.id, new this.ConnectorEdge(prevMedianPoint.id, medianPoint.id, polyline,\n              null,\n              null,\n              null, 0/* weight */, null, null, null,\n              true));\n          });\n      }\n\n      if (medianPoint != null) {\n        prevMedianPoint = medianPoint;\n      }\n    }\n    if (prevMedianPoint != null) {\n      forkItems.push(new this.ConnectorDestination({\n        id: prevMedianPoint.id,\n        bundleid: this.getId(data),\n        x: prevMedianPoint.x,\n        y: prevMedianPoint.y,\n        isSquared: true,\n        visibility: Visibility.Invisible\n      }));\n    }\n  }\n  // draw parents fork\n  var parentTreeItemPosition = params.treeItemsPositions[this.matrixNodeId];\n  actualPosition = parentTreeItemPosition.actualPosition;\n  var parentPoint = new this.ConnectorDestination({\n    id: this.connectionId,\n    x: actualPosition.horizontalCenter(),\n    y: actualPosition.bottom()\n  });\n  this.traceFork(data, params, options, parentPoint, forkItems, true, true, 0, options.showExtraArrows);\n};\n\nMatrixConnectorBundle.prototype.getNodeIndex = function (blockIndex, row, isLeft, isChild) {\n  var result = null,\n    column;\n  if (isChild) {\n    column = blockIndex * 2 + (isLeft ? 0 : 1);\n    if (this.matrixWidth > column) {\n      result = row * this.matrixWidth + column;\n    }\n  } else {\n    column = blockIndex * 2 + (isLeft ? -1 : 0);\n    if (column >= 0 && column < this.matrixWidth) {\n      result = row * this.matrixWidth + column;\n    }\n  }\n  return result;\n};\n\n"]},"metadata":{},"sourceType":"module"}