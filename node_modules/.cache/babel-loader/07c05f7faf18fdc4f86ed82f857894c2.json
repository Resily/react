{"ast":null,"code":"import Matrix from './Matrix';\nimport Point from './Point';\nimport { VectorRelationType } from '../../enums';\n/**\n * @class Vector\n * @classdesc Class defines a vector in 2D plane.\n * \n * @param {Vector} arg0 Vector object to clone.\n * \n * @param {Point} arg0 From point.\n * @param {Point} arg1 To point\n */\n\nexport default function Vector(arg0, arg1) {\n  /**\n   * The start point\n   */\n  this.from = null;\n  /**\n   * The end point\n   */\n\n  this.to = null;\n  /**\n   * Reference to context object associated with this vector.\n   * @type {object}\n   */\n\n  this.context = null;\n\n  switch (arguments.length) {\n    case 1:\n      this.from = arg0.from;\n      this.to = arg0.to;\n      break;\n\n    case 2:\n      this.from = arg0;\n      this.to = arg1;\n      break;\n\n    default:\n      break;\n  }\n}\n;\n/**\n * Checks if start and end points are the same\n * \n * @returns {boolean} Returns true if start and end points are the same.\n */\n\nVector.prototype.isNull = function () {\n  return this.from.x == this.to && this.from.y == this.to.y;\n};\n/**\n * Vector length\n * \n * @returns {number} Returns vector length\n */\n\n\nVector.prototype.length = function () {\n  return this.from.distanceTo(this.to);\n};\n/**\n * Checks if vectors are equal\n * \n * @param {Vector} vector Vector\n * @returns {boolean} Returns true if vectors are equal.\n */\n\n\nVector.prototype.equalTo = function (vector) {\n  return this.from.equalTo(vector.from) && this.to.equalTo(vector.to);\n};\n/**\n * Returns middle point of the current vector\n * \n * @returns {Point} Returns middle point\n */\n\n\nVector.prototype.getMiddlePoint = function () {\n  return new Point((this.from.x + this.to.x) / 2, (this.from.y + this.to.y) / 2);\n};\n/**\n * Finds how two vectors relate to each other\n * \n * @param {Vector} vector The vector to relate with\n * @returns {VectorRelationType} Returns how the vector relates to the specified vector\n */\n\n\nVector.prototype.relateTo = function (vector) {\n  var result = VectorRelationType.None,\n      x1 = this.to.x - this.from.x,\n      y1 = this.to.y - this.from.y,\n      x2 = vector.to.x - vector.from.x,\n      y2 = vector.to.y - vector.from.y,\n      key = (x1 ? 8 : 0) + (y1 ? 4 : 0) + (x2 ? 2 : 0) + (y2 ? 1 : 0);\n\n  switch (key) {\n    case 0: //0000\n\n    case 1: //0001\n\n    case 2: //0010\n\n    case 3: //0011\n\n    case 4: //0100\n\n    case 8: //1000\n\n    case 12:\n      //1100\n      result = VectorRelationType.Null;\n      break;\n\n    case 5:\n      //0101\n      if (y1 * y2 > 0) {\n        result = VectorRelationType.Collinear;\n      } else {\n        result = VectorRelationType.Opposite;\n      }\n\n      break;\n\n    case 10:\n      //1010\n      if (x1 * x2 > 0) {\n        result = VectorRelationType.Collinear;\n      } else {\n        result = VectorRelationType.Opposite;\n      }\n\n      break;\n\n    case 15:\n      //1111\n      if (x1 / x2 == y1 / y2) {\n        if (x1 / x2 > 0) {\n          result = VectorRelationType.Collinear;\n        } else {\n          result = VectorRelationType.Opposite;\n        }\n      }\n\n      break;\n  }\n\n  return result;\n};\n/**\n * Offsets vector coordinates\n * \n * @param {number} offset Offset\n */\n\n\nVector.prototype.offset = function (offset) {\n  var length = this.length(),\n\n  /* in order to rotate right multiply vector on 3D vector (0, 0, -1)*/\n  x = (this.to.y - this.from.y) * offset / length,\n      y = -(this.to.x - this.from.x) * offset / length;\n  this.from.x += x;\n  this.from.y += y;\n  this.to.x += x;\n  this.to.y += y;\n};\n/**\n * Gets line\n * \n * @returns {number[]} Returns line coefficients\n */\n\n\nVector.prototype.getLine = function () {\n  var x1 = this.from.x,\n      y1 = this.from.y,\n      x2 = this.to.x,\n      y2 = this.to.y,\n      a = y2 - y1,\n      b = x1 - x2,\n      c = x1 * (y1 - y2) + y1 * (x2 - x1);\n  return [a, b, c];\n};\n/**\n * Gets line key\n * \n * @returns {string} Returns unique line key\n */\n\n\nVector.prototype.getLineKey = function () {\n  var line = this.getLine(),\n      a = line[0],\n      b = line[1],\n      c = line[2],\n      r = 10000;\n\n  if (b !== 0) {\n    line = [Math.floor(a / b * r), 1, Math.floor(c / b * r)];\n  } else {\n    line = [1, 0, Math.floor(c / a * r)];\n  }\n\n  return line.toString();\n};\n/**\n * Checks if two vectors have intersection point\n * \n * @param {vector} vector The vector to check intersection with\n * @returns {boolean} Returns true if vectors intersect\n */\n\n\nVector.prototype.intersect = function (vector) {\n  var v1 = this.getLine(),\n      v2 = vector.getLine(),\n      m = new Matrix(v1[0], v1[1], v2[0], v2[1]),\n      d = m.determinant(),\n      mx,\n      my,\n      dx,\n      dy,\n      x,\n      y,\n      result = false;\n\n  if (d !== 0) {\n    mx = new Matrix(-v1[2], v1[1], -v2[2], v2[1]);\n    dx = mx.determinant();\n    my = new Matrix(v1[0], -v1[2], v2[0], -v2[2]);\n    dy = my.determinant();\n    x = dx / d;\n    y = dy / d;\n    vector.to.x = x;\n    vector.to.y = y;\n    this.from.x = x;\n    this.from.y = y;\n    result = true;\n  }\n\n  return result;\n};\n/**\n * Finds intersection point of two vectors\n * \n * @param {Vector} vector The vector to find intersection with\n * @param {boolean} strict If true then intersection point should belong to both vectors\n * @param {number} rounding The precision of calculations\n * @returns {Point|null} Returns intersection point or null if intersection does not exists\n */\n\n\nVector.prototype.getIntersectionPoint = function (vector, strict, rounding) {\n  var v1 = this.getLine(),\n      v2 = vector.getLine(),\n      m = new Matrix(v1[0], v1[1], v2[0], v2[1]),\n      d = m.determinant(),\n      mx,\n      my,\n      dx,\n      dy,\n      x,\n      y,\n      result = null;\n\n  if (d !== 0) {\n    mx = new Matrix(-v1[2], v1[1], -v2[2], v2[1]);\n    dx = mx.determinant();\n    my = new Matrix(v1[0], -v1[2], v2[0], -v2[2]);\n    dy = my.determinant();\n    x = dx / d;\n    y = dy / d;\n\n    if (strict) {\n      if (vector._contains(x, y, rounding) && this._contains(x, y, rounding)) {\n        result = new Point(x, y);\n      }\n    } else {\n      result = new Point(x, y);\n    }\n  }\n\n  return result;\n};\n/**\n * @ignore\n */\n\n\nVector.prototype._contains = function (x, y, rounding) {\n  var x1 = Math.min(this.from.x, this.to.x),\n      y1 = Math.min(this.from.y, this.to.y),\n      x2 = Math.max(this.from.x, this.to.x),\n      y2 = Math.max(this.from.y, this.to.y);\n  return x1 - rounding <= x && x <= x2 + rounding && y1 - rounding <= y && y <= y2 + rounding;\n};","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/graphics/structs/Vector.js"],"names":["Matrix","Point","VectorRelationType","Vector","arg0","arg1","from","to","context","arguments","length","prototype","isNull","x","y","distanceTo","equalTo","vector","getMiddlePoint","relateTo","result","None","x1","y1","x2","y2","key","Null","Collinear","Opposite","offset","getLine","a","b","c","getLineKey","line","r","Math","floor","toString","intersect","v1","v2","m","d","determinant","mx","my","dx","dy","getIntersectionPoint","strict","rounding","_contains","min","max"],"mappings":"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","sourcesContent":["import Matrix from './Matrix';\nimport Point from './Point';\nimport { VectorRelationType } from '../../enums';\n\n/**\n * @class Vector\n * @classdesc Class defines a vector in 2D plane.\n * \n * @param {Vector} arg0 Vector object to clone.\n * \n * @param {Point} arg0 From point.\n * @param {Point} arg1 To point\n */\nexport default function Vector(arg0, arg1) {\n  /**\n   * The start point\n   */\n  this.from = null;\n\n  /**\n   * The end point\n   */\n  this.to = null;\n\n  /**\n   * Reference to context object associated with this vector.\n   * @type {object}\n   */\n  this.context = null;\n\n  switch (arguments.length) {\n    case 1:\n      this.from = arg0.from;\n      this.to = arg0.to;\n      break;\n    case 2:\n      this.from = arg0;\n      this.to = arg1;\n      break;\n    default:\n      break;\n  }\n};\n\n/**\n * Checks if start and end points are the same\n * \n * @returns {boolean} Returns true if start and end points are the same.\n */\nVector.prototype.isNull = function () {\n  return this.from.x == this.to && this.from.y == this.to.y;\n};\n\n/**\n * Vector length\n * \n * @returns {number} Returns vector length\n */\nVector.prototype.length = function () {\n  return this.from.distanceTo(this.to);\n};\n\n/**\n * Checks if vectors are equal\n * \n * @param {Vector} vector Vector\n * @returns {boolean} Returns true if vectors are equal.\n */\nVector.prototype.equalTo = function (vector) {\n  return this.from.equalTo(vector.from) && this.to.equalTo(vector.to);\n};\n\n/**\n * Returns middle point of the current vector\n * \n * @returns {Point} Returns middle point\n */\nVector.prototype.getMiddlePoint = function () {\n  return new Point((this.from.x + this.to.x) / 2, (this.from.y + this.to.y) / 2);\n};\n\n/**\n * Finds how two vectors relate to each other\n * \n * @param {Vector} vector The vector to relate with\n * @returns {VectorRelationType} Returns how the vector relates to the specified vector\n */\nVector.prototype.relateTo = function (vector) {\n  var result = VectorRelationType.None,\n    x1 = this.to.x - this.from.x,\n    y1 = this.to.y - this.from.y,\n    x2 = vector.to.x - vector.from.x,\n    y2 = vector.to.y - vector.from.y,\n    key = (x1 ? 8 : 0) + (y1 ? 4 : 0) + (x2 ? 2 : 0) + (y2 ? 1 : 0);\n\n  switch (key) {\n    case 0: //0000\n    case 1: //0001\n    case 2: //0010\n    case 3: //0011\n    case 4: //0100\n    case 8: //1000\n    case 12://1100\n      result = VectorRelationType.Null;\n      break;\n    case 5: //0101\n      if (y1 * y2 > 0) {\n        result = VectorRelationType.Collinear;\n      } else {\n        result = VectorRelationType.Opposite;\n      }\n      break;\n    case 10://1010\n      if (x1 * x2 > 0) {\n        result = VectorRelationType.Collinear;\n      } else {\n        result = VectorRelationType.Opposite;\n      }\n      break;\n    case 15://1111\n      if (x1 / x2 == y1 / y2) {\n        if (x1 / x2 > 0) {\n          result = VectorRelationType.Collinear;\n        } else {\n          result = VectorRelationType.Opposite;\n        }\n      }\n      break;\n  }\n  return result;\n};\n\n/**\n * Offsets vector coordinates\n * \n * @param {number} offset Offset\n */\nVector.prototype.offset = function (offset) {\n  var length = this.length(),\n    /* in order to rotate right multiply vector on 3D vector (0, 0, -1)*/\n    x = (this.to.y - this.from.y) * offset / length,\n    y = - (this.to.x - this.from.x) * offset / length;\n\n  this.from.x += x;\n  this.from.y += y;\n  this.to.x += x;\n  this.to.y += y;\n};\n\n/**\n * Gets line\n * \n * @returns {number[]} Returns line coefficients\n */\nVector.prototype.getLine = function () {\n  var x1 = this.from.x,\n    y1 = this.from.y,\n    x2 = this.to.x,\n    y2 = this.to.y,\n    a = y2 - y1,\n    b = x1 - x2,\n    c = x1 * (y1 - y2) + y1 * (x2 - x1);\n\n  return [a, b, c];\n};\n\n/**\n * Gets line key\n * \n * @returns {string} Returns unique line key\n */\nVector.prototype.getLineKey = function () {\n  var line = this.getLine(),\n    a = line[0],\n    b = line[1],\n    c = line[2],\n    r = 10000;\n  if (b !== 0) {\n    line = [Math.floor(a / b * r), 1, Math.floor(c / b * r)];\n  } else {\n    line = [1, 0, Math.floor(c / a * r)];\n  }\n  return line.toString();\n};\n\n/**\n * Checks if two vectors have intersection point\n * \n * @param {vector} vector The vector to check intersection with\n * @returns {boolean} Returns true if vectors intersect\n */\nVector.prototype.intersect = function (vector) {\n  var v1 = this.getLine(),\n    v2 = vector.getLine(),\n    m = new Matrix(v1[0], v1[1], v2[0], v2[1]),\n    d = m.determinant(),\n    mx, my, dx, dy,\n    x, y,\n    result = false;\n\n  if (d !== 0) {\n    mx = new Matrix(-v1[2], v1[1], -v2[2], v2[1]);\n    dx = mx.determinant();\n    my = new Matrix(v1[0], -v1[2], v2[0], -v2[2]);\n    dy = my.determinant();\n    x = dx / d;\n    y = dy / d;\n\n    vector.to.x = x;\n    vector.to.y = y;\n\n    this.from.x = x;\n    this.from.y = y;\n\n    result = true;\n  }\n\n  return result;\n};\n\n/**\n * Finds intersection point of two vectors\n * \n * @param {Vector} vector The vector to find intersection with\n * @param {boolean} strict If true then intersection point should belong to both vectors\n * @param {number} rounding The precision of calculations\n * @returns {Point|null} Returns intersection point or null if intersection does not exists\n */\nVector.prototype.getIntersectionPoint = function (vector, strict, rounding) {\n  var v1 = this.getLine(),\n    v2 = vector.getLine(),\n    m = new Matrix(v1[0], v1[1], v2[0], v2[1]),\n    d = m.determinant(),\n    mx, my, dx, dy,\n    x, y,\n    result = null;\n\n  if (d !== 0) {\n    mx = new Matrix(-v1[2], v1[1], -v2[2], v2[1]);\n    dx = mx.determinant();\n    my = new Matrix(v1[0], -v1[2], v2[0], -v2[2]);\n    dy = my.determinant();\n    x = dx / d;\n    y = dy / d;\n\n    if (strict) {\n      if (vector._contains(x, y, rounding) && this._contains(x, y, rounding)) {\n        result = new Point(x, y);\n      }\n    } else {\n      result = new Point(x, y);\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ignore\n */\nVector.prototype._contains = function (x, y, rounding) {\n  var x1 = Math.min(this.from.x, this.to.x),\n    y1 = Math.min(this.from.y, this.to.y),\n    x2 = Math.max(this.from.x, this.to.x),\n    y2 = Math.max(this.from.y, this.to.y);\n\n  return x1 - rounding <= x && x <= x2 + rounding && y1 - rounding <= y && y <= y2 + rounding;\n};\n\n"]},"metadata":{},"sourceType":"module"}