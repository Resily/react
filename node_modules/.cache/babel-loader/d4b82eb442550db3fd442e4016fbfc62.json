{"ast":null,"code":"import getLiniarBreaks from './getLiniarBreaks';\nimport QuadTree from './QuadTree';\nimport Rect from '../graphics/structs/Rect';\n/**\n * Create spatial index structure. It uses collection of sizes to distribute \n * rectangles into buckets of similar size elements. Elements of the same bucket \n * are approximated to points. The search of rectangles is transformed to search of points \n * within given range plus offset for maximum linear rectangle size.\n * \n * @class SpatialIndex\n * \n * @param {Array} sizes Reference to optional collection of possible sizes of items we plan to store\n * in the index\n * \n * @returns {SpatialIndex} Returns spacial index data structure.\n */\n\nexport default function SpatialIndex(sizes) {\n  var _buckets = [];\n  sizes.sort(function (a, b) {\n    return a - b;\n  });\n\n  switch (sizes.length) {\n    case 0:\n      _buckets.push(new Bucket(0, 1000000));\n\n      break;\n\n    case 1:\n      var size1 = sizes[0];\n\n      _buckets.push(new Bucket(0, size1));\n\n      break;\n\n    case 2:\n      size1 = sizes[0];\n      var size2 = sizes[1];\n\n      if (size2 > size1 * 2) {\n        _buckets.push(new Bucket(0, size1));\n\n        _buckets.push(new Bucket(size1, size2));\n      } else {\n        _buckets.push(new Bucket(0, size2));\n      }\n\n      break;\n\n    default:\n      var breaks = getLiniarBreaks(sizes);\n      var minimum = 0;\n\n      for (var index = 0; index < breaks.length; index += 1) {\n        var maximum = sizes[breaks[index]];\n\n        _buckets.push(new Bucket(minimum, maximum));\n\n        minimum = maximum;\n      }\n\n      break;\n  }\n\n  function Bucket(minimum, maximum) {\n    this.minimum = minimum;\n    this.maximum = maximum;\n    this.quadTree = QuadTree(maximum * 2);\n  }\n  /**\n   * Adds rectangle to spacial index\n   * @param {Rect} rect Rectangle\n   */\n\n\n  function addRect(rect) {\n    var size = Math.max(rect.width, rect.height);\n    var point = rect.centerPoint();\n\n    for (var index = 0, len = _buckets.length; index < len; index += 1) {\n      var bucket = _buckets[index];\n\n      if (size <= bucket.maximum || index == len - 1) {\n        point.context = rect;\n        bucket.quadTree.addPoint(point);\n        break;\n      }\n    }\n  }\n  /**\n   * Callback function for iteration of spacial index rectangles\n   * \n   * @callback onSpatialIndexItemCallback\n   * @param {React} rect Rectangle\n   * @returns {boolean} Returns true to break iteration process.\n   */\n\n  /**\n   * Loops rectangular area of spacial index\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {Rect} rect Rectangular search area\n   * @param {onSpatialIndexItemCallback} onItem Callback function to call for every rectangle intersecting given rectangular search area\n   */\n\n\n  function loopArea(thisArg, rect, onItem) {\n    // onItem = function(itemid) {}\n    if (onItem != null) {\n      for (var index = 0, len = _buckets.length; index < len; index += 1) {\n        var bucket = _buckets[index];\n        var bucketRect = new Rect(rect);\n        bucketRect.offset(bucket.maximum / 2.0);\n        bucket.quadTree.loopArea(this, bucketRect, function (point) {\n          var pointRect = point.context;\n\n          if (rect.overlaps(pointRect)) {\n            return onItem.call(thisArg, pointRect);\n          }\n        });\n      }\n    }\n  }\n  /**\n   * Validates internal data consistency of spacial index data structure\n   * \n   * @ignore\n   * @returns {boolean} Returns true if structure pass validation\n   */\n\n\n  function validate() {\n    var result = true;\n\n    for (var index = 0, len = _buckets.length; index < len; index += 1) {\n      var bucket = _buckets[index];\n      result = result && bucket.quadTree.validate();\n    }\n\n    return result;\n  }\n  /**\n   * Returns collection of quadrants created in spacial index\n   * Quadrants exists only when elements exists in them.\n   * This method is used for visual debugging of the structure.\n   * \n   * @ignore\n   * @param {React} selection Rectangular test area to highlight quadrants\n   * @returns {Rect[]} Returns collection of available quadrants.\n   * Quadrants containing points within selection area have context.highlight property set to true.\n   */\n\n\n  function getPositions(selection) {\n    var result = [];\n\n    for (var index = 0, len = _buckets.length; index < len; index += 1) {\n      var bucket = _buckets[index];\n      result = result.concat(bucket.quadTree.getPositions(selection));\n    }\n\n    return result;\n  }\n\n  return {\n    addRect: addRect,\n    loopArea: loopArea,\n    validate: validate,\n    getPositions: getPositions\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/SpatialIndex.js"],"names":["getLiniarBreaks","QuadTree","Rect","SpatialIndex","sizes","_buckets","sort","a","b","length","push","Bucket","size1","size2","breaks","minimum","index","maximum","quadTree","addRect","rect","size","Math","max","width","height","point","centerPoint","len","bucket","context","addPoint","loopArea","thisArg","onItem","bucketRect","offset","pointRect","overlaps","call","validate","result","getPositions","selection","concat"],"mappings":"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","sourcesContent":["import getLiniarBreaks from './getLiniarBreaks';\nimport QuadTree from './QuadTree';\nimport Rect from '../graphics/structs/Rect';\n/**\n * Create spatial index structure. It uses collection of sizes to distribute \n * rectangles into buckets of similar size elements. Elements of the same bucket \n * are approximated to points. The search of rectangles is transformed to search of points \n * within given range plus offset for maximum linear rectangle size.\n * \n * @class SpatialIndex\n * \n * @param {Array} sizes Reference to optional collection of possible sizes of items we plan to store\n * in the index\n * \n * @returns {SpatialIndex} Returns spacial index data structure.\n */\nexport default function SpatialIndex(sizes) {\n  var _buckets = [];\n\n  sizes.sort(function (a, b) { return a - b; });\n\n  switch (sizes.length) {\n    case 0:\n      _buckets.push(new Bucket(0, 1000000));\n      break;\n    case 1:\n      var size1 = sizes[0];\n      _buckets.push(new Bucket(0, size1));\n      break;\n    case 2:\n      size1 = sizes[0];\n      var size2 = sizes[1];\n      if (size2 > size1 * 2) {\n        _buckets.push(new Bucket(0, size1));\n        _buckets.push(new Bucket(size1, size2));\n      } else {\n        _buckets.push(new Bucket(0, size2));\n      }\n      break;\n    default:\n      var breaks = getLiniarBreaks(sizes);\n      var minimum = 0;\n      for (var index = 0; index < breaks.length; index += 1) {\n        var maximum = sizes[breaks[index]];\n        _buckets.push(new Bucket(minimum, maximum));\n        minimum = maximum;\n      }\n      break;\n  }\n\n  function Bucket(minimum, maximum) {\n    this.minimum = minimum;\n    this.maximum = maximum;\n    this.quadTree = QuadTree(maximum * 2);\n  }\n\n  /**\n   * Adds rectangle to spacial index\n   * @param {Rect} rect Rectangle\n   */\n  function addRect(rect) {\n    var size = Math.max(rect.width, rect.height);\n    var point = rect.centerPoint();\n\n    for (var index = 0, len = _buckets.length; index < len; index += 1) {\n      var bucket = _buckets[index];\n\n      if (size <= bucket.maximum || index == len - 1) {\n        point.context = rect;\n        bucket.quadTree.addPoint(point);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Callback function for iteration of spacial index rectangles\n   * \n   * @callback onSpatialIndexItemCallback\n   * @param {React} rect Rectangle\n   * @returns {boolean} Returns true to break iteration process.\n   */\n\n  /**\n   * Loops rectangular area of spacial index\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {Rect} rect Rectangular search area\n   * @param {onSpatialIndexItemCallback} onItem Callback function to call for every rectangle intersecting given rectangular search area\n   */\n  function loopArea(thisArg, rect, onItem) { // onItem = function(itemid) {}\n    if (onItem != null) {\n      for (var index = 0, len = _buckets.length; index < len; index += 1) {\n        var bucket = _buckets[index];\n        var bucketRect = new Rect(rect);\n        bucketRect.offset(bucket.maximum / 2.0);\n        bucket.quadTree.loopArea(this, bucketRect, function (point) {\n          var pointRect = point.context;\n\n          if (rect.overlaps(pointRect)) {\n            return onItem.call(thisArg, pointRect);\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Validates internal data consistency of spacial index data structure\n   * \n   * @ignore\n   * @returns {boolean} Returns true if structure pass validation\n   */\n  function validate() {\n    var result = true;\n    for (var index = 0, len = _buckets.length; index < len; index += 1) {\n      var bucket = _buckets[index];\n\n      result = result && bucket.quadTree.validate();\n    }\n    return result;\n  }\n\n  /**\n   * Returns collection of quadrants created in spacial index\n   * Quadrants exists only when elements exists in them.\n   * This method is used for visual debugging of the structure.\n   * \n   * @ignore\n   * @param {React} selection Rectangular test area to highlight quadrants\n   * @returns {Rect[]} Returns collection of available quadrants.\n   * Quadrants containing points within selection area have context.highlight property set to true.\n   */\n  function getPositions(selection) {\n    var result = [];\n    for (var index = 0, len = _buckets.length; index < len; index += 1) {\n      var bucket = _buckets[index];\n\n      result = result.concat(bucket.quadTree.getPositions(selection));\n    }\n    return result;\n  }\n\n  return {\n    addRect: addRect,\n    loopArea: loopArea,\n    validate: validate,\n    getPositions: getPositions\n  };\n};"]},"metadata":{},"sourceType":"module"}