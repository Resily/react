{"ast":null,"code":"/**\n * Creates linked hash list collection.\n * @class LinkedHashItems\n * \n * @returns {LinkedHashItems} Returns linked hash list structure\n */\nexport default function LinkedHashItems() {\n  var segmentsHash = {},\n      nextKeys = {},\n      prevKeys = {},\n      startSegmentKey = null,\n      endSegmentKey = null;\n  /**\n   * Adds new item to collection\n   * @param {string} key The new item key \n   * @param {object} item The new item context object value\n   */\n\n  function add(key, item) {\n    if (segmentsHash.hasOwnProperty(key)) {\n      throw \"Duplicate segments are not supported!\";\n    }\n\n    segmentsHash[key] = item;\n    nextKeys[key] = null;\n\n    if (endSegmentKey == null) {\n      startSegmentKey = key;\n      prevKeys[key] = null;\n    } else {\n      nextKeys[endSegmentKey] = key;\n      prevKeys[key] = endSegmentKey;\n    }\n\n    endSegmentKey = key;\n  }\n  /**\n   * Checks if collection is empty\n   * \n   * @returns {boolean} Returns true if collection is empty\n   */\n\n\n  function isEmpty() {\n    return startSegmentKey == null;\n  }\n  /**\n   * Item context object\n   * \n   * @param {string} key The item's key\n   * @returns {object} Returns context object\n   */\n\n\n  function item(key) {\n    return segmentsHash[key];\n  }\n  /**\n   * Gets next key\n   * \n   * @param {string} key The item key\n   * @returns {string} Returns key of the next collection item\n   */\n\n\n  function nextKey(key) {\n    return nextKeys[key];\n  }\n  /**\n   * Gets previous key\n   * \n   * @param {string} key The item key\n   * @returns {string} Returns key of the previous collection item\n   */\n\n\n  function prevKey(key) {\n    return prevKeys[key];\n  }\n  /**\n   * First collection item key\n   * \n   * @returns {string} Returns the key of the first item in the collection\n   */\n\n\n  function startKey() {\n    return startSegmentKey;\n  }\n  /**\n   * Last collection item key\n   * \n   * @returns {string} Returns key of the last item in the collection\n   */\n\n\n  function endKey() {\n    return endSegmentKey;\n  }\n  /**\n  * Adds new item to the head of the list\n  * \n  * @param {string} key The new item key \n  * @param {object} item The new item context object value\n  * @returns {string} Returns key of the last item in the collection\n  */\n\n\n  function unshift(key, item) {\n    if (segmentsHash.hasOwnProperty(key)) {\n      throw \"Duplicate segments are not supported!\";\n    }\n\n    segmentsHash[key] = item;\n    prevKeys[key] = null;\n\n    if (startSegmentKey == null) {\n      endSegmentKey = key;\n      nextKeys[key] = null;\n    } else {\n      prevKeys[startSegmentKey] = key;\n      nextKeys[key] = startSegmentKey;\n    }\n\n    startSegmentKey = key;\n  }\n  /**\n  * Inserts new item into the list after the given key \n  *  \n  * @param {string} afterKey The key that the new element is placed after \n  * @param {string} key The new item key \n  * @param {object} item The new item context object value\n  */\n\n\n  function insertAfter(afterKey, key, item) {\n    if (segmentsHash.hasOwnProperty(key)) {\n      throw \"Duplicate segments are not supported!\";\n    }\n\n    if (afterKey == null) {\n      unshift(key, item);\n    } else {\n      var nextKey = nextKeys[afterKey];\n\n      if (nextKey == null) {\n        add(key, item);\n      } else {\n        segmentsHash[key] = item;\n        nextKeys[afterKey] = key;\n        nextKeys[key] = nextKey;\n        prevKeys[nextKey] = key;\n        prevKeys[key] = afterKey;\n      }\n    }\n  }\n  /**\n   * Inserts new item into the list before the given key  \n   * \n   * @param {string} beforeKey The key that the new element is placed before \n   * @param {string} key The new item key \n   * @param {object} item The new item context object value\n   */\n\n\n  function insertBefore(beforeKey, key, item) {\n    if (segmentsHash.hasOwnProperty(key)) {\n      throw \"Duplicate segments are not supported!\";\n    }\n\n    if (beforeKey == null || !segmentsHash.hasOwnProperty(beforeKey)) {\n      throw \"Before key should be defined!\";\n    }\n\n    var prevKey = prevKeys[beforeKey];\n\n    if (prevKey == null) {\n      unshift(key, item);\n    } else {\n      insertAfter(prevKey, key, item);\n    }\n  }\n  /**\n   * Removes item\n   * @param {string} key The key of the item \n   */\n\n\n  function remove(key) {\n    var prevKey = prevKeys[key],\n        nextKey = nextKeys[key];\n\n    if (prevKey != null) {\n      nextKeys[prevKey] = nextKey;\n    } else {\n      startSegmentKey = nextKey;\n    }\n\n    if (nextKey != null) {\n      prevKeys[nextKey] = prevKey;\n    } else {\n      endSegmentKey = prevKey;\n    }\n\n    delete segmentsHash[key];\n    delete nextKeys[key];\n    delete prevKeys[key];\n  }\n  /**\n   * Empties collection\n   */\n\n\n  function empty() {\n    segmentsHash = {};\n    nextKeys = {};\n    prevKeys = {};\n    startSegmentKey = null;\n    endSegmentKey = null;\n  }\n\n  function _iterate(forward, onItem, startKey, endKey) {\n    var key = startKey,\n        segment;\n\n    if (key == null) {\n      key = forward ? startSegmentKey : endSegmentKey;\n    }\n\n    if (onItem != null) {\n      while (key != null) {\n        segment = segmentsHash[key];\n\n        if (segment != null) {\n          if (onItem(segment, key)) {\n            return;\n          }\n        }\n\n        if (key == endKey) {\n          key = null;\n        } else {\n          key = forward ? nextKeys[key] : prevKeys[key];\n        }\n      }\n    }\n  }\n  /**\n   * Appends one list to another\n   * \n   * @param {LinkedHashItems} list A list to append to the end of the current list  \n   */\n\n\n  function attach(list) {\n    list.iterate(function (segment, key) {\n      add(key, segment);\n    });\n  }\n  /**\n   * Callback function for iterating list items\n   * \n   * @callback onLinkedHashItemsCallback\n   * @param {object} item  The item context object\n   * @param {string} key The item key\n   * @returns {boolean} Returns true to break the iteration process\n   */\n\n  /**\n   * Loops items of the collection\n   * @param {onLinkedHashItemsCallback} onItem  Callback function for iterating collection items\n   * @param {string} startKey The key to start iteration from \n   * @param {string} endKey The key to end iteration at\n   */\n\n\n  function iterate(onItem, startKey, endKey) {\n    _iterate(true, onItem, startKey, endKey);\n  }\n  /**\n   * Loops items of the collection backward\n   * @param {onLinkedHashItemsCallback} onItem  Callback function for iterating collection items\n   * @param {string} startKey The key to start iteration from \n   * @param {string} endKey The key to end iteration at\n   */\n\n\n  function iterateBack(onItem, startKey, endKey) {\n    _iterate(false, onItem, startKey, endKey);\n  }\n  /**\n   * Validates internal data consistency of the structure\n   * @returns {boolean} Returns true if it pass validation\n   */\n\n\n  function validate(info) {\n    var key, prevKey, nextKey;\n\n    for (key in segmentsHash) {\n      if (segmentsHash.hasOwnProperty(key)) {\n        if (!nextKeys.hasOwnProperty(key) || !prevKeys.hasOwnProperty(key)) {\n          if (info != null) {\n            info.message = \"Orphant key found!\";\n          }\n\n          return false;\n        }\n      }\n    }\n\n    if (!segmentsHash.hasOwnProperty(startSegmentKey) || !segmentsHash.hasOwnProperty(endSegmentKey)) {\n      if (info != null) {\n        info.message = \"Start or end values are missing!\";\n      }\n\n      return false;\n    }\n\n    for (key in nextKeys) {\n      if (nextKeys.hasOwnProperty(key)) {\n        if (!segmentsHash.hasOwnProperty(key) || !prevKeys.hasOwnProperty(key)) {\n          if (info != null) {\n            info.message = \"Orphant key found!\";\n          }\n\n          return false;\n        }\n\n        nextKey = nextKeys[key];\n\n        if (nextKey && !nextKeys.hasOwnProperty(nextKey)) {\n          if (info != null) {\n            info.message = \"Next key not found!\";\n          }\n\n          return false;\n        }\n      }\n    }\n\n    for (key in prevKeys) {\n      if (prevKeys.hasOwnProperty(key)) {\n        if (!segmentsHash.hasOwnProperty(key) || !nextKeys.hasOwnProperty(key)) {\n          if (info != null) {\n            info.message = \"Orphant key found!\";\n          }\n\n          return false;\n        }\n\n        prevKey = prevKeys[key];\n\n        if (prevKey && !prevKeys.hasOwnProperty(prevKey)) {\n          if (info != null) {\n            info.message = \"Prev key not found!\";\n          }\n\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Returns a regular javascript array of collection items\n   * \n   * @returns {object[]} Returns array containing items of the collection\n   */\n\n\n  function toArray() {\n    var result = [];\n    iterate(function (item) {\n      result.push(item);\n    });\n    return result;\n  }\n\n  return {\n    add: add,\n    item: item,\n    nextKey: nextKey,\n    prevKey: prevKey,\n    startKey: startKey,\n    endKey: endKey,\n    unshift: unshift,\n    insertAfter: insertAfter,\n    insertBefore: insertBefore,\n    remove: remove,\n    isEmpty: isEmpty,\n    attach: attach,\n    iterate: iterate,\n    iterateBack: iterateBack,\n    empty: empty,\n    toArray: toArray,\n    validate: validate\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/LinkedHashItems.js"],"names":["LinkedHashItems","segmentsHash","nextKeys","prevKeys","startSegmentKey","endSegmentKey","add","key","item","hasOwnProperty","isEmpty","nextKey","prevKey","startKey","endKey","unshift","insertAfter","afterKey","insertBefore","beforeKey","remove","empty","_iterate","forward","onItem","segment","attach","list","iterate","iterateBack","validate","info","message","toArray","result","push"],"mappings":"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","sourcesContent":["/**\n * Creates linked hash list collection.\n * @class LinkedHashItems\n * \n * @returns {LinkedHashItems} Returns linked hash list structure\n */\nexport default function LinkedHashItems() {\n  var segmentsHash = {},\n    nextKeys = {},\n    prevKeys = {},\n    startSegmentKey = null,\n    endSegmentKey = null;\n\n  /**\n   * Adds new item to collection\n   * @param {string} key The new item key \n   * @param {object} item The new item context object value\n   */\n  function add(key, item) {\n    if (segmentsHash.hasOwnProperty(key)) {\n      throw \"Duplicate segments are not supported!\";\n    }\n    segmentsHash[key] = item;\n    nextKeys[key] = null;\n    if (endSegmentKey == null) {\n      startSegmentKey = key;\n      prevKeys[key] = null;\n    } else {\n      nextKeys[endSegmentKey] = key;\n      prevKeys[key] = endSegmentKey;\n    }\n    endSegmentKey = key;\n  }\n\n  /**\n   * Checks if collection is empty\n   * \n   * @returns {boolean} Returns true if collection is empty\n   */\n  function isEmpty() {\n    return startSegmentKey == null;\n  }\n\n  /**\n   * Item context object\n   * \n   * @param {string} key The item's key\n   * @returns {object} Returns context object\n   */\n  function item(key) {\n    return segmentsHash[key];\n  }\n\n  /**\n   * Gets next key\n   * \n   * @param {string} key The item key\n   * @returns {string} Returns key of the next collection item\n   */\n  function nextKey(key) {\n    return nextKeys[key];\n  }\n\n  /**\n   * Gets previous key\n   * \n   * @param {string} key The item key\n   * @returns {string} Returns key of the previous collection item\n   */\n  function prevKey(key) {\n    return prevKeys[key];\n  }\n\n  /**\n   * First collection item key\n   * \n   * @returns {string} Returns the key of the first item in the collection\n   */\n  function startKey() {\n    return startSegmentKey;\n  }\n\n  /**\n   * Last collection item key\n   * \n   * @returns {string} Returns key of the last item in the collection\n   */\n  function endKey() {\n    return endSegmentKey;\n  }\n\n  /**\n  * Adds new item to the head of the list\n  * \n  * @param {string} key The new item key \n  * @param {object} item The new item context object value\n  * @returns {string} Returns key of the last item in the collection\n  */\n  function unshift(key, item) {\n    if (segmentsHash.hasOwnProperty(key)) {\n      throw \"Duplicate segments are not supported!\";\n    }\n    segmentsHash[key] = item;\n    prevKeys[key] = null;\n    if (startSegmentKey == null) {\n      endSegmentKey = key;\n      nextKeys[key] = null;\n    } else {\n      prevKeys[startSegmentKey] = key;\n      nextKeys[key] = startSegmentKey;\n    }\n    startSegmentKey = key;\n  }\n\n  /**\n  * Inserts new item into the list after the given key \n  *  \n  * @param {string} afterKey The key that the new element is placed after \n  * @param {string} key The new item key \n  * @param {object} item The new item context object value\n  */\n  function insertAfter(afterKey, key, item) {\n    if (segmentsHash.hasOwnProperty(key)) {\n      throw \"Duplicate segments are not supported!\";\n    }\n\n    if (afterKey == null) {\n      unshift(key, item);\n    } else {\n      var nextKey = nextKeys[afterKey];\n      if (nextKey == null) {\n        add(key, item);\n      } else {\n        segmentsHash[key] = item;\n        nextKeys[afterKey] = key;\n        nextKeys[key] = nextKey;\n        prevKeys[nextKey] = key;\n        prevKeys[key] = afterKey;\n      }\n    }\n  }\n\n  /**\n   * Inserts new item into the list before the given key  \n   * \n   * @param {string} beforeKey The key that the new element is placed before \n   * @param {string} key The new item key \n   * @param {object} item The new item context object value\n   */\n  function insertBefore(beforeKey, key, item) {\n    if (segmentsHash.hasOwnProperty(key)) {\n      throw \"Duplicate segments are not supported!\";\n    }\n    if (beforeKey == null || !segmentsHash.hasOwnProperty(beforeKey)) {\n      throw \"Before key should be defined!\";\n    }\n    var prevKey = prevKeys[beforeKey];\n    if (prevKey == null) {\n      unshift(key, item);\n    } else {\n      insertAfter(prevKey, key, item)\n    }\n  }\n\n  /**\n   * Removes item\n   * @param {string} key The key of the item \n   */\n  function remove(key) {\n    var prevKey = prevKeys[key],\n      nextKey = nextKeys[key];\n\n    if (prevKey != null) {\n      nextKeys[prevKey] = nextKey;\n    } else {\n      startSegmentKey = nextKey;\n    }\n\n    if (nextKey != null) {\n      prevKeys[nextKey] = prevKey;\n    } else {\n      endSegmentKey = prevKey;\n    }\n\n    delete segmentsHash[key];\n    delete nextKeys[key];\n    delete prevKeys[key];\n  }\n\n  /**\n   * Empties collection\n   */\n  function empty() {\n    segmentsHash = {};\n    nextKeys = {};\n    prevKeys = {};\n    startSegmentKey = null;\n    endSegmentKey = null;\n  }\n\n  function _iterate(forward, onItem, startKey, endKey) {\n    var key = startKey,\n      segment;\n\n    if (key == null) {\n      key = forward ? startSegmentKey : endSegmentKey;\n    }\n\n    if (onItem != null) {\n      while (key != null) {\n        segment = segmentsHash[key];\n        if (segment != null) {\n          if (onItem(segment, key)) {\n            return;\n          }\n        }\n\n        if (key == endKey) {\n          key = null;\n        } else {\n          key = forward ? nextKeys[key] : prevKeys[key];\n        }\n      }\n    }\n  }\n\n  /**\n   * Appends one list to another\n   * \n   * @param {LinkedHashItems} list A list to append to the end of the current list  \n   */\n  function attach(list) {\n    list.iterate(function (segment, key) {\n      add(key, segment);\n    });\n  }\n\n  /**\n   * Callback function for iterating list items\n   * \n   * @callback onLinkedHashItemsCallback\n   * @param {object} item  The item context object\n   * @param {string} key The item key\n   * @returns {boolean} Returns true to break the iteration process\n   */\n\n  /**\n   * Loops items of the collection\n   * @param {onLinkedHashItemsCallback} onItem  Callback function for iterating collection items\n   * @param {string} startKey The key to start iteration from \n   * @param {string} endKey The key to end iteration at\n   */\n  function iterate(onItem, startKey, endKey) {\n    _iterate(true, onItem, startKey, endKey);\n  }\n\n  /**\n   * Loops items of the collection backward\n   * @param {onLinkedHashItemsCallback} onItem  Callback function for iterating collection items\n   * @param {string} startKey The key to start iteration from \n   * @param {string} endKey The key to end iteration at\n   */\n  function iterateBack(onItem, startKey, endKey) {\n    _iterate(false, onItem, startKey, endKey);\n  }\n\n  /**\n   * Validates internal data consistency of the structure\n   * @returns {boolean} Returns true if it pass validation\n   */\n  function validate(info) {\n    var key, prevKey, nextKey;\n    for (key in segmentsHash) {\n      if (segmentsHash.hasOwnProperty(key)) {\n        if (!nextKeys.hasOwnProperty(key) || !prevKeys.hasOwnProperty(key)) {\n          if (info != null) {\n            info.message = \"Orphant key found!\";\n          }\n          return false;\n        }\n      }\n    }\n    if (!segmentsHash.hasOwnProperty(startSegmentKey) || !segmentsHash.hasOwnProperty(endSegmentKey)) {\n      if (info != null) {\n        info.message = \"Start or end values are missing!\";\n      }\n      return false;\n    }\n    for (key in nextKeys) {\n      if (nextKeys.hasOwnProperty(key)) {\n        if (!segmentsHash.hasOwnProperty(key) || !prevKeys.hasOwnProperty(key)) {\n          if (info != null) {\n            info.message = \"Orphant key found!\";\n          }\n          return false;\n        }\n        nextKey = nextKeys[key];\n        if (nextKey && !nextKeys.hasOwnProperty(nextKey)) {\n          if (info != null) {\n            info.message = \"Next key not found!\";\n          }\n          return false;\n        }\n      }\n    }\n    for (key in prevKeys) {\n      if (prevKeys.hasOwnProperty(key)) {\n        if (!segmentsHash.hasOwnProperty(key) || !nextKeys.hasOwnProperty(key)) {\n          if (info != null) {\n            info.message = \"Orphant key found!\";\n          }\n          return false;\n        }\n        prevKey = prevKeys[key];\n        if (prevKey && !prevKeys.hasOwnProperty(prevKey)) {\n          if (info != null) {\n            info.message = \"Prev key not found!\";\n          }\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns a regular javascript array of collection items\n   * \n   * @returns {object[]} Returns array containing items of the collection\n   */\n  function toArray() {\n    var result = [];\n\n    iterate(function (item) {\n      result.push(item);\n    });\n\n    return result;\n  }\n\n  return {\n    add: add,\n    item: item,\n    nextKey: nextKey,\n    prevKey: prevKey,\n    startKey: startKey,\n    endKey: endKey,\n    unshift: unshift,\n    insertAfter: insertAfter,\n    insertBefore: insertBefore,\n    remove: remove,\n    isEmpty: isEmpty,\n    attach: attach,\n\n    iterate: iterate,\n    iterateBack: iterateBack,\n    empty: empty,\n    toArray: toArray,\n    validate: validate\n  };\n};"]},"metadata":{},"sourceType":"module"}