{"ast":null,"code":"/**\n * Callback for finding distance for a collection item\n *\n * @callback funcDistance\n * @param {Object} item A collection item\n * @param {number} index An index of the collection item\n * @returns {number} Returns a distance for the item \n */\n\n/**\n* @typedef {Object} BinarySearchResult\n* @property {number} index The index of the nearest item in the collection\n* @property {Object} item The nearest item\n*/\n\n/**\n * Search sorted list of elements for the nearest item.\n *\n * @param {Object[]} items - The collection of elements.\n * @param {funcDistance} callback - A callback function to get distance for the collection item. \n * @param {number} [startMinimum=undefined] - The minimum index in the array to start search from\n * @param {number} [startMaximum=undefined] - The maximum index in the array to start search from\n * @returns {BinarySearchResult} Returns an item of the collection, which is nearest to optimal measured by callback function\n*/\nexport default function binarySearch(items, callback, startMinimum, startMaximum) {\n  var result = null,\n      distance,\n      bestDistance,\n      minimum = startMinimum || 0,\n      maximum = startMaximum || items.length - 1,\n      middle,\n      item;\n\n  if (items.length > 0) {\n    item = items[minimum];\n    result = {\n      index: minimum,\n      item: item\n    };\n    distance = callback(item, minimum);\n\n    if (distance > 0) {\n      bestDistance = Math.abs(distance);\n      item = items[maximum];\n      distance = callback(item, maximum);\n\n      if (distance >= 0) {\n        result = {\n          index: maximum,\n          item: item\n        };\n      } else {\n        distance = Math.abs(distance);\n\n        if (bestDistance > distance) {\n          bestDistance = distance;\n          result = {\n            index: maximum,\n            item: item\n          };\n        }\n\n        while (minimum + 1 < maximum) {\n          middle = Math.round((minimum + maximum) / 2.0);\n          item = items[middle];\n          distance = callback(item, middle);\n\n          if (distance === 0) {\n            result = {\n              index: middle,\n              item: item\n            };\n            break;\n          } else {\n            if (distance > 0) {\n              minimum = middle;\n            } else {\n              maximum = middle;\n            }\n\n            distance = Math.abs(distance);\n\n            if (bestDistance > distance) {\n              bestDistance = distance;\n              result = {\n                index: middle,\n                item: item\n              };\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/binarySearch.js"],"names":["binarySearch","items","callback","startMinimum","startMaximum","result","distance","bestDistance","minimum","maximum","length","middle","item","index","Math","abs","round"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,YAAT,CAAsBC,KAAtB,EAA6BC,QAA7B,EAAuCC,YAAvC,EAAqDC,YAArD,EAAmE;AAChF,MAAIC,MAAM,GAAG,IAAb;AAAA,MACEC,QADF;AAAA,MAEEC,YAFF;AAAA,MAGEC,OAAO,GAAGL,YAAY,IAAI,CAH5B;AAAA,MAIEM,OAAO,GAAGL,YAAY,IAAKH,KAAK,CAACS,MAAN,GAAe,CAJ5C;AAAA,MAKEC,MALF;AAAA,MAMEC,IANF;;AAQA,MAAIX,KAAK,CAACS,MAAN,GAAe,CAAnB,EAAsB;AACpBE,IAAAA,IAAI,GAAGX,KAAK,CAACO,OAAD,CAAZ;AACAH,IAAAA,MAAM,GAAG;AAAEQ,MAAAA,KAAK,EAAEL,OAAT;AAAkBI,MAAAA,IAAI,EAAEA;AAAxB,KAAT;AACAN,IAAAA,QAAQ,GAAGJ,QAAQ,CAACU,IAAD,EAAOJ,OAAP,CAAnB;;AACA,QAAIF,QAAQ,GAAG,CAAf,EAAkB;AAChBC,MAAAA,YAAY,GAAGO,IAAI,CAACC,GAAL,CAAST,QAAT,CAAf;AAEAM,MAAAA,IAAI,GAAGX,KAAK,CAACQ,OAAD,CAAZ;AACAH,MAAAA,QAAQ,GAAGJ,QAAQ,CAACU,IAAD,EAAOH,OAAP,CAAnB;;AACA,UAAIH,QAAQ,IAAI,CAAhB,EAAmB;AACjBD,QAAAA,MAAM,GAAG;AAAEQ,UAAAA,KAAK,EAAEJ,OAAT;AAAkBG,UAAAA,IAAI,EAAEA;AAAxB,SAAT;AACD,OAFD,MAEO;AACLN,QAAAA,QAAQ,GAAGQ,IAAI,CAACC,GAAL,CAAST,QAAT,CAAX;;AACA,YAAIC,YAAY,GAAGD,QAAnB,EAA6B;AAC3BC,UAAAA,YAAY,GAAGD,QAAf;AACAD,UAAAA,MAAM,GAAG;AAAEQ,YAAAA,KAAK,EAAEJ,OAAT;AAAkBG,YAAAA,IAAI,EAAEA;AAAxB,WAAT;AACD;;AACD,eAAOJ,OAAO,GAAG,CAAV,GAAcC,OAArB,EAA8B;AAC5BE,UAAAA,MAAM,GAAGG,IAAI,CAACE,KAAL,CAAW,CAACR,OAAO,GAAGC,OAAX,IAAsB,GAAjC,CAAT;AACAG,UAAAA,IAAI,GAAGX,KAAK,CAACU,MAAD,CAAZ;AACAL,UAAAA,QAAQ,GAAGJ,QAAQ,CAACU,IAAD,EAAOD,MAAP,CAAnB;;AACA,cAAIL,QAAQ,KAAK,CAAjB,EAAoB;AAClBD,YAAAA,MAAM,GAAG;AAAEQ,cAAAA,KAAK,EAAEF,MAAT;AAAiBC,cAAAA,IAAI,EAAEA;AAAvB,aAAT;AACA;AACD,WAHD,MAGO;AACL,gBAAIN,QAAQ,GAAG,CAAf,EAAkB;AAChBE,cAAAA,OAAO,GAAGG,MAAV;AACD,aAFD,MAEO;AACLF,cAAAA,OAAO,GAAGE,MAAV;AACD;;AACDL,YAAAA,QAAQ,GAAGQ,IAAI,CAACC,GAAL,CAAST,QAAT,CAAX;;AACA,gBAAIC,YAAY,GAAGD,QAAnB,EAA6B;AAC3BC,cAAAA,YAAY,GAAGD,QAAf;AACAD,cAAAA,MAAM,GAAG;AAAEQ,gBAAAA,KAAK,EAAEF,MAAT;AAAiBC,gBAAAA,IAAI,EAAEA;AAAvB,eAAT;AACD;AACF;AACF;AACF;AACF;AACF;;AACD,SAAOP,MAAP;AACD;AAAA","sourcesContent":["/**\n * Callback for finding distance for a collection item\n *\n * @callback funcDistance\n * @param {Object} item A collection item\n * @param {number} index An index of the collection item\n * @returns {number} Returns a distance for the item \n */\n\n/**\n* @typedef {Object} BinarySearchResult\n* @property {number} index The index of the nearest item in the collection\n* @property {Object} item The nearest item\n*/\n\n/**\n * Search sorted list of elements for the nearest item.\n *\n * @param {Object[]} items - The collection of elements.\n * @param {funcDistance} callback - A callback function to get distance for the collection item. \n * @param {number} [startMinimum=undefined] - The minimum index in the array to start search from\n * @param {number} [startMaximum=undefined] - The maximum index in the array to start search from\n * @returns {BinarySearchResult} Returns an item of the collection, which is nearest to optimal measured by callback function\n*/\nexport default function binarySearch(items, callback, startMinimum, startMaximum) {\n  var result = null,\n    distance,\n    bestDistance,\n    minimum = startMinimum || 0,\n    maximum = startMaximum || (items.length - 1),\n    middle,\n    item;\n\n  if (items.length > 0) {\n    item = items[minimum];\n    result = { index: minimum, item: item };\n    distance = callback(item, minimum);\n    if (distance > 0) {\n      bestDistance = Math.abs(distance);\n\n      item = items[maximum];\n      distance = callback(item, maximum);\n      if (distance >= 0) {\n        result = { index: maximum, item: item };\n      } else {\n        distance = Math.abs(distance);\n        if (bestDistance > distance) {\n          bestDistance = distance;\n          result = { index: maximum, item: item };\n        }\n        while (minimum + 1 < maximum) {\n          middle = Math.round((minimum + maximum) / 2.0);\n          item = items[middle];\n          distance = callback(item, middle);\n          if (distance === 0) {\n            result = { index: middle, item: item };\n            break;\n          } else {\n            if (distance > 0) {\n              minimum = middle;\n            } else {\n              maximum = middle;\n            }\n            distance = Math.abs(distance);\n            if (bestDistance > distance) {\n              bestDistance = distance;\n              result = { index: middle, item: item };\n            }\n          }\n        }\n      }\n    }\n  }\n  return result;\n};"]},"metadata":{},"sourceType":"module"}