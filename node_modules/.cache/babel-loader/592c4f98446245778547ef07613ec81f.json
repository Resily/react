{"ast":null,"code":"import Thickness from '../graphics/structs/Thickness';\nimport Size from '../graphics/structs/Size';\nimport { LineType, Enabled } from '../enums';\n/**\n * @class TemplateConfig\n * @classdesc Template configuration object defines DOM elements for node content, cursor and highlight visual representation.\n * They are grouped into one configuration object because if we decide to customize cursor or highlight templates most likely\n * we are going to make them item template specific. At the same time control does not require all 3 of them to be defined.\n * If cursor or highlight templates properties are not set in template configuration object then control uses internal\n * default template for all of them. Generally all 3 templates can be set to null, so default templates are going to be used\n * by control.\n */\n\nexport default function TemplateConfig() {\n  /**\n   * Name. Every template configuration object has name property, it is being used to reference templates from items.\n   * This name is used to as an argument of call back rendering function as well. If item has not template name set \n   * it uses default template for rendering.\n   * \n   * @type {string}\n   */\n  this.name = null;\n  /**\n   * If true it makes templated items inactive in diagram layout. Inactive items are regular items excluded from navigation, that means \n   * when use auto fit mode, selection of neighboring node to inactive item makes all nodes of inactive item shown in full\n   * size as well. Inactive items play a role of in layout annotations having no user interaction and templated with HTML.\n   * For example they can be used to add titles into family diagram layout or terminator items indicating that upon reaching\n   * them diagram would load extra nodes into layout.\n   * \n   * @type {boolean}\n   */\n\n  this.isActive = true;\n  /**\n   * Size. Control deals with fixed size layout, it makes no guesses about content and size of nodes.\n   * So we don't support in any form nodes auto sizing. In order to support such feature control should measure content\n   * of every node before rendering cycle. Taking into account that nodes visibility depends on available space it is going\n   * to be infinite loop of diagram layout and nodes measure iterations. The more space we provide to nodes the less number \n   * of diagram nodes is going to be visible. So control expect that node size is hard valued in template configuration.\n   * \n   * @type {Size}\n   */\n\n  this.itemSize = new Size(120, 100);\n  /**\n   * Border width. We use archaic method to layout cursor and highlight frames around nodes, so we need to know border\n   * width in order measure gaps between them properly.\n   * \n   * @type {number}\n   */\n\n  this.itemBorderWidth = 1;\n  /**\n   * Item template. Supported template formats: Control provide two distinct ways to define item templates.\n   * The original one is based on setting HTML elements content via innerHTML DOM element property, see following reference \n   * at https://developer.mozilla.org web site for more details. The modern way is to use JSON ML library that is our recommended\n   * solution for templates definition, see following web site for more details http://www.jsonml.org/. This is only 3d party\n   * MIT licensed code included into our code base, everything else is 100% authentic. We adopted it with minor modifications,\n   * it generally works according to its original design.\n   * \n   * The control calls `onItemRender` callback function when specific node cursor needs to be rendered with this template.\n   * \n   * @type {string|object}\n   */\n\n  this.itemTemplate = null;\n  /**\n   * Marker type. The shape of the marker when node is minimized by auto fit. The control supports auto fit of the diagram into available screen space.\n   * When diagram size significantly larger than available screen space, its scrolling and navigation becomes problematic,\n   * so control supports automatic diagram fit into the screen space via rendering some of its nodes in form of small markers.\n   * So this option sets marker shape for nodes templated with this template.\n   * \n   * @type {ShapeType}\n   */\n\n  this.minimizedItemShapeType = null;\n  /**\n   * Marker size.\n   * \n   * @type {Size}\n   */\n\n  this.minimizedItemSize = new Size(4, 4);\n  /**\n   * Marker corder radius for simple squares. By default it is null and dots displayed as cycles. If corner radius set to 0 then\n   * they are displayed as regular squares.\n   * \n   * @type {number}\n   */\n\n  this.minimizedItemCornerRadius = null;\n  /**\n   * Marker border line width\n   * \n   * @type {number}\n   */\n\n  this.minimizedItemLineWidth = 1;\n  /**\n   * Marker border line color. By default it is the same as `itemTitleColor` of rendered node.\n   * \n   * @type {string}\n   */\n\n  this.minimizedItemBorderColor = null;\n  /*\n    Marker border line pattern\n    \n    @type {LineType}\n  */\n\n  this.minimizedItemLineType = LineType.Solid;\n  /**\n   * Marker fill color. By default it is the same as `itemTitleColor` of rendered node.\n   * \n   * @type {string}\n   */\n\n  this.minimizedItemFillColor = null;\n  /**\n   * Marker fill color opacity.\n   * \n   * @type {number}\n   */\n\n  this.minimizedItemOpacity = 1;\n  /**\n   * Highlight frame offset from node.\n   * \n   * @type {Thickness}\n   */\n\n  this.highlightPadding = new Thickness(2, 2, 2, 2);\n  /**\n   * Highlight frame border width.\n   * \n   * @type {number}\n   */\n\n  this.highlightBorderWidth = 1;\n  /**\n   * Highlight Template.\n   * \n   * The control calls `onHighlightRender` callback function when specific node highlight needs to be rendered with this template.\n   * \n   * @type {string|object}\n   */\n\n  this.highlightTemplate = null;\n  /**\n   * Cursor frame offset from node.\n   * \n   * @type {Thickness}\n   */\n\n  this.cursorPadding = new Thickness(3, 3, 3, 3);\n  /**\n   * Cursor frame border width.\n   * \n   * @type {number}\n   */\n\n  this.cursorBorderWidth = 2;\n  /**\n   * Cursor Template.\n   * \n   * The control calls `onCursorRender` callback function when specific node cursor needs to be rendered with this template.\n   * \n   * @type {string|object}\n   */\n\n  this.cursorTemplate = null;\n  /**\n   * Sets buttons panel visibility.\n   * \n   * `Auto` - depends on master config `hasButtons` property setting.\n   * `True` - visible\n   * `False` - hidden\n   * \n   * @group Templates\n   * @type {boolean}\n   */\n\n  this.hasButtons = Enabled.Auto;\n  /**\n   * This callback function is used in React component. It basically makes buttons obsolete \n   * and gives end user possibility to render any content in buttons panel.\n   * \n   * @ignore\n   */\n\n  this.onButtonsRender = null;\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/configs/TemplateConfig.js"],"names":["Thickness","Size","LineType","Enabled","TemplateConfig","name","isActive","itemSize","itemBorderWidth","itemTemplate","minimizedItemShapeType","minimizedItemSize","minimizedItemCornerRadius","minimizedItemLineWidth","minimizedItemBorderColor","minimizedItemLineType","Solid","minimizedItemFillColor","minimizedItemOpacity","highlightPadding","highlightBorderWidth","highlightTemplate","cursorPadding","cursorBorderWidth","cursorTemplate","hasButtons","Auto","onButtonsRender"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,+BAAtB;AACA,OAAOC,IAAP,MAAiB,0BAAjB;AACA,SAASC,QAAT,EAAmBC,OAAnB,QAAkC,UAAlC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,cAAT,GAA0B;AACvC;AACF;AACA;AACA;AACA;AACA;AACA;AACE,OAAKC,IAAL,GAAY,IAAZ;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,QAAL,GAAgB,IAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,QAAL,GAAgB,IAAIN,IAAJ,CAAS,GAAT,EAAc,GAAd,CAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKO,eAAL,GAAuB,CAAvB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,YAAL,GAAoB,IAApB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,sBAAL,GAA8B,IAA9B;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,iBAAL,GAAyB,IAAIV,IAAJ,CAAS,CAAT,EAAY,CAAZ,CAAzB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKW,yBAAL,GAAiC,IAAjC;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,sBAAL,GAA8B,CAA9B;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,wBAAL,GAAgC,IAAhC;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,qBAAL,GAA6Bb,QAAQ,CAACc,KAAtC;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,sBAAL,GAA8B,IAA9B;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,oBAAL,GAA4B,CAA5B;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,gBAAL,GAAwB,IAAInB,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,CAAxB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKoB,oBAAL,GAA4B,CAA5B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,iBAAL,GAAyB,IAAzB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,aAAL,GAAqB,IAAItB,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,CAArB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKuB,iBAAL,GAAyB,CAAzB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,cAAL,GAAsB,IAAtB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkBtB,OAAO,CAACuB,IAA1B;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,eAAL,GAAuB,IAAvB;AACD;AAAA","sourcesContent":["import Thickness from '../graphics/structs/Thickness';\nimport Size from '../graphics/structs/Size';\nimport { LineType, Enabled } from '../enums';\n\n/**\n * @class TemplateConfig\n * @classdesc Template configuration object defines DOM elements for node content, cursor and highlight visual representation.\n * They are grouped into one configuration object because if we decide to customize cursor or highlight templates most likely\n * we are going to make them item template specific. At the same time control does not require all 3 of them to be defined.\n * If cursor or highlight templates properties are not set in template configuration object then control uses internal\n * default template for all of them. Generally all 3 templates can be set to null, so default templates are going to be used\n * by control.\n */\nexport default function TemplateConfig() {\n  /**\n   * Name. Every template configuration object has name property, it is being used to reference templates from items.\n   * This name is used to as an argument of call back rendering function as well. If item has not template name set \n   * it uses default template for rendering.\n   * \n   * @type {string}\n   */\n  this.name = null;\n\n  /**\n   * If true it makes templated items inactive in diagram layout. Inactive items are regular items excluded from navigation, that means \n   * when use auto fit mode, selection of neighboring node to inactive item makes all nodes of inactive item shown in full\n   * size as well. Inactive items play a role of in layout annotations having no user interaction and templated with HTML.\n   * For example they can be used to add titles into family diagram layout or terminator items indicating that upon reaching\n   * them diagram would load extra nodes into layout.\n   * \n   * @type {boolean}\n   */\n  this.isActive = true;\n\n  /**\n   * Size. Control deals with fixed size layout, it makes no guesses about content and size of nodes.\n   * So we don't support in any form nodes auto sizing. In order to support such feature control should measure content\n   * of every node before rendering cycle. Taking into account that nodes visibility depends on available space it is going\n   * to be infinite loop of diagram layout and nodes measure iterations. The more space we provide to nodes the less number \n   * of diagram nodes is going to be visible. So control expect that node size is hard valued in template configuration.\n   * \n   * @type {Size}\n   */\n  this.itemSize = new Size(120, 100);\n\n  /**\n   * Border width. We use archaic method to layout cursor and highlight frames around nodes, so we need to know border\n   * width in order measure gaps between them properly.\n   * \n   * @type {number}\n   */\n  this.itemBorderWidth = 1;\n\n  /**\n   * Item template. Supported template formats: Control provide two distinct ways to define item templates.\n   * The original one is based on setting HTML elements content via innerHTML DOM element property, see following reference \n   * at https://developer.mozilla.org web site for more details. The modern way is to use JSON ML library that is our recommended\n   * solution for templates definition, see following web site for more details http://www.jsonml.org/. This is only 3d party\n   * MIT licensed code included into our code base, everything else is 100% authentic. We adopted it with minor modifications,\n   * it generally works according to its original design.\n   * \n   * The control calls `onItemRender` callback function when specific node cursor needs to be rendered with this template.\n   * \n   * @type {string|object}\n   */\n  this.itemTemplate = null;\n\n  /**\n   * Marker type. The shape of the marker when node is minimized by auto fit. The control supports auto fit of the diagram into available screen space.\n   * When diagram size significantly larger than available screen space, its scrolling and navigation becomes problematic,\n   * so control supports automatic diagram fit into the screen space via rendering some of its nodes in form of small markers.\n   * So this option sets marker shape for nodes templated with this template.\n   * \n   * @type {ShapeType}\n   */\n  this.minimizedItemShapeType = null;\n\n  /**\n   * Marker size.\n   * \n   * @type {Size}\n   */\n  this.minimizedItemSize = new Size(4, 4);\n\n  /**\n   * Marker corder radius for simple squares. By default it is null and dots displayed as cycles. If corner radius set to 0 then\n   * they are displayed as regular squares.\n   * \n   * @type {number}\n   */\n  this.minimizedItemCornerRadius = null;\n\n  /**\n   * Marker border line width\n   * \n   * @type {number}\n   */\n  this.minimizedItemLineWidth = 1;\n\n  /**\n   * Marker border line color. By default it is the same as `itemTitleColor` of rendered node.\n   * \n   * @type {string}\n   */\n  this.minimizedItemBorderColor = null;\n\n  /*\n    Marker border line pattern\n    \n    @type {LineType}\n  */\n  this.minimizedItemLineType = LineType.Solid;\n\n  /**\n   * Marker fill color. By default it is the same as `itemTitleColor` of rendered node.\n   * \n   * @type {string}\n   */\n  this.minimizedItemFillColor = null;\n\n  /**\n   * Marker fill color opacity.\n   * \n   * @type {number}\n   */\n  this.minimizedItemOpacity = 1;\n\n  /**\n   * Highlight frame offset from node.\n   * \n   * @type {Thickness}\n   */\n  this.highlightPadding = new Thickness(2, 2, 2, 2);\n\n  /**\n   * Highlight frame border width.\n   * \n   * @type {number}\n   */\n  this.highlightBorderWidth = 1;\n\n  /**\n   * Highlight Template.\n   * \n   * The control calls `onHighlightRender` callback function when specific node highlight needs to be rendered with this template.\n   * \n   * @type {string|object}\n   */\n  this.highlightTemplate = null;\n\n  /**\n   * Cursor frame offset from node.\n   * \n   * @type {Thickness}\n   */\n  this.cursorPadding = new Thickness(3, 3, 3, 3);\n\n  /**\n   * Cursor frame border width.\n   * \n   * @type {number}\n   */\n  this.cursorBorderWidth = 2;\n\n  /**\n   * Cursor Template.\n   * \n   * The control calls `onCursorRender` callback function when specific node cursor needs to be rendered with this template.\n   * \n   * @type {string|object}\n   */\n  this.cursorTemplate = null;\n\n  /**\n   * Sets buttons panel visibility.\n   * \n   * `Auto` - depends on master config `hasButtons` property setting.\n   * `True` - visible\n   * `False` - hidden\n   * \n   * @group Templates\n   * @type {boolean}\n   */\n  this.hasButtons = Enabled.Auto;\n\n  /**\n   * This callback function is used in React component. It basically makes buttons obsolete \n   * and gives end user possibility to render any content in buttons panel.\n   * \n   * @ignore\n   */\n  this.onButtonsRender = null;\n};\n"]},"metadata":{},"sourceType":"module"}