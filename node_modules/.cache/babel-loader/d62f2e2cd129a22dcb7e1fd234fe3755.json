{"ast":null,"code":"/**\n* Heap result object\n* @class HeapResult\n* @property {string} key Key\n* @property {number} priority Priority\n* @property {Object} item Context object\n*/\nexport function HeapResult(node) {\n  this.key = node.key;\n  this.priority = node.priority;\n  this.item = node.item;\n}\n/**\n * Creates Fibonacci Heap structure\n * @class FibonacciHeap\n * \n * @param {boolean} isMaximum Is maximum heap\n * @returns {FibonacciHeap} Returns new FibonacciHeap object\n */\n\nexport default function FibonacciHeap(isMaximum) {\n  var root = null,\n      count = 0,\n      nodes = {};\n\n  function Node(key, priority, item) {\n    this.key = key;\n    this.priority = priority;\n    this.item = item;\n    this.degree = 0;\n    this.marked = false;\n    this.parent = null;\n    this.child = null;\n    this.left = null;\n    this.right = null;\n  }\n  /**\n   * Validates internal structure consistency.\n   * \n   * @returns {boolean} Returns true if structure pass data consistency check.\n   */\n\n\n  function validate() {\n    var totalNodes = 0;\n\n    for (var key in nodes) {\n      if (nodes.hasOwnProperty(key)) {\n        var node = nodes[key];\n        totalNodes += 1;\n\n        if (node.child != null) {\n          if (!nodes.hasOwnProperty(node.child)) {\n            throw \"Child does not exists\";\n          }\n\n          var ref = nodes[node.child];\n\n          if (ref.parent != node.key) {\n            throw \"Child references wrong parent\";\n          }\n        }\n\n        if (node.parent != null) {\n          if (!nodes.hasOwnProperty(node.parent)) {\n            throw \"Parent does not exists\";\n          }\n        }\n\n        if (node.left != null) {\n          if (!nodes.hasOwnProperty(node.left)) {\n            throw \"Left does not exists\";\n          }\n\n          ref = nodes[node.left];\n\n          if (ref.right != node.key) {\n            throw \"Left references wrong right\";\n          }\n        }\n\n        if (node.right != null) {\n          if (!nodes.hasOwnProperty(node.right)) {\n            throw \"Right does not exists\";\n          }\n\n          ref = nodes[node.right];\n\n          if (ref.left != node.key) {\n            throw \"Right references wrong left\";\n          }\n        }\n      }\n    }\n\n    if (root == null && totalNodes > 0) {\n      throw \"Orphans\";\n    }\n\n    if (root != null) {\n      if (!nodes.hasOwnProperty(root)) {\n        throw \"Root node does not exists\";\n      }\n\n      node = nodes[root];\n\n      if (node.parent != null) {\n        throw \"Root node has parent reference\";\n      }\n\n      var children = [root];\n      var processed = {};\n      var totalChildren = 0;\n\n      while (children.length > 0) {\n        var newChildren = [];\n\n        for (var index = 0, len = children.length; index < len; index += 1) {\n          var child = nodes[children[index]];\n\n          while (!processed.hasOwnProperty(child.key)) {\n            processed[child.key] = true;\n            totalChildren += 1;\n\n            if (child.child != null) {\n              newChildren.push(child.child);\n            }\n\n            child = nodes[child.right];\n          }\n        }\n\n        children = newChildren;\n      }\n\n      if (totalNodes != totalChildren) {\n        throw \"Tree has loops or orpants\";\n      }\n    }\n  }\n  /**\n   * Adds a new item into the heap\n   * @param {string} key A key of the new element \n   * @param {number} priority A priority of the new element\n   * @param {object} item A context object of the new element \n   */\n\n\n  function add(key, priority, item) {\n    if (nodes.hasOwnProperty(key)) {\n      throw \"Duplicate keys are not supported!\";\n    }\n\n    var newNode = new Node(key, priority, item);\n    nodes[key] = newNode;\n\n    if (root == null) {\n      newNode.left = key;\n      newNode.right = key;\n      root = key;\n    } else {\n      var rootNode = nodes[root];\n\n      _insert(rootNode, newNode);\n\n      if (isMaximum ? rootNode.priority < newNode.priority : rootNode.priority > newNode.priority) {\n        root = key;\n      }\n    }\n\n    count += 1;\n  }\n\n  function _insert(node, newNode) {\n    var rightNode = nodes[node.right];\n    newNode.right = node.right;\n    newNode.left = node.key;\n    node.right = newNode.key;\n    rightNode.left = newNode.key;\n  }\n\n  function _exclude(node) {\n    var prevNode = nodes[node.left],\n        nextNode = nodes[node.right];\n    prevNode.right = nextNode.key;\n    nextNode.left = prevNode.key;\n    node.right = node.key;\n    node.left = node.key;\n  }\n  /**\n   * Gets priority of element by key\n   * @param {string} key The element key\n   * @returns {number} Returns priority of the element\n   */\n\n\n  function getPriority(key) {\n    var result = null;\n\n    if (nodes.hasOwnProperty(key)) {\n      result = nodes[key].priority;\n    }\n\n    return result;\n  }\n  /**\n   * Returns heap root element\n   * \n   * @returns {HeapResult} Returns root element of the heap \n   */\n\n\n  function heapRoot() {\n    var result = null;\n\n    if (root != null) {\n      result = new HeapResult(nodes[root]);\n    }\n\n    return result;\n  }\n  /**\n   * Returns heap root element with removal\n   * \n   * @returns {HeapResult} Returns root element of the heap \n   */\n\n\n  function extractRoot() {\n    var result = heapRoot();\n\n    if (result != null) {\n      var rootNode = nodes[root],\n          nextNode = nodes[rootNode.right];\n\n      if (rootNode.child != null) {\n        var childNode = nodes[rootNode.child],\n            childNodeLeft = nodes[childNode.left];\n        rootNode.right = childNode.key;\n        nextNode.left = childNodeLeft.key;\n        childNode.left = rootNode.key;\n        childNodeLeft.right = nextNode.key;\n\n        _exclude(rootNode);\n\n        delete nodes[rootNode.key];\n        root = null;\n\n        _consolidate(childNode.key);\n      } else {\n        _exclude(rootNode);\n\n        delete nodes[rootNode.key];\n        root = null;\n\n        if (nextNode.key != rootNode.key) {\n          _consolidate(nextNode.key);\n        }\n      }\n\n      count -= 1;\n    }\n\n    return result;\n  }\n\n  function _consolidate(startKey) {\n    var pairs = [],\n        pairedNode,\n        processed = {},\n        key = startKey;\n\n    while (!processed.hasOwnProperty(key)) {\n      var node = nodes[key],\n          nextKey = node.right;\n      processed[key] = true;\n      node.parent = null;\n\n      while ((pairedNode = pairs[node.degree]) != null) {\n        if (isMaximum ? node.priority > pairedNode.priority : node.priority < pairedNode.priority) {\n          _union(node, pairedNode);\n        } else {\n          _union(pairedNode, node);\n\n          node = pairedNode;\n        }\n\n        pairs[node.degree - 1] = null;\n      }\n\n      pairs[node.degree] = node;\n\n      if (root == null || nodes[root] == null || (isMaximum ? nodes[root].priority <= node.priority : nodes[root].priority >= node.priority)) {\n        root = node.key;\n      }\n\n      key = nextKey;\n    }\n  }\n\n  function _union(node1, node2) {\n    node1.degree += 1;\n\n    _exclude(node2);\n\n    var child = nodes[node1.child];\n\n    if (child != null) {\n      _insert(child, node2);\n\n      if (isMaximum ? child.priority < node2.priority : child.priority > node2.priority) {\n        node1.child = node2.key;\n      }\n    } else {\n      node1.child = node2.key;\n    }\n\n    node2.parent = node1.key;\n  }\n  /**\n   * Sets priority of an element by key\n   * @param {string} key The key of the element \n   * @param {number} priority Priority\n   */\n\n\n  function setPriority(key, priority) {\n    var node = nodes[key];\n\n    if (isMaximum ? node.priority > priority : node.priority < priority) {\n      throw \"Priority increase is not supported\";\n    }\n\n    node.priority = priority;\n\n    if (node.parent != null) {\n      var parentNode = nodes[node.parent];\n\n      if (isMaximum ? parentNode.priority < node.priority : parentNode.priority > node.priority) {\n        _cut(parentNode, node);\n\n        _cascadeCut(parentNode);\n      }\n    }\n\n    if (isMaximum ? nodes[root].priority < node.priority : nodes[root].priority > node.priority) {\n      root = node.key;\n    }\n  }\n\n  function _cut(parentNode, node) {\n    node.marked = false;\n    node.parent = null;\n\n    if (node.right == node.key) {\n      parentNode.child = null;\n    } else {\n      parentNode.child = node.right;\n\n      _exclude(node);\n    }\n\n    parentNode.degree -= 1;\n\n    _insert(nodes[root], node);\n  }\n\n  function _cascadeCut(node) {\n    if (node.parent != null) {\n      if (node.marked) {\n        var parentNode = nodes[node.parent];\n\n        _cut(parentNode, node);\n\n        _cascadeCut(parentNode);\n      } else {\n        node.marked = true;\n      }\n    }\n  }\n  /**\n   * Deletes heap element by key\n   * @param {string} key The Key \n   */\n\n\n  function deleteKey(key) {\n    setPriority(key, isMaximum ? Infinity : -1);\n    extractRoot();\n  }\n\n  return {\n    add: add,\n    getPriority: getPriority,\n    setPriority: setPriority,\n    heapRoot: heapRoot,\n    extractRoot: extractRoot,\n    deleteKey: deleteKey,\n    validate: validate\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/FibonacciHeap.js"],"names":["HeapResult","node","key","priority","item","FibonacciHeap","isMaximum","root","count","nodes","Node","degree","marked","parent","child","left","right","validate","totalNodes","hasOwnProperty","ref","children","processed","totalChildren","length","newChildren","index","len","push","add","newNode","rootNode","_insert","rightNode","_exclude","prevNode","nextNode","getPriority","result","heapRoot","extractRoot","childNode","childNodeLeft","_consolidate","startKey","pairs","pairedNode","nextKey","_union","node1","node2","setPriority","parentNode","_cut","_cascadeCut","deleteKey","Infinity"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,UAAT,CAAqBC,IAArB,EAA2B;AAChC,OAAKC,GAAL,GAAWD,IAAI,CAACC,GAAhB;AACA,OAAKC,QAAL,GAAgBF,IAAI,CAACE,QAArB;AACA,OAAKC,IAAL,GAAYH,IAAI,CAACG,IAAjB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,aAAT,CAAuBC,SAAvB,EAAkC;AAC/C,MAAIC,IAAI,GAAG,IAAX;AAAA,MACEC,KAAK,GAAG,CADV;AAAA,MAEEC,KAAK,GAAG,EAFV;;AAIA,WAASC,IAAT,CAAcR,GAAd,EAAmBC,QAAnB,EAA6BC,IAA7B,EAAmC;AACjC,SAAKF,GAAL,GAAWA,GAAX;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKO,MAAL,GAAc,CAAd;AACA,SAAKC,MAAL,GAAc,KAAd;AAEA,SAAKC,MAAL,GAAc,IAAd;AACA,SAAKC,KAAL,GAAa,IAAb;AACA,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,KAAL,GAAa,IAAb;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE,WAASC,QAAT,GAAoB;AAClB,QAAIC,UAAU,GAAG,CAAjB;;AACA,SAAK,IAAIhB,GAAT,IAAgBO,KAAhB,EAAuB;AACrB,UAAIA,KAAK,CAACU,cAAN,CAAqBjB,GAArB,CAAJ,EAA+B;AAC7B,YAAID,IAAI,GAAGQ,KAAK,CAACP,GAAD,CAAhB;AAEAgB,QAAAA,UAAU,IAAI,CAAd;;AAEA,YAAIjB,IAAI,CAACa,KAAL,IAAc,IAAlB,EAAwB;AACtB,cAAI,CAACL,KAAK,CAACU,cAAN,CAAqBlB,IAAI,CAACa,KAA1B,CAAL,EAAuC;AACrC,kBAAM,uBAAN;AACD;;AACD,cAAIM,GAAG,GAAGX,KAAK,CAACR,IAAI,CAACa,KAAN,CAAf;;AACA,cAAIM,GAAG,CAACP,MAAJ,IAAcZ,IAAI,CAACC,GAAvB,EAA4B;AAC1B,kBAAM,+BAAN;AACD;AACF;;AACD,YAAID,IAAI,CAACY,MAAL,IAAe,IAAnB,EAAyB;AACvB,cAAI,CAACJ,KAAK,CAACU,cAAN,CAAqBlB,IAAI,CAACY,MAA1B,CAAL,EAAwC;AACtC,kBAAM,wBAAN;AACD;AAEF;;AACD,YAAIZ,IAAI,CAACc,IAAL,IAAa,IAAjB,EAAuB;AACrB,cAAI,CAACN,KAAK,CAACU,cAAN,CAAqBlB,IAAI,CAACc,IAA1B,CAAL,EAAsC;AACpC,kBAAM,sBAAN;AACD;;AACDK,UAAAA,GAAG,GAAGX,KAAK,CAACR,IAAI,CAACc,IAAN,CAAX;;AACA,cAAIK,GAAG,CAACJ,KAAJ,IAAaf,IAAI,CAACC,GAAtB,EAA2B;AACzB,kBAAM,6BAAN;AACD;AACF;;AAED,YAAID,IAAI,CAACe,KAAL,IAAc,IAAlB,EAAwB;AACtB,cAAI,CAACP,KAAK,CAACU,cAAN,CAAqBlB,IAAI,CAACe,KAA1B,CAAL,EAAuC;AACrC,kBAAM,uBAAN;AACD;;AACDI,UAAAA,GAAG,GAAGX,KAAK,CAACR,IAAI,CAACe,KAAN,CAAX;;AACA,cAAII,GAAG,CAACL,IAAJ,IAAYd,IAAI,CAACC,GAArB,EAA0B;AACxB,kBAAM,6BAAN;AACD;AACF;AACF;AACF;;AACD,QAAIK,IAAI,IAAI,IAAR,IAAgBW,UAAU,GAAG,CAAjC,EAAoC;AAClC,YAAM,SAAN;AACD;;AAED,QAAIX,IAAI,IAAI,IAAZ,EAAkB;AAChB,UAAI,CAACE,KAAK,CAACU,cAAN,CAAqBZ,IAArB,CAAL,EAAiC;AAC/B,cAAM,2BAAN;AACD;;AAEDN,MAAAA,IAAI,GAAGQ,KAAK,CAACF,IAAD,CAAZ;;AACA,UAAIN,IAAI,CAACY,MAAL,IAAe,IAAnB,EAAyB;AACvB,cAAM,gCAAN;AACD;;AAED,UAAIQ,QAAQ,GAAG,CAACd,IAAD,CAAf;AACA,UAAIe,SAAS,GAAG,EAAhB;AACA,UAAIC,aAAa,GAAG,CAApB;;AACA,aAAOF,QAAQ,CAACG,MAAT,GAAkB,CAAzB,EAA4B;AAC1B,YAAIC,WAAW,GAAG,EAAlB;;AACA,aAAK,IAAIC,KAAK,GAAG,CAAZ,EAAeC,GAAG,GAAGN,QAAQ,CAACG,MAAnC,EAA2CE,KAAK,GAAGC,GAAnD,EAAwDD,KAAK,IAAI,CAAjE,EAAoE;AAClE,cAAIZ,KAAK,GAAGL,KAAK,CAACY,QAAQ,CAACK,KAAD,CAAT,CAAjB;;AACA,iBAAO,CAACJ,SAAS,CAACH,cAAV,CAAyBL,KAAK,CAACZ,GAA/B,CAAR,EAA6C;AAC3CoB,YAAAA,SAAS,CAACR,KAAK,CAACZ,GAAP,CAAT,GAAuB,IAAvB;AACAqB,YAAAA,aAAa,IAAI,CAAjB;;AACA,gBAAIT,KAAK,CAACA,KAAN,IAAe,IAAnB,EAAyB;AACvBW,cAAAA,WAAW,CAACG,IAAZ,CAAiBd,KAAK,CAACA,KAAvB;AACD;;AACDA,YAAAA,KAAK,GAAGL,KAAK,CAACK,KAAK,CAACE,KAAP,CAAb;AACD;AACF;;AACDK,QAAAA,QAAQ,GAAGI,WAAX;AACD;;AAED,UAAIP,UAAU,IAAIK,aAAlB,EAAiC;AAC/B,cAAM,2BAAN;AACD;AACF;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE,WAASM,GAAT,CAAa3B,GAAb,EAAkBC,QAAlB,EAA4BC,IAA5B,EAAkC;AAChC,QAAIK,KAAK,CAACU,cAAN,CAAqBjB,GAArB,CAAJ,EAA+B;AAC7B,YAAM,mCAAN;AACD;;AAED,QAAI4B,OAAO,GAAG,IAAIpB,IAAJ,CAASR,GAAT,EAAcC,QAAd,EAAwBC,IAAxB,CAAd;AACAK,IAAAA,KAAK,CAACP,GAAD,CAAL,GAAa4B,OAAb;;AAEA,QAAIvB,IAAI,IAAI,IAAZ,EAAkB;AAChBuB,MAAAA,OAAO,CAACf,IAAR,GAAeb,GAAf;AACA4B,MAAAA,OAAO,CAACd,KAAR,GAAgBd,GAAhB;AACAK,MAAAA,IAAI,GAAGL,GAAP;AACD,KAJD,MAIO;AACL,UAAI6B,QAAQ,GAAGtB,KAAK,CAACF,IAAD,CAApB;;AACAyB,MAAAA,OAAO,CAACD,QAAD,EAAWD,OAAX,CAAP;;AACA,UAAIxB,SAAS,GAAGyB,QAAQ,CAAC5B,QAAT,GAAoB2B,OAAO,CAAC3B,QAA/B,GAA0C4B,QAAQ,CAAC5B,QAAT,GAAoB2B,OAAO,CAAC3B,QAAnF,EAA6F;AAC3FI,QAAAA,IAAI,GAAGL,GAAP;AACD;AACF;;AACDM,IAAAA,KAAK,IAAI,CAAT;AACD;;AAED,WAASwB,OAAT,CAAiB/B,IAAjB,EAAuB6B,OAAvB,EAAgC;AAC9B,QAAIG,SAAS,GAAGxB,KAAK,CAACR,IAAI,CAACe,KAAN,CAArB;AACAc,IAAAA,OAAO,CAACd,KAAR,GAAgBf,IAAI,CAACe,KAArB;AACAc,IAAAA,OAAO,CAACf,IAAR,GAAed,IAAI,CAACC,GAApB;AACAD,IAAAA,IAAI,CAACe,KAAL,GAAac,OAAO,CAAC5B,GAArB;AACA+B,IAAAA,SAAS,CAAClB,IAAV,GAAiBe,OAAO,CAAC5B,GAAzB;AACD;;AAED,WAASgC,QAAT,CAAkBjC,IAAlB,EAAwB;AACtB,QAAIkC,QAAQ,GAAG1B,KAAK,CAACR,IAAI,CAACc,IAAN,CAApB;AAAA,QACEqB,QAAQ,GAAG3B,KAAK,CAACR,IAAI,CAACe,KAAN,CADlB;AAGAmB,IAAAA,QAAQ,CAACnB,KAAT,GAAiBoB,QAAQ,CAAClC,GAA1B;AACAkC,IAAAA,QAAQ,CAACrB,IAAT,GAAgBoB,QAAQ,CAACjC,GAAzB;AACAD,IAAAA,IAAI,CAACe,KAAL,GAAaf,IAAI,CAACC,GAAlB;AACAD,IAAAA,IAAI,CAACc,IAAL,GAAYd,IAAI,CAACC,GAAjB;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE,WAASmC,WAAT,CAAqBnC,GAArB,EAA0B;AACxB,QAAIoC,MAAM,GAAG,IAAb;;AACA,QAAI7B,KAAK,CAACU,cAAN,CAAqBjB,GAArB,CAAJ,EAA+B;AAC7BoC,MAAAA,MAAM,GAAG7B,KAAK,CAACP,GAAD,CAAL,CAAWC,QAApB;AACD;;AACD,WAAOmC,MAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE,WAASC,QAAT,GAAoB;AAClB,QAAID,MAAM,GAAG,IAAb;;AACA,QAAI/B,IAAI,IAAI,IAAZ,EAAkB;AAChB+B,MAAAA,MAAM,GAAG,IAAItC,UAAJ,CAAeS,KAAK,CAACF,IAAD,CAApB,CAAT;AACD;;AACD,WAAO+B,MAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE,WAASE,WAAT,GAAuB;AACrB,QAAIF,MAAM,GAAGC,QAAQ,EAArB;;AACA,QAAID,MAAM,IAAI,IAAd,EAAoB;AAClB,UAAIP,QAAQ,GAAGtB,KAAK,CAACF,IAAD,CAApB;AAAA,UACE6B,QAAQ,GAAG3B,KAAK,CAACsB,QAAQ,CAACf,KAAV,CADlB;;AAGA,UAAIe,QAAQ,CAACjB,KAAT,IAAkB,IAAtB,EAA4B;AAC1B,YAAI2B,SAAS,GAAGhC,KAAK,CAACsB,QAAQ,CAACjB,KAAV,CAArB;AAAA,YACE4B,aAAa,GAAGjC,KAAK,CAACgC,SAAS,CAAC1B,IAAX,CADvB;AAGAgB,QAAAA,QAAQ,CAACf,KAAT,GAAiByB,SAAS,CAACvC,GAA3B;AACAkC,QAAAA,QAAQ,CAACrB,IAAT,GAAgB2B,aAAa,CAACxC,GAA9B;AACAuC,QAAAA,SAAS,CAAC1B,IAAV,GAAiBgB,QAAQ,CAAC7B,GAA1B;AACAwC,QAAAA,aAAa,CAAC1B,KAAd,GAAsBoB,QAAQ,CAAClC,GAA/B;;AAEAgC,QAAAA,QAAQ,CAACH,QAAD,CAAR;;AACA,eAAOtB,KAAK,CAACsB,QAAQ,CAAC7B,GAAV,CAAZ;AAEAK,QAAAA,IAAI,GAAG,IAAP;;AACAoC,QAAAA,YAAY,CAACF,SAAS,CAACvC,GAAX,CAAZ;AACD,OAdD,MAcO;AACLgC,QAAAA,QAAQ,CAACH,QAAD,CAAR;;AACA,eAAOtB,KAAK,CAACsB,QAAQ,CAAC7B,GAAV,CAAZ;AAEAK,QAAAA,IAAI,GAAG,IAAP;;AACA,YAAI6B,QAAQ,CAAClC,GAAT,IAAgB6B,QAAQ,CAAC7B,GAA7B,EAAkC;AAChCyC,UAAAA,YAAY,CAACP,QAAQ,CAAClC,GAAV,CAAZ;AACD;AACF;;AACDM,MAAAA,KAAK,IAAI,CAAT;AACD;;AACD,WAAO8B,MAAP;AACD;;AAED,WAASK,YAAT,CAAsBC,QAAtB,EAAgC;AAC9B,QAAIC,KAAK,GAAG,EAAZ;AAAA,QAAgBC,UAAhB;AAAA,QACExB,SAAS,GAAG,EADd;AAAA,QAEEpB,GAAG,GAAG0C,QAFR;;AAGA,WAAO,CAACtB,SAAS,CAACH,cAAV,CAAyBjB,GAAzB,CAAR,EAAuC;AACrC,UAAID,IAAI,GAAGQ,KAAK,CAACP,GAAD,CAAhB;AAAA,UACE6C,OAAO,GAAG9C,IAAI,CAACe,KADjB;AAGAM,MAAAA,SAAS,CAACpB,GAAD,CAAT,GAAiB,IAAjB;AACAD,MAAAA,IAAI,CAACY,MAAL,GAAc,IAAd;;AAEA,aAAO,CAACiC,UAAU,GAAGD,KAAK,CAAC5C,IAAI,CAACU,MAAN,CAAnB,KAAqC,IAA5C,EAAkD;AAChD,YAAIL,SAAS,GAAGL,IAAI,CAACE,QAAL,GAAgB2C,UAAU,CAAC3C,QAA9B,GAAyCF,IAAI,CAACE,QAAL,GAAgB2C,UAAU,CAAC3C,QAAjF,EAA2F;AACzF6C,UAAAA,MAAM,CAAC/C,IAAD,EAAO6C,UAAP,CAAN;AACD,SAFD,MAEO;AACLE,UAAAA,MAAM,CAACF,UAAD,EAAa7C,IAAb,CAAN;;AACAA,UAAAA,IAAI,GAAG6C,UAAP;AACD;;AACDD,QAAAA,KAAK,CAAC5C,IAAI,CAACU,MAAL,GAAc,CAAf,CAAL,GAAyB,IAAzB;AACD;;AACDkC,MAAAA,KAAK,CAAC5C,IAAI,CAACU,MAAN,CAAL,GAAqBV,IAArB;;AAEA,UAAIM,IAAI,IAAI,IAAR,IAAgBE,KAAK,CAACF,IAAD,CAAL,IAAe,IAA/B,KAAwCD,SAAS,GAAGG,KAAK,CAACF,IAAD,CAAL,CAAYJ,QAAZ,IAAwBF,IAAI,CAACE,QAAhC,GAA2CM,KAAK,CAACF,IAAD,CAAL,CAAYJ,QAAZ,IAAwBF,IAAI,CAACE,QAAzH,CAAJ,EAAwI;AACtII,QAAAA,IAAI,GAAGN,IAAI,CAACC,GAAZ;AACD;;AAEDA,MAAAA,GAAG,GAAG6C,OAAN;AACD;AACF;;AAED,WAASC,MAAT,CAAgBC,KAAhB,EAAuBC,KAAvB,EAA8B;AAC5BD,IAAAA,KAAK,CAACtC,MAAN,IAAgB,CAAhB;;AACAuB,IAAAA,QAAQ,CAACgB,KAAD,CAAR;;AACA,QAAIpC,KAAK,GAAGL,KAAK,CAACwC,KAAK,CAACnC,KAAP,CAAjB;;AACA,QAAIA,KAAK,IAAI,IAAb,EAAmB;AACjBkB,MAAAA,OAAO,CAAClB,KAAD,EAAQoC,KAAR,CAAP;;AACA,UAAI5C,SAAS,GAAGQ,KAAK,CAACX,QAAN,GAAiB+C,KAAK,CAAC/C,QAA1B,GAAqCW,KAAK,CAACX,QAAN,GAAiB+C,KAAK,CAAC/C,QAAzE,EAAmF;AACjF8C,QAAAA,KAAK,CAACnC,KAAN,GAAcoC,KAAK,CAAChD,GAApB;AACD;AACF,KALD,MAKO;AACL+C,MAAAA,KAAK,CAACnC,KAAN,GAAcoC,KAAK,CAAChD,GAApB;AACD;;AACDgD,IAAAA,KAAK,CAACrC,MAAN,GAAeoC,KAAK,CAAC/C,GAArB;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE,WAASiD,WAAT,CAAqBjD,GAArB,EAA0BC,QAA1B,EAAoC;AAClC,QAAIF,IAAI,GAAGQ,KAAK,CAACP,GAAD,CAAhB;;AACA,QAAII,SAAS,GAAGL,IAAI,CAACE,QAAL,GAAgBA,QAAnB,GAA8BF,IAAI,CAACE,QAAL,GAAgBA,QAA3D,EAAqE;AACnE,YAAM,oCAAN;AACD;;AACDF,IAAAA,IAAI,CAACE,QAAL,GAAgBA,QAAhB;;AAEA,QAAIF,IAAI,CAACY,MAAL,IAAe,IAAnB,EAAyB;AACvB,UAAIuC,UAAU,GAAG3C,KAAK,CAACR,IAAI,CAACY,MAAN,CAAtB;;AACA,UAAIP,SAAS,GAAG8C,UAAU,CAACjD,QAAX,GAAsBF,IAAI,CAACE,QAA9B,GAAyCiD,UAAU,CAACjD,QAAX,GAAsBF,IAAI,CAACE,QAAjF,EAA2F;AACzFkD,QAAAA,IAAI,CAACD,UAAD,EAAanD,IAAb,CAAJ;;AACAqD,QAAAA,WAAW,CAACF,UAAD,CAAX;AACD;AACF;;AACD,QAAI9C,SAAS,GAAGG,KAAK,CAACF,IAAD,CAAL,CAAYJ,QAAZ,GAAuBF,IAAI,CAACE,QAA/B,GAA0CM,KAAK,CAACF,IAAD,CAAL,CAAYJ,QAAZ,GAAuBF,IAAI,CAACE,QAAnF,EAA6F;AAC3FI,MAAAA,IAAI,GAAGN,IAAI,CAACC,GAAZ;AACD;AACF;;AAED,WAASmD,IAAT,CAAcD,UAAd,EAA0BnD,IAA1B,EAAgC;AAC9BA,IAAAA,IAAI,CAACW,MAAL,GAAc,KAAd;AACAX,IAAAA,IAAI,CAACY,MAAL,GAAc,IAAd;;AACA,QAAIZ,IAAI,CAACe,KAAL,IAAcf,IAAI,CAACC,GAAvB,EAA4B;AAC1BkD,MAAAA,UAAU,CAACtC,KAAX,GAAmB,IAAnB;AACD,KAFD,MAEO;AACLsC,MAAAA,UAAU,CAACtC,KAAX,GAAmBb,IAAI,CAACe,KAAxB;;AACAkB,MAAAA,QAAQ,CAACjC,IAAD,CAAR;AACD;;AACDmD,IAAAA,UAAU,CAACzC,MAAX,IAAqB,CAArB;;AACAqB,IAAAA,OAAO,CAACvB,KAAK,CAACF,IAAD,CAAN,EAAcN,IAAd,CAAP;AACD;;AAED,WAASqD,WAAT,CAAqBrD,IAArB,EAA2B;AACzB,QAAIA,IAAI,CAACY,MAAL,IAAe,IAAnB,EAAyB;AACvB,UAAIZ,IAAI,CAACW,MAAT,EAAiB;AACf,YAAIwC,UAAU,GAAG3C,KAAK,CAACR,IAAI,CAACY,MAAN,CAAtB;;AACAwC,QAAAA,IAAI,CAACD,UAAD,EAAanD,IAAb,CAAJ;;AACAqD,QAAAA,WAAW,CAACF,UAAD,CAAX;AACD,OAJD,MAIO;AACLnD,QAAAA,IAAI,CAACW,MAAL,GAAc,IAAd;AACD;AACF;AACF;AAED;AACF;AACA;AACA;;;AACE,WAAS2C,SAAT,CAAmBrD,GAAnB,EAAwB;AACtBiD,IAAAA,WAAW,CAACjD,GAAD,EAAMI,SAAS,GAAGkD,QAAH,GAAc,CAAC,CAA9B,CAAX;AACAhB,IAAAA,WAAW;AACZ;;AAED,SAAO;AACLX,IAAAA,GAAG,EAAEA,GADA;AAELQ,IAAAA,WAAW,EAAEA,WAFR;AAGLc,IAAAA,WAAW,EAAEA,WAHR;AAILZ,IAAAA,QAAQ,EAAEA,QAJL;AAKLC,IAAAA,WAAW,EAAEA,WALR;AAMLe,IAAAA,SAAS,EAAEA,SANN;AAOLtC,IAAAA,QAAQ,EAAEA;AAPL,GAAP;AASD;AAAA","sourcesContent":["/**\n* Heap result object\n* @class HeapResult\n* @property {string} key Key\n* @property {number} priority Priority\n* @property {Object} item Context object\n*/\nexport function HeapResult (node) {\n  this.key = node.key;\n  this.priority = node.priority;\n  this.item = node.item;\n}\n\n/**\n * Creates Fibonacci Heap structure\n * @class FibonacciHeap\n * \n * @param {boolean} isMaximum Is maximum heap\n * @returns {FibonacciHeap} Returns new FibonacciHeap object\n */\nexport default function FibonacciHeap(isMaximum) {\n  var root = null,\n    count = 0,\n    nodes = {};\n\n  function Node(key, priority, item) {\n    this.key = key;\n    this.priority = priority;\n    this.item = item;\n    this.degree = 0;\n    this.marked = false;\n\n    this.parent = null;\n    this.child = null;\n    this.left = null;\n    this.right = null;\n  }\n\n  /**\n   * Validates internal structure consistency.\n   * \n   * @returns {boolean} Returns true if structure pass data consistency check.\n   */\n  function validate() {\n    var totalNodes = 0;\n    for (var key in nodes) {\n      if (nodes.hasOwnProperty(key)) {\n        var node = nodes[key];\n\n        totalNodes += 1;\n\n        if (node.child != null) {\n          if (!nodes.hasOwnProperty(node.child)) {\n            throw \"Child does not exists\";\n          }\n          var ref = nodes[node.child];\n          if (ref.parent != node.key) {\n            throw \"Child references wrong parent\";\n          }\n        }\n        if (node.parent != null) {\n          if (!nodes.hasOwnProperty(node.parent)) {\n            throw \"Parent does not exists\";\n          }\n\n        }\n        if (node.left != null) {\n          if (!nodes.hasOwnProperty(node.left)) {\n            throw \"Left does not exists\";\n          }\n          ref = nodes[node.left];\n          if (ref.right != node.key) {\n            throw \"Left references wrong right\";\n          }\n        }\n\n        if (node.right != null) {\n          if (!nodes.hasOwnProperty(node.right)) {\n            throw \"Right does not exists\";\n          }\n          ref = nodes[node.right];\n          if (ref.left != node.key) {\n            throw \"Right references wrong left\";\n          }\n        }\n      }\n    }\n    if (root == null && totalNodes > 0) {\n      throw \"Orphans\";\n    }\n\n    if (root != null) {\n      if (!nodes.hasOwnProperty(root)) {\n        throw \"Root node does not exists\";\n      }\n\n      node = nodes[root];\n      if (node.parent != null) {\n        throw \"Root node has parent reference\";\n      }\n\n      var children = [root];\n      var processed = {};\n      var totalChildren = 0;\n      while (children.length > 0) {\n        var newChildren = [];\n        for (var index = 0, len = children.length; index < len; index += 1) {\n          var child = nodes[children[index]];\n          while (!processed.hasOwnProperty(child.key)) {\n            processed[child.key] = true;\n            totalChildren += 1;\n            if (child.child != null) {\n              newChildren.push(child.child);\n            }\n            child = nodes[child.right];\n          }\n        }\n        children = newChildren;\n      }\n\n      if (totalNodes != totalChildren) {\n        throw \"Tree has loops or orpants\";\n      }\n    }\n  }\n\n  /**\n   * Adds a new item into the heap\n   * @param {string} key A key of the new element \n   * @param {number} priority A priority of the new element\n   * @param {object} item A context object of the new element \n   */\n  function add(key, priority, item) {\n    if (nodes.hasOwnProperty(key)) {\n      throw \"Duplicate keys are not supported!\";\n    }\n\n    var newNode = new Node(key, priority, item);\n    nodes[key] = newNode;\n\n    if (root == null) {\n      newNode.left = key;\n      newNode.right = key;\n      root = key;\n    } else {\n      var rootNode = nodes[root];\n      _insert(rootNode, newNode);\n      if (isMaximum ? rootNode.priority < newNode.priority : rootNode.priority > newNode.priority) {\n        root = key;\n      }\n    }\n    count += 1;\n  }\n\n  function _insert(node, newNode) {\n    var rightNode = nodes[node.right];\n    newNode.right = node.right;\n    newNode.left = node.key;\n    node.right = newNode.key;\n    rightNode.left = newNode.key;\n  }\n\n  function _exclude(node) {\n    var prevNode = nodes[node.left],\n      nextNode = nodes[node.right];\n\n    prevNode.right = nextNode.key;\n    nextNode.left = prevNode.key;\n    node.right = node.key;\n    node.left = node.key;\n  }\n\n  /**\n   * Gets priority of element by key\n   * @param {string} key The element key\n   * @returns {number} Returns priority of the element\n   */\n  function getPriority(key) {\n    var result = null;\n    if (nodes.hasOwnProperty(key)) {\n      result = nodes[key].priority;\n    }\n    return result;\n  }\n\n  /**\n   * Returns heap root element\n   * \n   * @returns {HeapResult} Returns root element of the heap \n   */\n  function heapRoot() {\n    var result = null;\n    if (root != null) {\n      result = new HeapResult(nodes[root]);\n    }\n    return result;\n  }\n\n  /**\n   * Returns heap root element with removal\n   * \n   * @returns {HeapResult} Returns root element of the heap \n   */\n  function extractRoot() {\n    var result = heapRoot();\n    if (result != null) {\n      var rootNode = nodes[root],\n        nextNode = nodes[rootNode.right];\n\n      if (rootNode.child != null) {\n        var childNode = nodes[rootNode.child],\n          childNodeLeft = nodes[childNode.left];\n\n        rootNode.right = childNode.key;\n        nextNode.left = childNodeLeft.key;\n        childNode.left = rootNode.key;\n        childNodeLeft.right = nextNode.key;\n\n        _exclude(rootNode);\n        delete nodes[rootNode.key];\n\n        root = null;\n        _consolidate(childNode.key);\n      } else {\n        _exclude(rootNode);\n        delete nodes[rootNode.key];\n\n        root = null;\n        if (nextNode.key != rootNode.key) {\n          _consolidate(nextNode.key);\n        }\n      }\n      count -= 1;\n    }\n    return result;\n  }\n\n  function _consolidate(startKey) {\n    var pairs = [], pairedNode,\n      processed = {},\n      key = startKey;\n    while (!processed.hasOwnProperty(key)) {\n      var node = nodes[key],\n        nextKey = node.right;\n\n      processed[key] = true;\n      node.parent = null;\n\n      while ((pairedNode = pairs[node.degree]) != null) {\n        if (isMaximum ? node.priority > pairedNode.priority : node.priority < pairedNode.priority) {\n          _union(node, pairedNode);\n        } else {\n          _union(pairedNode, node);\n          node = pairedNode;\n        }\n        pairs[node.degree - 1] = null;\n      }\n      pairs[node.degree] = node;\n\n      if (root == null || nodes[root] == null || (isMaximum ? nodes[root].priority <= node.priority : nodes[root].priority >= node.priority)) {\n        root = node.key;\n      }\n\n      key = nextKey;\n    }\n  }\n\n  function _union(node1, node2) {\n    node1.degree += 1;\n    _exclude(node2);\n    var child = nodes[node1.child];\n    if (child != null) {\n      _insert(child, node2);\n      if (isMaximum ? child.priority < node2.priority : child.priority > node2.priority) {\n        node1.child = node2.key;\n      }\n    } else {\n      node1.child = node2.key;\n    }\n    node2.parent = node1.key;\n  }\n\n  /**\n   * Sets priority of an element by key\n   * @param {string} key The key of the element \n   * @param {number} priority Priority\n   */\n  function setPriority(key, priority) {\n    var node = nodes[key];\n    if (isMaximum ? node.priority > priority : node.priority < priority) {\n      throw \"Priority increase is not supported\";\n    }\n    node.priority = priority;\n\n    if (node.parent != null) {\n      var parentNode = nodes[node.parent];\n      if (isMaximum ? parentNode.priority < node.priority : parentNode.priority > node.priority) {\n        _cut(parentNode, node);\n        _cascadeCut(parentNode);\n      }\n    }\n    if (isMaximum ? nodes[root].priority < node.priority : nodes[root].priority > node.priority) {\n      root = node.key;\n    }\n  }\n\n  function _cut(parentNode, node) {\n    node.marked = false;\n    node.parent = null;\n    if (node.right == node.key) {\n      parentNode.child = null;\n    } else {\n      parentNode.child = node.right;\n      _exclude(node);\n    }\n    parentNode.degree -= 1;\n    _insert(nodes[root], node);\n  }\n\n  function _cascadeCut(node) {\n    if (node.parent != null) {\n      if (node.marked) {\n        var parentNode = nodes[node.parent];\n        _cut(parentNode, node);\n        _cascadeCut(parentNode);\n      } else {\n        node.marked = true;\n      }\n    }\n  }\n\n  /**\n   * Deletes heap element by key\n   * @param {string} key The Key \n   */\n  function deleteKey(key) {\n    setPriority(key, isMaximum ? Infinity : -1);\n    extractRoot();\n  }\n\n  return {\n    add: add,\n    getPriority: getPriority,\n    setPriority: setPriority,\n    heapRoot: heapRoot,\n    extractRoot: extractRoot,\n    deleteKey: deleteKey,\n    validate: validate\n  };\n};"]},"metadata":{},"sourceType":"module"}