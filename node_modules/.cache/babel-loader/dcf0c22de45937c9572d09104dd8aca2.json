{"ast":null,"code":"import Thickness from '../graphics/structs/Thickness';\nimport Size from '../graphics/structs/Size';\nimport { AnnotationType, ZOrderType, ShapeType, PlacementType, LineType } from '../enums';\n/**\n * @class ShapeAnnotationConfig\n * @classdesc  Shape annotation configuration object. Shape annotation is a possibility to draw some geometrical\n * shapes over nodes of the diagram. \n *\n * @param {object} arg0 Object properties.\n */\n\nexport default function ShapeAnnotationConfig(arg0) {\n  var property;\n  /**\n   * Annotation type. All types of annotations objects are added to `annotations` collection property of the control.\n   * This property is needed to distinguish them when they are defined as JSON objects.\n   * \n   * @type {AnnotationType}\n   */\n\n  this.annotationType = AnnotationType.Shape;\n  /**\n   * Sets annotation Z order placement relative to the diagram items. Diagram visual elements are drawn in layers on top of each other.\n   * If you place annotations over diagram nodes then you block mouse events of UI elements in their templates.\n   * Browsers don't support mouse events transparency consistently yet. So in order to avoid mouse events blocking of UI elements in item\n   * templates you have to place annotation items under them or explicitly define maximum zindex for controls and make them rendered on top\n   * of other visual elements. The control takes this into account and renders buttons panel on top of everything,\n   * so they are never blocked by annotations drawn in front of diagram nodes.\n   * \n   * @type {ZOrderType}\n   */\n\n  this.zOrderType = ZOrderType.Auto;\n  /**\n   * Collection of nodes ids this shape annotation is drawn for.\n   * \n   * @type {string[]}\n   */\n\n  this.items = [];\n  /**\n   * Shape\n   * \n   * @type {ShapeType}\n   */\n\n  this.shapeType = ShapeType.Rectangle;\n  /**\n   * Sets shape offset around annotated items.\n   * \n   * @type {Thickness}\n   */\n\n  this.offset = new Thickness(0, 0, 0, 0);\n  /**\n   * Border line width\n   * \n   * @type {number}\n   */\n\n  this.lineWidth = 2;\n  /**\n   * Corner radius. Body corner radius in percents or pixels. For applicable shapes only.\n   * \n   * @type {string|number}\n   */\n\n  this.cornerRadius = \"10%\";\n  /**\n   * Background color opacity.\n   * \n   * @type {number}\n   */\n\n  this.opacity = 1;\n  /**\n   * Shape border line color\n   * \n   * @type {string}\n   */\n\n  this.borderColor = null;\n  /**\n   * Shape fill color\n   * \n   * @type {string}\n   */\n\n  this.fillColor = null;\n  /**\n   * Border line type\n   * \n   * @type {LineType}\n   */\n\n  this.lineType = LineType.Solid;\n  /**\n   * If true then annotated nodes are shown full size regardless of controls auto fit mode and available screen space.\n   * @type {boolean}\n   */\n\n  this.selectItems = false;\n  /**\n   * Label. Label styled with css class name \"bp-connector-label\".\n   * @type {string}\n   */\n\n  this.label = null;\n  /**\n   * Label size\n   * @type {Size}\n   */\n\n  this.labelSize = new Size(60, 30);\n  /**\n   * Label placement relative to the annotation.\n   * \n   * @type {PlacementType}\n   */\n\n  this.labelPlacement = PlacementType.Auto;\n  /**\n   * Label offset from shape in pixels.\n   * \n   * @type {number}\n   */\n\n  this.labelOffset = 4;\n\n  switch (arguments.length) {\n    case 1:\n      if (arg0 !== null) {\n        if (arg0 instanceof Array) {\n          this.items = arg0;\n        } else if (typeof arg0 == \"object\") {\n          for (property in arg0) {\n            if (arg0.hasOwnProperty(property)) {\n              this[property] = arg0[property];\n            }\n          }\n        }\n      }\n\n      break;\n  }\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/configs/ShapeAnnotationConfig.js"],"names":["Thickness","Size","AnnotationType","ZOrderType","ShapeType","PlacementType","LineType","ShapeAnnotationConfig","arg0","property","annotationType","Shape","zOrderType","Auto","items","shapeType","Rectangle","offset","lineWidth","cornerRadius","opacity","borderColor","fillColor","lineType","Solid","selectItems","label","labelSize","labelPlacement","labelOffset","arguments","length","Array","hasOwnProperty"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,+BAAtB;AACA,OAAOC,IAAP,MAAiB,0BAAjB;AACA,SAAQC,cAAR,EAAwBC,UAAxB,EAAoCC,SAApC,EAA+CC,aAA/C,EAA8DC,QAA9D,QAA8E,UAA9E;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,qBAAT,CAA+BC,IAA/B,EAAqC;AAClD,MAAIC,QAAJ;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,cAAL,GAAsBR,cAAc,CAACS,KAArC;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkBT,UAAU,CAACU,IAA7B;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,KAAL,GAAa,EAAb;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,SAAL,GAAiBX,SAAS,CAACY,SAA3B;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,MAAL,GAAc,IAAIjB,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,CAAd;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKkB,SAAL,GAAiB,CAAjB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,YAAL,GAAoB,KAApB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,OAAL,GAAe,CAAf;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,WAAL,GAAmB,IAAnB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,SAAL,GAAiB,IAAjB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,QAAL,GAAgBjB,QAAQ,CAACkB,KAAzB;AAEA;AACF;AACA;AACA;;AACE,OAAKC,WAAL,GAAmB,KAAnB;AAEA;AACF;AACA;AACA;;AACE,OAAKC,KAAL,GAAa,IAAb;AAEA;AACF;AACA;AACA;;AACE,OAAKC,SAAL,GAAiB,IAAI1B,IAAJ,CAAS,EAAT,EAAa,EAAb,CAAjB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAK2B,cAAL,GAAsBvB,aAAa,CAACQ,IAApC;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKgB,WAAL,GAAmB,CAAnB;;AAEA,UAAQC,SAAS,CAACC,MAAlB;AACE,SAAK,CAAL;AACE,UAAIvB,IAAI,KAAK,IAAb,EAAmB;AACjB,YAAIA,IAAI,YAAYwB,KAApB,EAA2B;AACzB,eAAKlB,KAAL,GAAaN,IAAb;AACD,SAFD,MAEO,IAAI,OAAOA,IAAP,IAAe,QAAnB,EAA6B;AAClC,eAAKC,QAAL,IAAiBD,IAAjB,EAAuB;AACrB,gBAAIA,IAAI,CAACyB,cAAL,CAAoBxB,QAApB,CAAJ,EAAmC;AACjC,mBAAKA,QAAL,IAAiBD,IAAI,CAACC,QAAD,CAArB;AACD;AACF;AACF;AACF;;AACD;AAbJ;AAeD;AAAA","sourcesContent":["import Thickness from '../graphics/structs/Thickness';\nimport Size from '../graphics/structs/Size';\nimport {AnnotationType, ZOrderType, ShapeType, PlacementType, LineType } from '../enums';\n\n/**\n * @class ShapeAnnotationConfig\n * @classdesc  Shape annotation configuration object. Shape annotation is a possibility to draw some geometrical\n * shapes over nodes of the diagram. \n *\n * @param {object} arg0 Object properties.\n */\nexport default function ShapeAnnotationConfig(arg0) {\n  var property;\n\n  /**\n   * Annotation type. All types of annotations objects are added to `annotations` collection property of the control.\n   * This property is needed to distinguish them when they are defined as JSON objects.\n   * \n   * @type {AnnotationType}\n   */\n  this.annotationType = AnnotationType.Shape;\n\n  /**\n   * Sets annotation Z order placement relative to the diagram items. Diagram visual elements are drawn in layers on top of each other.\n   * If you place annotations over diagram nodes then you block mouse events of UI elements in their templates.\n   * Browsers don't support mouse events transparency consistently yet. So in order to avoid mouse events blocking of UI elements in item\n   * templates you have to place annotation items under them or explicitly define maximum zindex for controls and make them rendered on top\n   * of other visual elements. The control takes this into account and renders buttons panel on top of everything,\n   * so they are never blocked by annotations drawn in front of diagram nodes.\n   * \n   * @type {ZOrderType}\n   */\n  this.zOrderType = ZOrderType.Auto;\n\n  /**\n   * Collection of nodes ids this shape annotation is drawn for.\n   * \n   * @type {string[]}\n   */\n  this.items = [];\n\n  /**\n   * Shape\n   * \n   * @type {ShapeType}\n   */\n  this.shapeType = ShapeType.Rectangle;\n\n  /**\n   * Sets shape offset around annotated items.\n   * \n   * @type {Thickness}\n   */\n  this.offset = new Thickness(0, 0, 0, 0);\n\n  /**\n   * Border line width\n   * \n   * @type {number}\n   */\n  this.lineWidth = 2;\n\n  /**\n   * Corner radius. Body corner radius in percents or pixels. For applicable shapes only.\n   * \n   * @type {string|number}\n   */\n  this.cornerRadius = \"10%\";\n\n  /**\n   * Background color opacity.\n   * \n   * @type {number}\n   */\n  this.opacity = 1;\n\n  /**\n   * Shape border line color\n   * \n   * @type {string}\n   */\n  this.borderColor = null;\n\n  /**\n   * Shape fill color\n   * \n   * @type {string}\n   */\n  this.fillColor = null;\n\n  /**\n   * Border line type\n   * \n   * @type {LineType}\n   */\n  this.lineType = LineType.Solid;\n\n  /**\n   * If true then annotated nodes are shown full size regardless of controls auto fit mode and available screen space.\n   * @type {boolean}\n   */\n  this.selectItems = false;\n\n  /**\n   * Label. Label styled with css class name \"bp-connector-label\".\n   * @type {string}\n   */\n  this.label = null;\n\n  /**\n   * Label size\n   * @type {Size}\n   */\n  this.labelSize = new Size(60, 30);\n\n  /**\n   * Label placement relative to the annotation.\n   * \n   * @type {PlacementType}\n   */\n  this.labelPlacement = PlacementType.Auto;\n\n  /**\n   * Label offset from shape in pixels.\n   * \n   * @type {number}\n   */\n  this.labelOffset = 4;\n\n  switch (arguments.length) {\n    case 1:\n      if (arg0 !== null) {\n        if (arg0 instanceof Array) {\n          this.items = arg0;\n        } else if (typeof arg0 == \"object\") {\n          for (property in arg0) {\n            if (arg0.hasOwnProperty(property)) {\n              this[property] = arg0[property];\n            }\n          }\n        }\n      }\n      break;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}