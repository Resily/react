{"ast":null,"code":"import BaseShape from './BaseShape';\nimport Point from '../structs/Point';\nimport Rect from '../structs/Rect';\nimport MoveSegment from '../structs/MoveSegment';\nimport QuadraticArcSegment from '../structs/QuadraticArcSegment';\nimport { PlacementType, ConnectorShapeType, ConnectorLabelPlacementType } from '../../enums';\nexport default function ConnectorOffbeat() {}\n;\nConnectorOffbeat.prototype = new BaseShape();\n\nConnectorOffbeat.prototype.draw = function (buffer, linePaletteItem, fromRect, toRect, linesOffset, bundleOffset, labelSize, panelSize, connectorShapeType, labelOffset, labelPlacementType, hasLabel, connectorAnnotationOffsetResolver, onLabelPlacement, labelConfig) {\n  var minimalGap,\n      connectorRect,\n      fromPoint,\n      toPoint,\n      snapPoint,\n      index,\n      len,\n      offsets,\n      tempOffset,\n      invertX,\n      invertY,\n      fromLabelPlacement = PlacementType.Auto,\n      toLabelPlacement = PlacementType.Auto,\n      labelPlacement = null,\n      polyline,\n      bothWay;\n  polyline = buffer.getPolyline(linePaletteItem);\n  offsets = [];\n\n  switch (connectorShapeType) {\n    case ConnectorShapeType.TwoWay:\n      offsets = [-linesOffset / 2, linesOffset / 2];\n      bothWay = false;\n      break;\n\n    case ConnectorShapeType.OneWay:\n      offsets = [0];\n      bothWay = false;\n      break;\n\n    case ConnectorShapeType.BothWay:\n      offsets = [0];\n      bothWay = true;\n      break;\n  }\n\n  minimalGap = Math.max(hasLabel ? labelSize.width : 0, linesOffset * 5);\n\n  if (fromRect.right() + minimalGap < toRect.left() || fromRect.left() > toRect.right() + minimalGap) {\n    if (fromRect.left() > toRect.right()) {\n      fromPoint = new Point(fromRect.left(), fromRect.verticalCenter());\n      toPoint = new Point(toRect.right(), toRect.verticalCenter());\n    } else {\n      fromPoint = new Point(fromRect.right(), fromRect.verticalCenter());\n      toPoint = new Point(toRect.left(), toRect.verticalCenter());\n    }\n\n    if (hasLabel) {\n      if (fromRect.left() > toRect.right()) {\n        fromLabelPlacement = PlacementType.Left;\n        toLabelPlacement = PlacementType.Right;\n      } else {\n        fromLabelPlacement = PlacementType.Right;\n        toLabelPlacement = PlacementType.Left;\n      }\n    }\n\n    connectorRect = new Rect(fromPoint, toPoint);\n    invertY = fromPoint.y <= toPoint.y;\n    invertX = fromPoint.x < toPoint.x;\n\n    if (connectorRect.height < connectorRect.width) {\n      /* horizontal single bended connector between boxes from right side to left side */\n      if (connectorRect.height < linesOffset * 2) {\n        connectorRect.offset(0, invertY ? linesOffset * 2 : 0, 0, invertY ? 0 : linesOffset * 2);\n      }\n\n      for (index = 0, len = offsets.length; index < len; index += 1) {\n        tempOffset = offsets[index];\n        buffer.addInverted(function (invertedBuffer) {\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\n          polyline.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter(), (invertY ? connectorRect.top() : connectorRect.bottom()) + tempOffset, toPoint.x, toPoint.y + tempOffset));\n\n          if (bothWay) {\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n            }); //ignore jslint\n          }\n        }, index || connectorShapeType == ConnectorShapeType.OneWay); //ignore jslint\n\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n        }); //ignore jslint\n      }\n\n      if (hasLabel) {\n        if (labelSize.width < connectorRect.width / 5 * 2) {\n          snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, connectorRect.horizontalCenter(), invertY ? connectorRect.top() : connectorRect.bottom(), toPoint.x, toPoint.y, 0.5);\n        } else {\n          snapPoint = new Point(fromPoint.x, invertY ? connectorRect.top() : connectorRect.bottom());\n        }\n\n        labelPlacement = new Rect(snapPoint.x + (invertX ? linesOffset : -labelSize.width - linesOffset), invertY ? snapPoint.y - labelSize.height - linesOffset : snapPoint.y + linesOffset, labelSize.width, labelSize.height);\n      }\n    } else {\n      /* horizontal double bended connector between boxes from right side to left side */\n      for (index = 0, len = offsets.length; index < len; index += 1) {\n        tempOffset = offsets[index];\n        buffer.addInverted(function (invertedBuffer) {\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\n          polyline.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1), (invertY ? connectorRect.top() : connectorRect.bottom()) + tempOffset, connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1), connectorRect.verticalCenter() + tempOffset));\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1), (invertY ? connectorRect.bottom() : connectorRect.top()) + tempOffset, toPoint.x, toPoint.y + tempOffset));\n\n          if (bothWay) {\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n            }); //ignore jslint\n          }\n        }, index || connectorShapeType == ConnectorShapeType.OneWay); //ignore jslint\n\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n        }); //ignore jslint\n      }\n\n      if (hasLabel) {\n        labelPlacement = new Rect(connectorRect.horizontalCenter() + (invertY != invertX ? linesOffset : -(linesOffset + labelSize.width)), connectorRect.verticalCenter() - labelSize.height / 2, labelSize.width, labelSize.height);\n      }\n    }\n  } else {\n    if (fromRect.verticalCenter() < toRect.top() || fromRect.verticalCenter() > toRect.bottom()) {\n      /* vertical single bended connector between boxes from right side to right side */\n      invertX = fromRect.x < panelSize.width / 2;\n      fromPoint = new Point(invertX ? fromRect.right() : fromRect.left(), fromRect.verticalCenter());\n      toPoint = new Point(invertX ? toRect.right() : toRect.left(), toRect.verticalCenter());\n      connectorRect = new Rect(fromPoint, toPoint);\n      connectorRect.offset(linesOffset * 10, 0, linesOffset * 10, 0);\n      invertY = fromPoint.y <= toPoint.y;\n\n      for (index = 0, len = offsets.length; index < len; index += 1) {\n        tempOffset = offsets[index];\n        buffer.addInverted(function (invertedBuffer) {\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\n          polyline.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));\n          polyline.addSegment(new QuadraticArcSegment(invertX ? connectorRect.right() + tempOffset * (invertY ? -1 : 1) : connectorRect.left() - tempOffset * (invertY ? -1 : 1), connectorRect.verticalCenter(), invertX ? toRect.right() : toRect.left(), toRect.verticalCenter() - tempOffset));\n\n          if (bothWay) {\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n            }); //ignore jslint\n          }\n        }, index || connectorShapeType == ConnectorShapeType.OneWay); //ignore jslint\n\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n        }); //ignore jslint\n      }\n\n      if (hasLabel) {\n        fromLabelPlacement = invertX ? PlacementType.Right : PlacementType.Left;\n        toLabelPlacement = fromLabelPlacement;\n        snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, invertX ? connectorRect.right() : connectorRect.left(), connectorRect.verticalCenter(), toPoint.x, toPoint.y, 0.5);\n        labelPlacement = new Rect(snapPoint.x + (invertX ? linesOffset / 2 : -linesOffset / 2 - labelSize.width), snapPoint.y - labelSize.height / 2, labelSize.width, labelSize.height);\n      }\n    } else {\n      fromPoint = new Point(fromRect.horizontalCenter(), fromRect.top());\n      toPoint = new Point(toRect.horizontalCenter(), toRect.top());\n      connectorRect = new Rect(fromPoint, toPoint);\n      connectorRect.offset(0, linesOffset * 7, 0, 0);\n      invertX = fromPoint.x < toPoint.x;\n\n      for (index = 0, len = offsets.length; index < len; index += 1) {\n        tempOffset = offsets[index];\n        buffer.addInverted(function (invertedBuffer) {\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\n          polyline.addSegment(new MoveSegment(fromPoint.x + tempOffset, fromPoint.y));\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter(), connectorRect.top() - tempOffset * (invertX ? -1 : 1), toRect.horizontalCenter() - tempOffset, toRect.top()));\n\n          if (bothWay) {\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n            }); //ignore jslint\n          }\n        }, index || connectorShapeType == ConnectorShapeType.OneWay); //ignore jslint\n\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n        }); //ignore jslint\n      }\n\n      if (hasLabel) {\n        fromLabelPlacement = PlacementType.Top;\n        toLabelPlacement = PlacementType.Top;\n        snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, connectorRect.horizontalCenter(), connectorRect.top(), toPoint.x, toPoint.y, 0.5);\n        labelPlacement = new Rect(snapPoint.x - labelSize.width / 2, snapPoint.y - (labelOffset + labelSize.height), labelSize.width, labelSize.height);\n      }\n    }\n  }\n\n  if (hasLabel) {\n    /* end points labels placement */\n    switch (labelPlacementType) {\n      case ConnectorLabelPlacementType.From:\n        labelPlacement = this._getLabelPosition(fromRect.x, fromRect.y, fromRect.width, fromRect.height, labelPlacement.width, labelPlacement.height, labelOffset, fromLabelPlacement);\n        break;\n\n      case ConnectorLabelPlacementType.To:\n        labelPlacement = this._getLabelPosition(toRect.x, toRect.y, toRect.width, toRect.height, labelPlacement.width, labelPlacement.height, labelOffset, toLabelPlacement);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  if (onLabelPlacement != null) {\n    onLabelPlacement(labelPlacement, labelConfig);\n  }\n};","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/graphics/shapes/ConnectorOffbeat.js"],"names":["BaseShape","Point","Rect","MoveSegment","QuadraticArcSegment","PlacementType","ConnectorShapeType","ConnectorLabelPlacementType","ConnectorOffbeat","prototype","draw","buffer","linePaletteItem","fromRect","toRect","linesOffset","bundleOffset","labelSize","panelSize","connectorShapeType","labelOffset","labelPlacementType","hasLabel","connectorAnnotationOffsetResolver","onLabelPlacement","labelConfig","minimalGap","connectorRect","fromPoint","toPoint","snapPoint","index","len","offsets","tempOffset","invertX","invertY","fromLabelPlacement","Auto","toLabelPlacement","labelPlacement","polyline","bothWay","getPolyline","TwoWay","OneWay","BothWay","Math","max","width","right","left","verticalCenter","Left","Right","y","x","height","offset","length","addInverted","invertedBuffer","addSegment","horizontalCenter","top","bottom","addArrow","lineWidth","mergeTo","paletteItem","offsetPoint","Top","From","_getLabelPosition","To"],"mappings":"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","sourcesContent":["import BaseShape from './BaseShape';\nimport Point from '../structs/Point';\nimport Rect from '../structs/Rect';\nimport MoveSegment from '../structs/MoveSegment';\nimport QuadraticArcSegment from '../structs/QuadraticArcSegment';\nimport { PlacementType, ConnectorShapeType, ConnectorLabelPlacementType } from '../../enums';\n\nexport default function ConnectorOffbeat() {\n\n};\n\nConnectorOffbeat.prototype = new BaseShape();\n\nConnectorOffbeat.prototype.draw = function (buffer, linePaletteItem, fromRect, toRect, linesOffset, bundleOffset, labelSize, panelSize, connectorShapeType, labelOffset, labelPlacementType, hasLabel,\n  connectorAnnotationOffsetResolver, onLabelPlacement, labelConfig) {\n  var minimalGap,\n    connectorRect,\n    fromPoint, toPoint,\n    snapPoint,\n    index, len,\n    offsets, tempOffset,\n    invertX, invertY,\n    fromLabelPlacement = PlacementType.Auto,\n    toLabelPlacement = PlacementType.Auto,\n    labelPlacement = null,\n    polyline,\n    bothWay;\n\n  polyline = buffer.getPolyline(linePaletteItem);\n\n  offsets = [];\n  switch (connectorShapeType) {\n    case ConnectorShapeType.TwoWay:\n      offsets = [-linesOffset / 2, linesOffset / 2];\n      bothWay = false;\n      break;\n    case ConnectorShapeType.OneWay:\n      offsets = [0];\n      bothWay = false;\n      break;\n    case ConnectorShapeType.BothWay:\n      offsets = [0];\n      bothWay = true;\n      break;\n  }\n\n  minimalGap = Math.max(hasLabel ? labelSize.width : 0, linesOffset * 5);\n  if (fromRect.right() + minimalGap < toRect.left() || fromRect.left() > toRect.right() + minimalGap) {\n    if (fromRect.left() > toRect.right()) {\n      fromPoint = new Point(fromRect.left(), fromRect.verticalCenter());\n      toPoint = new Point(toRect.right(), toRect.verticalCenter());\n    } else {\n      fromPoint = new Point(fromRect.right(), fromRect.verticalCenter());\n      toPoint = new Point(toRect.left(), toRect.verticalCenter());\n    }\n    if (hasLabel) {\n      if (fromRect.left() > toRect.right()) {\n        fromLabelPlacement = PlacementType.Left;\n        toLabelPlacement = PlacementType.Right;\n      } else {\n        fromLabelPlacement = PlacementType.Right;\n        toLabelPlacement = PlacementType.Left;\n      }\n    }\n    connectorRect = new Rect(fromPoint, toPoint);\n    invertY = (fromPoint.y <= toPoint.y);\n    invertX = (fromPoint.x < toPoint.x);\n    if (connectorRect.height < connectorRect.width) {\n      /* horizontal single bended connector between boxes from right side to left side */\n      if (connectorRect.height < linesOffset * 2) {\n        connectorRect.offset(0, invertY ? linesOffset * 2 : 0, 0, invertY ? 0 : linesOffset * 2);\n      }\n\n      for (index = 0, len = offsets.length; index < len; index += 1) {\n        tempOffset = offsets[index];\n        buffer.addInverted(function (invertedBuffer) {\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\n          polyline.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter(), (invertY ? connectorRect.top() : connectorRect.bottom()) + tempOffset,\n            toPoint.x, toPoint.y + tempOffset));\n\n          if (bothWay) {\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n            });//ignore jslint\n          }\n        }, index || (connectorShapeType == ConnectorShapeType.OneWay));//ignore jslint\n\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n        }); //ignore jslint\n      }\n\n      if (hasLabel) {\n        if (labelSize.width < connectorRect.width / 5 * 2) {\n          snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, connectorRect.horizontalCenter(), (invertY ? connectorRect.top() : connectorRect.bottom()), toPoint.x, toPoint.y, 0.5);\n        } else {\n          snapPoint = new Point(fromPoint.x, invertY ? connectorRect.top() : connectorRect.bottom());\n        }\n        labelPlacement = new Rect(snapPoint.x + (invertX ? linesOffset : -labelSize.width - linesOffset), (invertY ? snapPoint.y - labelSize.height - linesOffset : snapPoint.y + linesOffset), labelSize.width, labelSize.height);\n      }\n    } else {\n      /* horizontal double bended connector between boxes from right side to left side */\n      for (index = 0, len = offsets.length; index < len; index += 1) {\n        tempOffset = offsets[index];\n        buffer.addInverted(function (invertedBuffer) {\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\n          polyline.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1), (invertY ? connectorRect.top() : connectorRect.bottom()) + tempOffset,\n            connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1), connectorRect.verticalCenter() + tempOffset));\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter() + tempOffset * (invertY != invertX ? 1 : -1), (invertY ? connectorRect.bottom() : connectorRect.top()) + tempOffset,\n            toPoint.x, toPoint.y + tempOffset));\n\n          if (bothWay) {\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n            });//ignore jslint\n          }\n        }, index || (connectorShapeType == ConnectorShapeType.OneWay));//ignore jslint\n\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n        }); //ignore jslint\n      }\n\n      if (hasLabel) {\n        labelPlacement = new Rect(connectorRect.horizontalCenter() + (invertY != invertX ? linesOffset : -(linesOffset + labelSize.width)),\n          connectorRect.verticalCenter() - labelSize.height / 2, labelSize.width, labelSize.height);\n      }\n    }\n  } else {\n    if (fromRect.verticalCenter() < toRect.top() || fromRect.verticalCenter() > toRect.bottom()) {\n      /* vertical single bended connector between boxes from right side to right side */\n      invertX = fromRect.x < panelSize.width / 2;\n      fromPoint = new Point(invertX ? fromRect.right() : fromRect.left(), fromRect.verticalCenter());\n      toPoint = new Point(invertX ? toRect.right() : toRect.left(), toRect.verticalCenter());\n      connectorRect = new Rect(fromPoint, toPoint);\n      connectorRect.offset(linesOffset * 10, 0, linesOffset * 10, 0);\n      invertY = (fromPoint.y <= toPoint.y);\n      for (index = 0, len = offsets.length; index < len; index += 1) {\n        tempOffset = offsets[index];\n        buffer.addInverted(function (invertedBuffer) {\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\n          polyline.addSegment(new MoveSegment(fromPoint.x, fromPoint.y + tempOffset));\n          polyline.addSegment(new QuadraticArcSegment(invertX ? connectorRect.right() + tempOffset * (invertY ? -1 : 1) : connectorRect.left() - tempOffset * (invertY ? -1 : 1), connectorRect.verticalCenter(),\n            invertX ? toRect.right() : toRect.left(), toRect.verticalCenter() - tempOffset));\n\n          if (bothWay) {\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n            });//ignore jslint\n          }\n        }, index || (connectorShapeType == ConnectorShapeType.OneWay));//ignore jslint\n\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n        });//ignore jslint\n      }\n\n      if (hasLabel) {\n        fromLabelPlacement = invertX ? PlacementType.Right : PlacementType.Left;\n        toLabelPlacement = fromLabelPlacement;\n\n        snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, (invertX ? connectorRect.right() : connectorRect.left()), connectorRect.verticalCenter(), toPoint.x, toPoint.y, 0.5);\n        labelPlacement = new Rect(snapPoint.x + (invertX ? linesOffset / 2 : -linesOffset / 2 - labelSize.width), snapPoint.y - labelSize.height / 2, labelSize.width, labelSize.height);\n      }\n    } else {\n      fromPoint = new Point(fromRect.horizontalCenter(), fromRect.top());\n      toPoint = new Point(toRect.horizontalCenter(), toRect.top());\n      connectorRect = new Rect(fromPoint, toPoint);\n      connectorRect.offset(0, linesOffset * 7, 0, 0);\n      invertX = (fromPoint.x < toPoint.x);\n      for (index = 0, len = offsets.length; index < len; index += 1) {\n        tempOffset = offsets[index];\n        buffer.addInverted(function (invertedBuffer) {\n          var polyline = invertedBuffer.getPolyline(linePaletteItem);\n          polyline.addSegment(new MoveSegment(fromPoint.x + tempOffset, fromPoint.y));\n          polyline.addSegment(new QuadraticArcSegment(connectorRect.horizontalCenter(), connectorRect.top() - tempOffset * (invertX ? -1 : 1),\n            toRect.horizontalCenter() - tempOffset, toRect.top()));\n\n          if (bothWay) {\n            polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n              polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n            });//ignore jslint\n          }\n        }, index || (connectorShapeType == ConnectorShapeType.OneWay));//ignore jslint\n\n        polyline.addArrow(linePaletteItem.lineWidth, function (polyline) {\n          polyline.mergeTo(buffer.getPolyline(polyline.paletteItem));\n        }); //ignore jslint\n      }\n\n      if (hasLabel) {\n        fromLabelPlacement = PlacementType.Top;\n        toLabelPlacement = PlacementType.Top;\n\n        snapPoint = QuadraticArcSegment.prototype.offsetPoint(fromPoint.x, fromPoint.y, connectorRect.horizontalCenter(), connectorRect.top(), toPoint.x, toPoint.y, 0.5);\n        labelPlacement = new Rect(snapPoint.x - labelSize.width / 2, snapPoint.y - (labelOffset + labelSize.height), labelSize.width, labelSize.height);\n      }\n    }\n  }\n\n  if (hasLabel) {\n    /* end points labels placement */\n    switch (labelPlacementType) {\n      case ConnectorLabelPlacementType.From:\n        labelPlacement = this._getLabelPosition(fromRect.x, fromRect.y, fromRect.width, fromRect.height, labelPlacement.width, labelPlacement.height, labelOffset, fromLabelPlacement);\n        break;\n      case ConnectorLabelPlacementType.To:\n        labelPlacement = this._getLabelPosition(toRect.x, toRect.y, toRect.width, toRect.height, labelPlacement.width, labelPlacement.height, labelOffset, toLabelPlacement);\n        break;\n      default:\n        break;\n    }\n  }\n\n  if (onLabelPlacement != null) {\n    onLabelPlacement(labelPlacement, labelConfig);\n  }\n};\n"]},"metadata":{},"sourceType":"module"}