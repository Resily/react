{"ast":null,"code":"import SortedList from './SortedList';\n/**\n * Callback function to iterate over pairs of crossing rectangles\n * \n * @callback onCrossingRectanglesItemCallback\n * @param {Rect} rect1 First rectangle\n * @param {Rect} rect2 Second rectangle\n */\n\n/**\n * Finds pairs of crossing rectangles.\n * \n * @param {Object} thisArg The callback function invocation context\n * @param {Rect[]} rectangles Collection of rectangles.\n * @param {onCrossingRectanglesItemCallback} onCrossing Callback function to pass pair of crossing rectangles.\n */\n\nexport default function getCrossingRectangles(thisArg, rectangles, onCrossing) {\n  function Action(isStart, index, x, rect) {\n    this.isStart = isStart;\n    this.index = index;\n    this.x = x;\n    this.rect = rect;\n  }\n\n  function Level() {\n    this.count = 0;\n    this.rectangles = {};\n\n    this.add = function (index) {\n      this.count += 1;\n      this.rectangles[index] = true;\n    };\n\n    this.remove = function (index) {\n      this.count -= 1;\n      delete this.rectangles[index];\n      return this.count == 0;\n    };\n  }\n\n  function _findCrossedRectangles(buffer, from, to, rectIndex, rect) {\n    buffer.loopForward(this, from, function (value, level) {\n      if (value > to) {\n        return true;\n      }\n\n      for (var index in level.rectangles) {\n        if (level.rectangles.hasOwnProperty(index)) {\n          var key = rectIndex > index ? rectIndex + \"-\" + index : index + \"-\" + rectIndex;\n\n          if (!processed.hasOwnProperty(key)) {\n            processed[key] = true;\n            onCrossing.call(thisArg, rect, rectangles[index]);\n          }\n        }\n      }\n    });\n  }\n\n  if (onCrossing != null) {\n    // Create action items out of rectangles\n    var actions = [];\n\n    for (var index = 0; index < rectangles.length; index += 1) {\n      var rect = rectangles[index];\n      actions.push(new Action(1, index, rect.x, rect));\n      actions.push(new Action(0, index, rect.right(), rect));\n    }\n\n    actions.sort(function (a, b) {\n      if (a.x == b.x) {\n        return b.isStart - a.isStart;\n      }\n\n      return a.x - b.x;\n    });\n    /* find intersections */\n\n    var buffer = SortedList();\n    var levels = {};\n    var processed = {};\n\n    for (index = 0; index < actions.length; index += 1) {\n      var action = actions[index];\n      var actionLevels = [action.rect.y, action.rect.bottom()];\n\n      if (action.isStart == 1) {\n        // Search for intersections of the left side of the rectangle with existing horizontal segments\n        _findCrossedRectangles(buffer, actionLevels[0], actionLevels[1], action.index, action.rect); // add rectangle's horizontal segments\n\n\n        for (var index2 = 0, len2 = actionLevels.length; index2 < len2; index2 += 1) {\n          var value = actionLevels[index2];\n          var level = levels[value];\n\n          if (level == null) {\n            level = new Level();\n            levels[value] = level;\n            buffer.add(value, level);\n          }\n\n          level.add(action.index);\n        }\n      } else {\n        // remove rectangle's horizontal segments\n        for (index2 = 0, len2 = actionLevels.length; index2 < len2; index2 += 1) {\n          value = actionLevels[index2];\n          level = levels[value];\n\n          if (level.remove(action.index)) {\n            delete levels[value];\n            buffer.remove(value);\n          }\n        } // Search for intersections of the right side of rectangle with existing horizontal segments\n\n\n        _findCrossedRectangles(buffer, actionLevels[0], actionLevels[1], action.index, action.rect);\n      }\n    }\n  }\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/getCrossingRectangles.js"],"names":["SortedList","getCrossingRectangles","thisArg","rectangles","onCrossing","Action","isStart","index","x","rect","Level","count","add","remove","_findCrossedRectangles","buffer","from","to","rectIndex","loopForward","value","level","hasOwnProperty","key","processed","call","actions","length","push","right","sort","a","b","levels","action","actionLevels","y","bottom","index2","len2"],"mappings":"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","sourcesContent":["import SortedList from './SortedList';\n/**\n * Callback function to iterate over pairs of crossing rectangles\n * \n * @callback onCrossingRectanglesItemCallback\n * @param {Rect} rect1 First rectangle\n * @param {Rect} rect2 Second rectangle\n */\n\n/**\n * Finds pairs of crossing rectangles.\n * \n * @param {Object} thisArg The callback function invocation context\n * @param {Rect[]} rectangles Collection of rectangles.\n * @param {onCrossingRectanglesItemCallback} onCrossing Callback function to pass pair of crossing rectangles.\n */\nexport default function getCrossingRectangles(thisArg, rectangles, onCrossing) {\n  function Action(isStart, index, x, rect) {\n    this.isStart = isStart;\n    this.index = index;\n    this.x = x;\n    this.rect = rect;\n  }\n\n  function Level() {\n    this.count = 0;\n    this.rectangles = {};\n\n    this.add = function (index) {\n      this.count += 1;\n      this.rectangles[index] = true;\n    };\n\n    this.remove = function (index) {\n      this.count -= 1;\n      delete this.rectangles[index];\n      return this.count == 0;\n    };\n  }\n\n  function _findCrossedRectangles(buffer, from, to, rectIndex, rect) {\n    buffer.loopForward(this, from, function (value, level) {\n      if (value > to) {\n        return true;\n      }\n      for (var index in level.rectangles) {\n        if (level.rectangles.hasOwnProperty(index)) {\n          var key = rectIndex > index ? rectIndex + \"-\" + index : index + \"-\" + rectIndex;\n          if (!processed.hasOwnProperty(key)) {\n            processed[key] = true;\n            onCrossing.call(thisArg, rect, rectangles[index]);\n          }\n        }\n      }\n    });\n  }\n\n  if (onCrossing != null) {\n\n    // Create action items out of rectangles\n    var actions = [];\n    for (var index = 0; index < rectangles.length; index += 1) {\n      var rect = rectangles[index];\n\n      actions.push(new Action(1, index, rect.x, rect));\n      actions.push(new Action(0, index, rect.right(), rect));\n    }\n\n    actions.sort(function (a, b) {\n      if (a.x == b.x) {\n        return b.isStart - a.isStart;\n      }\n      return a.x - b.x;\n    });\n\n    /* find intersections */\n    var buffer = SortedList();\n    var levels = {};\n    var processed = {};\n\n    for (index = 0; index < actions.length; index += 1) {\n      var action = actions[index];\n      var actionLevels = [action.rect.y, action.rect.bottom()];\n\n      if (action.isStart == 1) {\n        // Search for intersections of the left side of the rectangle with existing horizontal segments\n        _findCrossedRectangles(buffer, actionLevels[0], actionLevels[1], action.index, action.rect);\n\n        // add rectangle's horizontal segments\n        for (var index2 = 0, len2 = actionLevels.length; index2 < len2; index2 += 1) {\n          var value = actionLevels[index2];\n          var level = levels[value];\n          if (level == null) {\n            level = new Level();\n            levels[value] = level;\n\n            buffer.add(value, level);\n          }\n          level.add(action.index);\n        }\n      } else {\n        // remove rectangle's horizontal segments\n        for (index2 = 0, len2 = actionLevels.length; index2 < len2; index2 += 1) {\n          value = actionLevels[index2];\n          level = levels[value];\n          if (level.remove(action.index)) {\n            delete levels[value];\n            buffer.remove(value);\n          }\n        }\n\n        // Search for intersections of the right side of rectangle with existing horizontal segments\n        _findCrossedRectangles(buffer, actionLevels[0], actionLevels[1], action.index, action.rect);\n      }\n    }\n  }\n};\n\n"]},"metadata":{},"sourceType":"module"}