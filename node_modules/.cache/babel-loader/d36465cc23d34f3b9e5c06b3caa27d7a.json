{"ast":null,"code":"import getFamilyUnits from './getFamilyUnits';\nimport FamilyMargins from './FamilyMargins';\n/**\n * Callback function for getting family node width\n * \n * @callback onFamilyAlignmentItemSizeCallback\n * @param {string} itemid Family node id\n * @param {object} item Family node context object\n * @returns {number} Family node width\n */\n\n/**\n * Creates family alignment data structure. This structure aligns horizontally planar family of nodes.\n * @class FamilyAlignment\n * \n * @param {Object} thisArg The callback function invocation context\n * @param {family} family Family data structure\n * @param {TreeLevels} treeLevels Three levels data structure\n * @param {onFamilyAlignmentItemSizeCallback} onItemSize Callback function to measure family node width\n * @returns {FamilyAlignment} Returns family alignment structure\n */\n\nexport default function FamilyAlignment(thisArg, family, treeLevels, onItemSize) {\n  var offsets,\n      sizes = {},\n      childrenDistances;\n\n  if (onItemSize != null) {\n    treeLevels.loopItems(this, function (itemid, item, position, levelIndex, level) {\n      sizes[itemid] = onItemSize.call(thisArg, itemid, item);\n    });\n  }\n\n  childrenDistances = getDistancesBetweenChildren(family, treeLevels);\n  offsets = getTreeLevelsOffsets(family, treeLevels, childrenDistances);\n\n  function _getNodeMargins(margins, nodeid) {\n    // create margins for node if it does not exists\n    var nodeMargins = margins[nodeid];\n\n    if (nodeMargins == null) {\n      nodeMargins = new FamilyMargins();\n      margins[nodeid] = nodeMargins;\n    }\n\n    return nodeMargins;\n  }\n\n  function getDistancesBetweenChildren(family, treeLevels) {\n    var distances = {};\n    var margins = {};\n    var levelMargins = null;\n    treeLevels.loopLevelsReversed(this, function (levelIndex, level) {\n      var newMargins = new FamilyMargins();\n\n      if (levelMargins != null) {\n        levelMargins.add(0, Number.MAX_VALUE);\n        newMargins.merge(levelMargins, 0);\n      }\n\n      levelMargins = newMargins;\n      var previousParentMargins = levelMargins;\n      treeLevels.loopLevelItems(this, levelIndex, function (nodeid, node, position) {\n        var nodeMargins = _getNodeMargins(margins, nodeid); // add node size into its margin\n\n\n        nodeMargins.add(sizes[nodeid], position);\n\n        switch (family.countParents(nodeid)) {\n          case 0:\n            if (previousParentMargins != null) {\n              distances[nodeid] = previousParentMargins.attach(nodeMargins);\n            }\n\n            break;\n\n          case 1:\n            family.loopParents(this, nodeid, function (parentid, parent, levelIndex) {\n              var parentMargins = _getNodeMargins(margins, parentid);\n\n              distances[nodeid] = parentMargins.merge(nodeMargins);\n              previousParentMargins = parentMargins;\n              return family.BREAK;\n            });\n            break;\n\n          default:\n            // loop parents and find total size of them\n            var totalSize = 0;\n            var fromIndex = null;\n            var toIndex = null;\n            var hash = {};\n            family.loopParents(this, nodeid, function (parentid, parent, levelIndex) {\n              if (levelIndex > 0) {\n                return family.BREAK;\n              }\n\n              totalSize += sizes[parentid];\n              var position = treeLevels.getItemPosition(parentid);\n              fromIndex = fromIndex == null ? position : Math.min(fromIndex, position);\n              toIndex = toIndex == null ? position : Math.max(toIndex, position);\n              hash[position] = parentid;\n            });\n            var offset = -totalSize / 2;\n\n            for (var index = fromIndex; index <= toIndex; index += 1) {\n              var parentid = hash[index];\n              offset += sizes[parentid] / 2.0;\n\n              var parentMargins = _getNodeMargins(margins, parentid);\n\n              parentMargins.attach(nodeMargins, -offset);\n              previousParentMargins = parentMargins;\n              offset += sizes[parentid] / 2.0;\n            }\n\n            break;\n        }\n      });\n    });\n    return distances;\n  }\n\n  function getTreeLevelsOffsets(family, treeLevels, childrenDistances) {\n    var offsets = {};\n    var familyUnitsById = getFamilyUnits(family);\n    var processedFamilyUnits = {};\n    treeLevels.loopLevels(this, function (levelIndex, level) {\n      treeLevels.loopLevelItems(this, levelIndex, function (nodeid, node, position) {\n        if (!offsets.hasOwnProperty(nodeid)) {\n          var offset = 0;\n\n          if (position === 0) {\n            if (childrenDistances[nodeid] != null) {\n              offset += childrenDistances[nodeid] + sizes[nodeid] / 2;\n            }\n          } else {\n            var prevNodeId = treeLevels.getItemAtPosition(levelIndex, position - 1);\n            offset += offsets[prevNodeId] + sizes[prevNodeId] / 2 + (childrenDistances[nodeid] || 0) + sizes[nodeid] / 2;\n          }\n\n          offsets[nodeid] = offset;\n        }\n\n        var familyUnits = familyUnitsById[nodeid];\n\n        if (familyUnits != null) {\n          for (var index = 0; index < familyUnits.length; index += 1) {\n            var familyUnit = familyUnits[index];\n\n            if (!processedFamilyUnits.hasOwnProperty(familyUnit.id)) {\n              processedFamilyUnits[familyUnit.id] = true;\n              setFamilyOffsets(offsets, nodeid, familyUnit, levelIndex, levelIndex + 1, position, treeLevels, childrenDistances);\n            }\n          }\n        }\n      });\n    });\n    return offsets;\n  }\n\n  function setFamilyOffsets(offsets, itemid, familyUnit, fromLevel, toLevel, itemIndex, treeLevels, childrenDistances) {\n    var fromIndex = itemIndex;\n    var toIndex = itemIndex;\n    familyUnit.loopSiblings(this, itemid, function (siblingid) {\n      var position = treeLevels.getItemPosition(siblingid);\n      fromIndex = Math.min(fromIndex, position);\n      toIndex = Math.max(toIndex, position);\n    }); // Place nodes on the left side of start node\n\n    for (var index = itemIndex - 1; index >= fromIndex; index -= 1) {\n      var siblingid = treeLevels.getItemAtPosition(fromLevel, index);\n\n      if (!offsets.hasOwnProperty(siblingid)) {\n        var nodeid = treeLevels.getItemAtPosition(fromLevel, index + 1);\n        offsets[siblingid] = offsets[nodeid] - (sizes[siblingid] / 2 + (childrenDistances[nodeid] || 0) + sizes[nodeid] / 2);\n      }\n    } // Place nodes on the right side of start node\n\n\n    for (index = itemIndex + 1; index <= toIndex; index += 1) {\n      siblingid = treeLevels.getItemAtPosition(fromLevel, index);\n\n      if (!offsets.hasOwnProperty(siblingid)) {\n        nodeid = treeLevels.getItemAtPosition(fromLevel, index - 1);\n        offsets[siblingid] = offsets[nodeid] + (sizes[nodeid] / 2 + (childrenDistances[siblingid] || 0) + sizes[siblingid] / 2);\n      }\n    }\n\n    siblingid = treeLevels.getItemAtPosition(fromLevel, fromIndex);\n    var siblingsMedian = offsets[siblingid] - sizes[siblingid] / 2;\n    siblingid = treeLevels.getItemAtPosition(fromLevel, toIndex);\n    siblingsMedian += offsets[siblingid] + sizes[siblingid] / 2;\n    siblingsMedian /= 2;\n    fromIndex = null;\n    toIndex = null;\n    familyUnit.loopNonSiblings(this, itemid, function (siblingid) {\n      var position = treeLevels.getItemPosition(siblingid);\n      fromIndex = fromIndex != null ? Math.min(fromIndex, position) : position;\n      toIndex = toIndex != null ? Math.max(toIndex, position) : position;\n    });\n    var nonSiblingsWidth = 0;\n\n    for (index = fromIndex; index <= toIndex; index += 1) {\n      var relatedItemId = treeLevels.getItemAtPosition(toLevel, index);\n      nonSiblingsWidth += sizes[relatedItemId];\n\n      if (index > fromIndex) {\n        nonSiblingsWidth += childrenDistances[relatedItemId] || 0;\n      }\n    }\n\n    var offset = siblingsMedian - nonSiblingsWidth / 2;\n    relatedItemId = treeLevels.getItemAtPosition(toLevel, fromIndex);\n\n    if (!offsets.hasOwnProperty(relatedItemId)) {\n      offsets[relatedItemId] = offset + sizes[relatedItemId] / 2;\n    }\n\n    for (index = fromIndex + 1; index <= toIndex; index += 1) {\n      relatedItemId = treeLevels.getItemAtPosition(toLevel, index);\n\n      if (!offsets.hasOwnProperty(relatedItemId)) {\n        nodeid = treeLevels.getItemAtPosition(toLevel, index - 1);\n        offsets[relatedItemId] = offsets[nodeid] + (sizes[nodeid] / 2 + (childrenDistances[relatedItemId] || 0) + sizes[relatedItemId] / 2);\n      }\n    }\n  }\n  /**\n   * Returns horizontal node offset from left margin of the family diagram\n   * \n   * @param {string} nodeid Family node id\n   * @returns {number} Node offset\n   */\n\n\n  function getOffset(nodeid) {\n    return offsets[nodeid];\n  }\n\n  return {\n    getOffset: getOffset\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/FamilyAlignment.js"],"names":["getFamilyUnits","FamilyMargins","FamilyAlignment","thisArg","family","treeLevels","onItemSize","offsets","sizes","childrenDistances","loopItems","itemid","item","position","levelIndex","level","call","getDistancesBetweenChildren","getTreeLevelsOffsets","_getNodeMargins","margins","nodeid","nodeMargins","distances","levelMargins","loopLevelsReversed","newMargins","add","Number","MAX_VALUE","merge","previousParentMargins","loopLevelItems","node","countParents","attach","loopParents","parentid","parent","parentMargins","BREAK","totalSize","fromIndex","toIndex","hash","getItemPosition","Math","min","max","offset","index","familyUnitsById","processedFamilyUnits","loopLevels","hasOwnProperty","prevNodeId","getItemAtPosition","familyUnits","length","familyUnit","id","setFamilyOffsets","fromLevel","toLevel","itemIndex","loopSiblings","siblingid","siblingsMedian","loopNonSiblings","nonSiblingsWidth","relatedItemId","getOffset"],"mappings":"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","sourcesContent":["import getFamilyUnits from './getFamilyUnits';\nimport FamilyMargins from './FamilyMargins';\n/**\n * Callback function for getting family node width\n * \n * @callback onFamilyAlignmentItemSizeCallback\n * @param {string} itemid Family node id\n * @param {object} item Family node context object\n * @returns {number} Family node width\n */\n\n/**\n * Creates family alignment data structure. This structure aligns horizontally planar family of nodes.\n * @class FamilyAlignment\n * \n * @param {Object} thisArg The callback function invocation context\n * @param {family} family Family data structure\n * @param {TreeLevels} treeLevels Three levels data structure\n * @param {onFamilyAlignmentItemSizeCallback} onItemSize Callback function to measure family node width\n * @returns {FamilyAlignment} Returns family alignment structure\n */\nexport default function FamilyAlignment(thisArg, family, treeLevels, onItemSize) {\n  var offsets,\n    sizes = {},\n    childrenDistances;\n\n  if (onItemSize != null) {\n    treeLevels.loopItems(this, function (itemid, item, position, levelIndex, level) {\n      sizes[itemid] = onItemSize.call(thisArg, itemid, item);\n    });\n  }\n\n  childrenDistances = getDistancesBetweenChildren(family, treeLevels);\n  offsets = getTreeLevelsOffsets(family, treeLevels, childrenDistances);\n\n  function _getNodeMargins(margins, nodeid) {\n    // create margins for node if it does not exists\n    var nodeMargins = margins[nodeid];\n    if (nodeMargins == null) {\n      nodeMargins = new FamilyMargins();\n      margins[nodeid] = nodeMargins;\n    }\n    return nodeMargins;\n  }\n\n  function getDistancesBetweenChildren(family, treeLevels) {\n    var distances = {};\n    var margins = {};\n    var levelMargins = null;\n\n    treeLevels.loopLevelsReversed(this, function (levelIndex, level) {\n      var newMargins = new FamilyMargins();\n      if (levelMargins != null) {\n        levelMargins.add(0, Number.MAX_VALUE);\n        newMargins.merge(levelMargins, 0);\n      }\n      levelMargins = newMargins;\n\n      var previousParentMargins = levelMargins;\n      treeLevels.loopLevelItems(this, levelIndex, function (nodeid, node, position) {\n        var nodeMargins = _getNodeMargins(margins, nodeid);\n\n        // add node size into its margin\n        nodeMargins.add(sizes[nodeid], position);\n\n        switch (family.countParents(nodeid)) {\n          case 0:\n            if (previousParentMargins != null) {\n              distances[nodeid] = previousParentMargins.attach(nodeMargins);\n            }\n            break;\n          case 1:\n            family.loopParents(this, nodeid, function (parentid, parent, levelIndex) {\n              var parentMargins = _getNodeMargins(margins, parentid);\n              distances[nodeid] = parentMargins.merge(nodeMargins);\n\n              previousParentMargins = parentMargins;\n              return family.BREAK;\n            });\n            break;\n          default:\n            // loop parents and find total size of them\n            var totalSize = 0;\n            var fromIndex = null;\n            var toIndex = null;\n            var hash = {};\n            family.loopParents(this, nodeid, function (parentid, parent, levelIndex) {\n              if (levelIndex > 0) {\n                return family.BREAK;\n              }\n              totalSize += sizes[parentid];\n\n              var position = treeLevels.getItemPosition(parentid);\n              fromIndex = fromIndex == null ? position : Math.min(fromIndex, position);\n              toIndex = toIndex == null ? position : Math.max(toIndex, position);\n              hash[position] = parentid;\n            });\n\n            var offset = -totalSize / 2;\n            for (var index = fromIndex; index <= toIndex; index += 1) {\n              var parentid = hash[index];\n\n              offset += sizes[parentid] / 2.0;\n\n              var parentMargins = _getNodeMargins(margins, parentid);\n\n              parentMargins.attach(nodeMargins, -offset);\n\n              previousParentMargins = parentMargins;\n\n              offset += sizes[parentid] / 2.0;\n            }\n            break;\n        }\n      });\n    });\n\n    return distances;\n  }\n\n  function getTreeLevelsOffsets(family, treeLevels, childrenDistances) {\n    var offsets = {};\n\n    var familyUnitsById = getFamilyUnits(family);\n    var processedFamilyUnits = {};\n\n    treeLevels.loopLevels(this, function (levelIndex, level) {\n      treeLevels.loopLevelItems(this, levelIndex, function (nodeid, node, position) {\n        if (!offsets.hasOwnProperty(nodeid)) {\n          var offset = 0;\n          if (position === 0) {\n            if (childrenDistances[nodeid] != null) {\n              offset += childrenDistances[nodeid] + sizes[nodeid] / 2;\n            }\n          } else {\n            var prevNodeId = treeLevels.getItemAtPosition(levelIndex, position - 1);\n            offset += offsets[prevNodeId] + sizes[prevNodeId] / 2 + (childrenDistances[nodeid] || 0) + sizes[nodeid] / 2;\n          }\n          offsets[nodeid] = offset;\n        }\n        var familyUnits = familyUnitsById[nodeid];\n        if (familyUnits != null) {\n          for (var index = 0; index < familyUnits.length; index += 1) {\n            var familyUnit = familyUnits[index];\n            if (!processedFamilyUnits.hasOwnProperty(familyUnit.id)) {\n              processedFamilyUnits[familyUnit.id] = true;\n\n              setFamilyOffsets(offsets, nodeid, familyUnit, levelIndex, levelIndex + 1, position, treeLevels, childrenDistances);\n            }\n          }\n        }\n      });\n    });\n\n    return offsets;\n  }\n\n  function setFamilyOffsets(offsets, itemid, familyUnit, fromLevel, toLevel, itemIndex, treeLevels, childrenDistances) {\n    var fromIndex = itemIndex;\n    var toIndex = itemIndex;\n\n    familyUnit.loopSiblings(this, itemid, function (siblingid) {\n      var position = treeLevels.getItemPosition(siblingid);\n      fromIndex = Math.min(fromIndex, position);\n      toIndex = Math.max(toIndex, position);\n    });\n\n    // Place nodes on the left side of start node\n    for (var index = itemIndex - 1; index >= fromIndex; index -= 1) {\n      var siblingid = treeLevels.getItemAtPosition(fromLevel, index);\n\n      if (!offsets.hasOwnProperty(siblingid)) {\n        var nodeid = treeLevels.getItemAtPosition(fromLevel, index + 1);\n        offsets[siblingid] = offsets[nodeid] - (sizes[siblingid] / 2 + (childrenDistances[nodeid] || 0) + sizes[nodeid] / 2);\n      }\n    }\n    // Place nodes on the right side of start node\n    for (index = itemIndex + 1; index <= toIndex; index += 1) {\n      siblingid = treeLevels.getItemAtPosition(fromLevel, index);\n\n      if (!offsets.hasOwnProperty(siblingid)) {\n        nodeid = treeLevels.getItemAtPosition(fromLevel, index - 1);\n        offsets[siblingid] = offsets[nodeid] + (sizes[nodeid] / 2 + (childrenDistances[siblingid] || 0) + sizes[siblingid] / 2);\n      }\n    }\n    siblingid = treeLevels.getItemAtPosition(fromLevel, fromIndex);\n    var siblingsMedian = offsets[siblingid] - sizes[siblingid] / 2;\n    siblingid = treeLevels.getItemAtPosition(fromLevel, toIndex);\n    siblingsMedian += offsets[siblingid] + sizes[siblingid] / 2;\n\n    siblingsMedian /= 2;\n\n    fromIndex = null;\n    toIndex = null;\n    familyUnit.loopNonSiblings(this, itemid, function (siblingid) {\n      var position = treeLevels.getItemPosition(siblingid);\n      fromIndex = fromIndex != null ? Math.min(fromIndex, position) : position;\n      toIndex = toIndex != null ? Math.max(toIndex, position) : position;\n    });\n\n    var nonSiblingsWidth = 0;\n    for (index = fromIndex; index <= toIndex; index += 1) {\n      var relatedItemId = treeLevels.getItemAtPosition(toLevel, index);\n      nonSiblingsWidth += sizes[relatedItemId];\n      if (index > fromIndex) {\n        nonSiblingsWidth += (childrenDistances[relatedItemId] || 0);\n      }\n    }\n\n    var offset = siblingsMedian - nonSiblingsWidth / 2;\n    relatedItemId = treeLevels.getItemAtPosition(toLevel, fromIndex);\n    if (!offsets.hasOwnProperty(relatedItemId)) {\n      offsets[relatedItemId] = offset + sizes[relatedItemId] / 2;\n    }\n    for (index = fromIndex + 1; index <= toIndex; index += 1) {\n      relatedItemId = treeLevels.getItemAtPosition(toLevel, index);\n      if (!offsets.hasOwnProperty(relatedItemId)) {\n        nodeid = treeLevels.getItemAtPosition(toLevel, index - 1);\n        offsets[relatedItemId] = offsets[nodeid] + (sizes[nodeid] / 2 + (childrenDistances[relatedItemId] || 0) + sizes[relatedItemId] / 2);\n      }\n    }\n  }\n\n  /**\n   * Returns horizontal node offset from left margin of the family diagram\n   * \n   * @param {string} nodeid Family node id\n   * @returns {number} Node offset\n   */\n  function getOffset(nodeid) {\n    return offsets[nodeid];\n  }\n\n  return {\n    getOffset: getOffset\n  };\n};"]},"metadata":{},"sourceType":"module"}