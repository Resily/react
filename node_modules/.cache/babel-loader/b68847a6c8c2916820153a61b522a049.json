{"ast":null,"code":"import { Layers, ConnectorStyleType, GroupByType, ElbowType } from '../../enums';\nimport PolylinesBuffer from '../../graphics/structs/PolylinesBuffer';\nimport DotSegment from '../../graphics/structs/DotSegment';\nexport default function DrawConnectorsTask(getGraphics, connectionsGraphTask, connectorsOptionTask, showElbowDots, paletteManagerTask) {\n  function process() {\n    var graphics = getGraphics();\n    var graph = connectionsGraphTask.getGraph();\n    var connectorsOptions = connectorsOptionTask.getOptions();\n    var paletteManager = paletteManagerTask.getPaletteManager();\n    graphics.reset(\"placeholder\", Layers.Connector);\n    graphics.activate(\"placeholder\", Layers.Connector);\n    var buffer = new PolylinesBuffer();\n    var elbowDotRadius = Math.round(connectorsOptions.elbowDotSize / 2);\n    var processed = {};\n    var processedDots = {};\n    graph.loopNodes(this, null, function (itemid) {\n      graph.loopNodeEdges(this, itemid, function (to, connectorEdge) {\n        if (!processed.hasOwnProperty(to)) {\n          var paletteItem = null;\n\n          if (connectorEdge.fromOffset <= 1) {\n            paletteItem = paletteManager.getPalette(ConnectorStyleType.Regular);\n          } else {\n            paletteManager.selectPalette(connectorEdge.fromOffset);\n            paletteItem = paletteManager.getPalette(ConnectorStyleType.Extra);\n          }\n\n          var polyline = buffer.getPolyline(paletteItem);\n          /* draw intersection dots */\n\n          if (showElbowDots && connectorEdge.dotId != null && connectorsOptions.elbowType != ElbowType.None && !processedDots.hasOwnProperty(connectorEdge.dotId)) {\n            var dotPolyline = buffer.getPolyline(polyline.arrowPaletteItem);\n            var dotPoint = connectorEdge.dotId == connectorEdge.from ? connectorEdge.polyline.getStartPoint() : connectorEdge.polyline.getEndPoint();\n            dotPolyline.addSegment(new DotSegment(dotPoint.x - elbowDotRadius, dotPoint.y - elbowDotRadius, elbowDotRadius * 2, elbowDotRadius * 2, elbowDotRadius));\n            processedDots[connectorEdge.dotId] = true;\n          }\n\n          var arrowId = null;\n\n          if (connectorEdge.hasArrow) {\n            switch (connectorsOptions.arrowsDirection) {\n              case GroupByType.Parents:\n                arrowId = !connectorEdge.isOppositeFlow ? connectorEdge.parentsArrowId : connectorEdge.childrenArrowId;\n                break;\n\n              case GroupByType.Children:\n                arrowId = !connectorEdge.isOppositeFlow ? connectorEdge.childrenArrowId : connectorEdge.parentsArrowId;\n                break;\n            }\n          }\n\n          if (arrowId == null) {\n            var newSegment = connectorEdge.polyline.clone();\n\n            if (connectorEdge.hasMiddle && connectorsOptions.arrowsDirection != GroupByType.None) {\n              var isForward = true;\n\n              if (connectorEdge.from == connectorEdge.middleParent) {\n                isForward = connectorsOptions.arrowsDirection == GroupByType.Children;\n              } else {\n                isForward = connectorsOptions.arrowsDirection == GroupByType.Parents;\n              }\n\n              if (connectorEdge.isOppositeFlow) {\n                isForward = !isForward;\n              }\n\n              newSegment.addOffsetArrow(isForward, connectorsOptions.linesWidth, 0.4, connectorsOptions.extraArrowsMinimumSpace, function (arrowPolyline) {\n                arrowPolyline.mergeTo(buffer.getPolyline(polyline.arrowPaletteItem));\n              }); //ignore jslint\n            }\n\n            if (connectorEdge.from == itemid) {\n              newSegment.mergeTo(polyline);\n            } else {\n              polyline.addInverted(newSegment);\n            }\n          } else {\n            if (arrowId == connectorEdge.to) {\n              connectorEdge.polyline.clone().mergeTo(polyline);\n            } else {\n              polyline.addInverted(connectorEdge.polyline.clone());\n            }\n\n            polyline.addArrow(connectorsOptions.linesWidth, function (arrowPolyline) {\n              arrowPolyline.mergeTo(buffer.getPolyline(arrowPolyline.paletteItem));\n            }); //ignore jslint\n          }\n        }\n      });\n      processed[itemid] = true;\n    });\n    graphics.polylinesBuffer(buffer);\n    return false;\n  }\n\n  return {\n    process: process\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/tasks/renders/DrawConnectorsTask.js"],"names":["Layers","ConnectorStyleType","GroupByType","ElbowType","PolylinesBuffer","DotSegment","DrawConnectorsTask","getGraphics","connectionsGraphTask","connectorsOptionTask","showElbowDots","paletteManagerTask","process","graphics","graph","getGraph","connectorsOptions","getOptions","paletteManager","getPaletteManager","reset","Connector","activate","buffer","elbowDotRadius","Math","round","elbowDotSize","processed","processedDots","loopNodes","itemid","loopNodeEdges","to","connectorEdge","hasOwnProperty","paletteItem","fromOffset","getPalette","Regular","selectPalette","Extra","polyline","getPolyline","dotId","elbowType","None","dotPolyline","arrowPaletteItem","dotPoint","from","getStartPoint","getEndPoint","addSegment","x","y","arrowId","hasArrow","arrowsDirection","Parents","isOppositeFlow","parentsArrowId","childrenArrowId","Children","newSegment","clone","hasMiddle","isForward","middleParent","addOffsetArrow","linesWidth","extraArrowsMinimumSpace","arrowPolyline","mergeTo","addInverted","addArrow","polylinesBuffer"],"mappings":"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","sourcesContent":["import { Layers, ConnectorStyleType, GroupByType, ElbowType } from '../../enums';\nimport PolylinesBuffer from '../../graphics/structs/PolylinesBuffer';\nimport DotSegment from '../../graphics/structs/DotSegment';\n\n\nexport default function DrawConnectorsTask(getGraphics, connectionsGraphTask, connectorsOptionTask, showElbowDots, paletteManagerTask) {\n  function process() {\n    var graphics = getGraphics();\n    var graph = connectionsGraphTask.getGraph();\n    var connectorsOptions = connectorsOptionTask.getOptions();\n    var paletteManager = paletteManagerTask.getPaletteManager();\n\n    graphics.reset(\"placeholder\", Layers.Connector);\n    graphics.activate(\"placeholder\", Layers.Connector);\n\n    var buffer = new PolylinesBuffer();\n\n    var elbowDotRadius = Math.round(connectorsOptions.elbowDotSize / 2);\n\n    var processed = {};\n    var processedDots = {};\n    graph.loopNodes(this, null, function (itemid) {\n      graph.loopNodeEdges(this, itemid, function (to, connectorEdge) {\n        if (!processed.hasOwnProperty(to)) {\n          var paletteItem = null;\n          if (connectorEdge.fromOffset <= 1) {\n            paletteItem = paletteManager.getPalette(ConnectorStyleType.Regular);\n          } else {\n            paletteManager.selectPalette(connectorEdge.fromOffset);\n            paletteItem = paletteManager.getPalette(ConnectorStyleType.Extra);\n          }\n          var polyline = buffer.getPolyline(paletteItem);\n\n          /* draw intersection dots */\n          if (showElbowDots && connectorEdge.dotId != null && connectorsOptions.elbowType != ElbowType.None && !processedDots.hasOwnProperty(connectorEdge.dotId)) {\n            var dotPolyline = buffer.getPolyline(polyline.arrowPaletteItem);\n            var dotPoint = (connectorEdge.dotId == connectorEdge.from) ? connectorEdge.polyline.getStartPoint() : connectorEdge.polyline.getEndPoint();\n            dotPolyline.addSegment(new DotSegment(dotPoint.x - elbowDotRadius, dotPoint.y - elbowDotRadius, elbowDotRadius * 2, elbowDotRadius * 2, elbowDotRadius));\n            processedDots[connectorEdge.dotId] = true;\n          }\n\n          var arrowId = null;\n\n          if (connectorEdge.hasArrow) {\n            switch (connectorsOptions.arrowsDirection) {\n              case GroupByType.Parents:\n                arrowId = !connectorEdge.isOppositeFlow ? connectorEdge.parentsArrowId : connectorEdge.childrenArrowId;\n                break;\n              case GroupByType.Children:\n                arrowId = !connectorEdge.isOppositeFlow ? connectorEdge.childrenArrowId : connectorEdge.parentsArrowId;\n                break;\n            }\n          }\n\n          if (arrowId == null) {\n            var newSegment = connectorEdge.polyline.clone();\n\n            if (connectorEdge.hasMiddle && connectorsOptions.arrowsDirection != GroupByType.None) {\n              var isForward = true;\n              if (connectorEdge.from == connectorEdge.middleParent) {\n                isForward = (connectorsOptions.arrowsDirection == GroupByType.Children);\n              } else {\n                isForward = (connectorsOptions.arrowsDirection == GroupByType.Parents);\n              }\n              if (connectorEdge.isOppositeFlow) {\n                isForward = !isForward;\n              }\n              newSegment.addOffsetArrow(isForward, connectorsOptions.linesWidth, 0.4, connectorsOptions.extraArrowsMinimumSpace, function (arrowPolyline) {\n                arrowPolyline.mergeTo(buffer.getPolyline(polyline.arrowPaletteItem));\n              }); //ignore jslint\n            }\n\n            if (connectorEdge.from == itemid) {\n              newSegment.mergeTo(polyline);\n            } else {\n              polyline.addInverted(newSegment);\n            }\n          } else {\n            if (arrowId == connectorEdge.to) {\n              connectorEdge.polyline.clone().mergeTo(polyline);\n            } else {\n              polyline.addInverted(connectorEdge.polyline.clone());\n            }\n            polyline.addArrow(connectorsOptions.linesWidth, function (arrowPolyline) {\n              arrowPolyline.mergeTo(buffer.getPolyline(arrowPolyline.paletteItem));\n            }); //ignore jslint\n          }\n        }\n      });\n      processed[itemid] = true;\n    });\n\n    graphics.polylinesBuffer(buffer);\n\n    return false;\n  }\n\n  return {\n    process: process\n  };\n};"]},"metadata":{},"sourceType":"module"}