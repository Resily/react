{"ast":null,"code":"/**\n * Creates pile structure used to sort and stack segments on top of each other \n * so they occupy minimum number of rows.\n * @class Pile\n * \n * @returns {Pile} Returns pile structure\n */\nexport default function Pile() {\n  var _items = [];\n  /**\n   * Adds new segment to pile object.\n   * \n   * @param {number} from Left margin of segment.\n   * @param {number} to Right margin of segment.\n   * @param {object} context Any reference to user object. It is returned as parameter in callback function of resolve method.\n   */\n\n  function add(from, to, context) {\n    if (from < to) {\n      _items.push(new Segment(from, to, context, 1));\n    } else {\n      _items.push(new Segment(to, from, context, -1));\n    }\n  }\n  /**\n   * Callback function or iterating result offsets of the pile items in the stack.\n   * \n   * @callback onPileItemCallback\n   * @param {number} from The left margin of the segment \n   * @param {number} to The right margin of the segment\n   * @param {object} context The context of the pile item\n   * @param {number} offset Index of the pile item in the stack\n   */\n\n  /**\n   * Sorts and stack segments on top of each other so they occupy minimum number of rows.\n   * \n   * @param {object} thisArg A context object of the callback function invocation.\n   * @param {onPileItemCallback} onItem Callback function for setting segments offsets in the pile.\n   * @returns {number} Number of stacked rows in pile.\n   */\n\n\n  function resolve(thisArg, onItem) {\n    var hash,\n        backtraceNext,\n        backtraceTaken,\n        items,\n        item,\n        rowItems,\n        rows,\n        rowIndex,\n        index,\n        offset = 0;\n\n    if (onItem != null) {\n      items = _items.slice(0);\n      items.sort(function (a, b) {\n        return a.from - b.from;\n      });\n      rows = [];\n\n      while (items.length > 0) {\n        hash = {};\n        backtraceNext = {};\n        backtraceTaken = {};\n        getMax(0, items, hash, backtraceNext, backtraceTaken);\n        rowItems = [];\n        rows[offset] = [];\n        index = 0;\n\n        while (backtraceNext.hasOwnProperty(index)) {\n          if (backtraceTaken[index]) {\n            rowItems.push(index);\n            rows[offset].push(items[index]);\n          }\n\n          index = backtraceNext[index];\n        }\n\n        for (index = rowItems.length - 1; index >= 0; index -= 1) {\n          items.splice(rowItems[index], 1);\n        }\n\n        offset += 1;\n      }\n\n      for (rowIndex = 0; rowIndex < offset; rowIndex += 1) {\n        rowItems = rows[rowIndex];\n\n        for (index = 0; index < rowItems.length; index += 1) {\n          item = rowItems[index];\n\n          if (onItem.call(thisArg, item.from, item.to, item.context, rowIndex, offset, item.direction)) {\n            return offset;\n          }\n        }\n      }\n    }\n\n    return offset;\n  }\n\n  function Segment(from, to, context, direction) {\n    this.context = context;\n    this.from = from;\n    this.to = to;\n    this.offset = null;\n    this.direction = direction;\n  }\n\n  function getMax(index, items, hash, backtraceNext, backtraceTaken) {\n    var result = 0;\n\n    if (index >= items.length) {\n      return 0;\n    }\n\n    if (hash.hasOwnProperty(index)) {\n      return hash[index];\n    }\n\n    var item = items[index];\n    var withoutItem = getMax(index + 1, items, hash, backtraceNext, backtraceTaken);\n    var nextIndex = index + 1;\n\n    while (nextIndex < items.length) {\n      var nextItem = items[nextIndex];\n\n      if (nextItem.from >= item.to) {\n        break;\n      }\n\n      nextIndex += 1;\n    }\n\n    var withItem = 1 + getMax(nextIndex, items, hash, backtraceNext, backtraceTaken);\n\n    if (withItem > withoutItem) {\n      hash[index] = withItem;\n      backtraceNext[index] = nextIndex;\n      backtraceTaken[index] = true;\n    } else {\n      hash[index] = withoutItem;\n      backtraceNext[index] = index + 1;\n      backtraceTaken[index] = false;\n    }\n\n    return hash[index];\n  }\n\n  return {\n    add: add,\n    resolve: resolve\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/Pile.js"],"names":["Pile","_items","add","from","to","context","push","Segment","resolve","thisArg","onItem","hash","backtraceNext","backtraceTaken","items","item","rowItems","rows","rowIndex","index","offset","slice","sort","a","b","length","getMax","hasOwnProperty","splice","call","direction","result","withoutItem","nextIndex","nextItem","withItem"],"mappings":"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","sourcesContent":["/**\n * Creates pile structure used to sort and stack segments on top of each other \n * so they occupy minimum number of rows.\n * @class Pile\n * \n * @returns {Pile} Returns pile structure\n */\nexport default function Pile () {\n  var _items = [];\n\n  /**\n   * Adds new segment to pile object.\n   * \n   * @param {number} from Left margin of segment.\n   * @param {number} to Right margin of segment.\n   * @param {object} context Any reference to user object. It is returned as parameter in callback function of resolve method.\n   */\n  function add(from, to, context) {\n    if (from < to) {\n      _items.push(new Segment(from, to, context, 1));\n    } else {\n      _items.push(new Segment(to, from, context, -1));\n    }\n  }\n\n  /**\n   * Callback function or iterating result offsets of the pile items in the stack.\n   * \n   * @callback onPileItemCallback\n   * @param {number} from The left margin of the segment \n   * @param {number} to The right margin of the segment\n   * @param {object} context The context of the pile item\n   * @param {number} offset Index of the pile item in the stack\n   */\n\n  /**\n   * Sorts and stack segments on top of each other so they occupy minimum number of rows.\n   * \n   * @param {object} thisArg A context object of the callback function invocation.\n   * @param {onPileItemCallback} onItem Callback function for setting segments offsets in the pile.\n   * @returns {number} Number of stacked rows in pile.\n   */\n  function resolve(thisArg, onItem) {\n    var hash,\n      backtraceNext,\n      backtraceTaken,\n      items, item,\n      rowItems,\n      rows,\n      rowIndex, index,\n      offset = 0;\n\n    if (onItem != null) {\n      items = _items.slice(0);\n      items.sort(function (a, b) {\n        return a.from - b.from;\n      });\n\n      rows = [];\n      while (items.length > 0) {\n        hash = {};\n        backtraceNext = {};\n        backtraceTaken = {};\n\n        getMax(0, items, hash, backtraceNext, backtraceTaken);\n\n        rowItems = [];\n        rows[offset] = [];\n        index = 0;\n        while (backtraceNext.hasOwnProperty(index)) {\n          if (backtraceTaken[index]) {\n            rowItems.push(index);\n\n            rows[offset].push(items[index]);\n          }\n          index = backtraceNext[index];\n        }\n\n        for (index = rowItems.length - 1; index >= 0; index -= 1) {\n          items.splice(rowItems[index], 1);\n        }\n        offset += 1;\n      }\n\n      for (rowIndex = 0; rowIndex < offset; rowIndex += 1) {\n        rowItems = rows[rowIndex];\n        for (index = 0; index < rowItems.length; index += 1) {\n          item = rowItems[index];\n          if (onItem.call(thisArg, item.from, item.to, item.context, rowIndex, offset, item.direction)) {\n            return offset;\n          }\n        }\n      }\n    }\n\n    return offset;\n  }\n\n  function Segment(from, to, context, direction) {\n    this.context = context;\n    this.from = from;\n    this.to = to;\n    this.offset = null;\n    this.direction = direction;\n  }\n\n  function getMax(index, items, hash, backtraceNext, backtraceTaken) {\n    var result = 0;\n\n    if (index >= items.length) {\n      return 0;\n    }\n\n    if (hash.hasOwnProperty(index)) {\n      return hash[index];\n    }\n\n    var item = items[index];\n    var withoutItem = getMax(index + 1, items, hash, backtraceNext, backtraceTaken);\n\n    var nextIndex = index + 1;\n    while (nextIndex < items.length) {\n      var nextItem = items[nextIndex];\n      if (nextItem.from >= item.to) {\n        break;\n      }\n      nextIndex += 1;\n    }\n    var withItem = 1 + getMax(nextIndex, items, hash, backtraceNext, backtraceTaken);\n\n    if (withItem > withoutItem) {\n      hash[index] = withItem;\n      backtraceNext[index] = nextIndex;\n      backtraceTaken[index] = true;\n    } else {\n      hash[index] = withoutItem;\n      backtraceNext[index] = index + 1;\n      backtraceTaken[index] = false;\n    }\n\n    return hash[index];\n  }\n\n  return {\n    add: add,\n    resolve: resolve\n  };\n};"]},"metadata":{},"sourceType":"module"}