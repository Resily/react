{"ast":null,"code":"import TreeLevelConnectorStackSize from '../../models/TreeLevelConnectorStackSize';\nimport TreeLevels from '../../algorithms/TreeLevels';\nimport Pile from '../../algorithms/Pile';\nimport { SideFlag } from '../../enums';\nimport VerticalConnectorBundle from '../../connectors/VerticalConnectorBundle';\nimport HorizontalConnectorBundle from '../../connectors/HorizontalConnectorBundle';\n/* Read visual tree\n    populate treeLevels array of type TreeLevel\n      TreeLevel object contains ordered list of all its items \n      plus when items added to that collection we store level & levelPosition in item\n*/\n\nexport default function VisualTreeLevelsTask(visualTreeTask, itemTemplateParamsTask) {\n  var _data = {\n    treeLevels: null,\n\n    /* TreeLevels */\n    bundles: null,\n\n    /* array of BaseConnectorBundle objects */\n    connectorStacks: null\n    /* array of TreeLevelConnectorStackSize objects, \n    it keeps total number of horizontal connectors lines between parents and children stack on top of each other */\n\n  },\n      _nullTreeLevelConnectorStackSize = new TreeLevelConnectorStackSize();\n\n  function process() {\n    var visualTree = visualTreeTask.getVisualTree();\n    _data.treeLevels = TreeLevels();\n    visualTree.loopLevels(this, function (treeItemId, treeItem, levelIndex) {\n      _data.treeLevels.addItem(levelIndex, treeItemId, treeItem);\n    });\n    _data.bundles = [];\n    _data.connectorStacks = [];\n    recalcLevelsDepth(_data.bundles, _data.connectorStacks, _data.treeLevels, visualTree);\n    return true;\n  }\n\n  function recalcLevelsDepth(bundles, connectorStacks, treeLevels, orgTree, orgPartners) {\n    var index,\n        len,\n        index2,\n        len2,\n        index3,\n        len3,\n        treeItem,\n        itemPosition,\n        bundle,\n        bundlesToStack,\n        bundlesByItemmId = {},\n        startIndex,\n        endIndex,\n        stackSegments;\n    treeLevels.loopLevels(this, function (levelIndex, treeLevel) {\n      var stacksSizes = new TreeLevelConnectorStackSize();\n      connectorStacks[levelIndex] = stacksSizes;\n      bundlesToStack = [];\n      treeLevels.loopLevelItems(this, levelIndex, function (itemid, treeItem, position) {\n        var parents = [];\n\n        if (!bundlesByItemmId.hasOwnProperty(itemid)) {\n          if (treeItem.connectorPlacement & SideFlag.Bottom) {\n            parents.push(itemid);\n          }\n\n          parents = parents.concat(treeItem.partners);\n\n          if (parents.length > 0) {\n            bundle = new VerticalConnectorBundle(parents, []);\n\n            for (var index = 0, len = parents.length; index < len; index += 1) {\n              bundlesByItemmId[parents[index]] = bundle;\n            }\n\n            orgTree.loopChildren(this, itemid, function (childid, child, index) {\n              if (child.connectorPlacement & SideFlag.Top) {\n                bundle.toItems.push(childid);\n              }\n            }); //ignore jslint\n\n            if (parents.length > 1) {\n              bundlesToStack.push(bundle);\n            }\n\n            if (bundle.fromItems.length > 1 || bundle.toItems.length > 0) {\n              bundles.push(bundle);\n            }\n          }\n        }\n\n        if (treeItem.connectorPlacement & SideFlag.Left) {\n          bundle = new HorizontalConnectorBundle(itemid, treeLevels.getPrevItem(itemid));\n          bundles.push(bundle);\n        }\n\n        if (treeItem.connectorPlacement & SideFlag.Right) {\n          bundle = new HorizontalConnectorBundle(itemid, treeLevels.getNextItem(itemid));\n          bundles.push(bundle);\n        }\n      });\n\n      if (bundlesToStack.length > 0) {\n        /* find minimum and maximum partner index at level */\n        stackSegments = Pile();\n\n        for (index2 = 0, len2 = bundlesToStack.length; index2 < len2; index2 += 1) {\n          bundle = bundlesToStack[index2];\n          startIndex = null;\n          endIndex = null;\n\n          for (index3 = 0, len3 = bundle.fromItems.length; index3 < len3; index3 += 1) {\n            itemPosition = treeLevels.getItemPosition(bundle.fromItems[index3]);\n            startIndex = startIndex != null ? Math.min(startIndex, itemPosition) : itemPosition;\n            endIndex = endIndex != null ? Math.max(endIndex, itemPosition) : itemPosition;\n          }\n\n          stackSegments.add(startIndex, endIndex, bundle);\n        }\n\n        stacksSizes.parentsStackSize = stackSegments.resolve(this, function (from, to, bundle, offset, stackSize) {\n          bundle.fromOffset = offset + 1;\n          bundle.fromStackSize = stackSize;\n        }); //ignore jslint\n      }\n    });\n  }\n\n  function getTreeLevels() {\n    return _data.treeLevels;\n  }\n\n  function getBundles() {\n    return _data.bundles;\n  }\n\n  function getNestedLayoutBottomConnectorIds() {\n    return {};\n    /* org chart does not support nested layouts */\n  }\n\n  function getConnectorsStacksSizes(levelid) {\n    return _data.connectorStacks[levelid] || _nullTreeLevelConnectorStackSize;\n  }\n\n  return {\n    process: process,\n    getTreeLevels: getTreeLevels,\n    getBundles: getBundles,\n    getConnectorsStacksSizes: getConnectorsStacksSizes,\n    getNestedLayoutBottomConnectorIds: getNestedLayoutBottomConnectorIds\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/tasks/transformations/VisualTreeLevelsTask.js"],"names":["TreeLevelConnectorStackSize","TreeLevels","Pile","SideFlag","VerticalConnectorBundle","HorizontalConnectorBundle","VisualTreeLevelsTask","visualTreeTask","itemTemplateParamsTask","_data","treeLevels","bundles","connectorStacks","_nullTreeLevelConnectorStackSize","process","visualTree","getVisualTree","loopLevels","treeItemId","treeItem","levelIndex","addItem","recalcLevelsDepth","orgTree","orgPartners","index","len","index2","len2","index3","len3","itemPosition","bundle","bundlesToStack","bundlesByItemmId","startIndex","endIndex","stackSegments","treeLevel","stacksSizes","loopLevelItems","itemid","position","parents","hasOwnProperty","connectorPlacement","Bottom","push","concat","partners","length","loopChildren","childid","child","Top","toItems","fromItems","Left","getPrevItem","Right","getNextItem","getItemPosition","Math","min","max","add","parentsStackSize","resolve","from","to","offset","stackSize","fromOffset","fromStackSize","getTreeLevels","getBundles","getNestedLayoutBottomConnectorIds","getConnectorsStacksSizes","levelid"],"mappings":"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","sourcesContent":["import TreeLevelConnectorStackSize from '../../models/TreeLevelConnectorStackSize';\nimport TreeLevels from '../../algorithms/TreeLevels';\nimport Pile from '../../algorithms/Pile';\nimport { SideFlag } from '../../enums';\nimport VerticalConnectorBundle from '../../connectors/VerticalConnectorBundle';\nimport HorizontalConnectorBundle from '../../connectors/HorizontalConnectorBundle';\n\n/* Read visual tree\n    populate treeLevels array of type TreeLevel\n      TreeLevel object contains ordered list of all its items \n      plus when items added to that collection we store level & levelPosition in item\n*/\nexport default function VisualTreeLevelsTask(visualTreeTask, itemTemplateParamsTask) {\n  var _data = {\n    treeLevels: null, /* TreeLevels */\n    bundles: null, /* array of BaseConnectorBundle objects */\n    connectorStacks: null /* array of TreeLevelConnectorStackSize objects, \n      it keeps total number of horizontal connectors lines between parents and children stack on top of each other */\n  },\n    _nullTreeLevelConnectorStackSize = new TreeLevelConnectorStackSize();\n\n  function process() {\n    var visualTree = visualTreeTask.getVisualTree();\n\n    _data.treeLevels = TreeLevels();\n\n    visualTree.loopLevels(this, function (treeItemId, treeItem, levelIndex) {\n      _data.treeLevels.addItem(levelIndex, treeItemId, treeItem);\n    });\n\n    _data.bundles = [];\n    _data.connectorStacks = [];\n\n    recalcLevelsDepth(_data.bundles, _data.connectorStacks, _data.treeLevels, visualTree);\n\n    return true;\n  }\n\n  function recalcLevelsDepth(bundles, connectorStacks, treeLevels, orgTree, orgPartners) {\n    var index, len,\n      index2, len2,\n      index3, len3,\n      treeItem,\n      itemPosition,\n      bundle, bundlesToStack, bundlesByItemmId = {},\n      startIndex, endIndex, stackSegments;\n\n\n    treeLevels.loopLevels(this, function (levelIndex, treeLevel) {\n      var stacksSizes = new TreeLevelConnectorStackSize();\n      connectorStacks[levelIndex] = stacksSizes;\n\n      bundlesToStack = [];\n\n      treeLevels.loopLevelItems(this, levelIndex, function (itemid, treeItem, position) {\n        var parents = [];\n        if (!bundlesByItemmId.hasOwnProperty(itemid)) {\n          if (treeItem.connectorPlacement & SideFlag.Bottom) {\n            parents.push(itemid);\n          }\n          parents = parents.concat(treeItem.partners);\n\n          if (parents.length > 0) {\n            bundle = new VerticalConnectorBundle(parents, []);\n\n            for (var index = 0, len = parents.length; index < len; index += 1) {\n              bundlesByItemmId[parents[index]] = bundle;\n            }\n\n            orgTree.loopChildren(this, itemid, function (childid, child, index) {\n              if (child.connectorPlacement & SideFlag.Top) {\n                bundle.toItems.push(childid);\n              }\n            }); //ignore jslint\n\n            if (parents.length > 1) {\n              bundlesToStack.push(bundle);\n            }\n\n            if (bundle.fromItems.length > 1 || bundle.toItems.length > 0) {\n              bundles.push(bundle);\n            }\n          }\n        }\n\n        if (treeItem.connectorPlacement & SideFlag.Left) {\n          bundle = new HorizontalConnectorBundle(itemid, treeLevels.getPrevItem(itemid));\n          bundles.push(bundle);\n        }\n\n        if (treeItem.connectorPlacement & SideFlag.Right) {\n          bundle = new HorizontalConnectorBundle(itemid, treeLevels.getNextItem(itemid));\n          bundles.push(bundle);\n        }\n      });\n\n      if (bundlesToStack.length > 0) {\n        /* find minimum and maximum partner index at level */\n        stackSegments = Pile();\n        for (index2 = 0, len2 = bundlesToStack.length; index2 < len2; index2 += 1) {\n          bundle = bundlesToStack[index2];\n\n          startIndex = null;\n          endIndex = null;\n          for (index3 = 0, len3 = bundle.fromItems.length; index3 < len3; index3 += 1) {\n            itemPosition = treeLevels.getItemPosition(bundle.fromItems[index3]);\n\n            startIndex = (startIndex != null) ? Math.min(startIndex, itemPosition) : itemPosition;\n            endIndex = (endIndex != null) ? Math.max(endIndex, itemPosition) : itemPosition;\n          }\n          stackSegments.add(startIndex, endIndex, bundle);\n        }\n\n        stacksSizes.parentsStackSize = stackSegments.resolve(this, function (from, to, bundle, offset, stackSize) {\n          bundle.fromOffset = offset + 1;\n          bundle.fromStackSize = stackSize;\n        });//ignore jslint\n      }\n    });\n  }\n\n  function getTreeLevels() {\n    return _data.treeLevels;\n  }\n\n  function getBundles() {\n    return _data.bundles;\n  }\n\n  function getNestedLayoutBottomConnectorIds() {\n    return {}; /* org chart does not support nested layouts */\n  }\n\n  function getConnectorsStacksSizes(levelid) {\n    return _data.connectorStacks[levelid] || _nullTreeLevelConnectorStackSize;\n  }\n\n  return {\n    process: process,\n    getTreeLevels: getTreeLevels,\n    getBundles: getBundles,\n    getConnectorsStacksSizes: getConnectorsStacksSizes,\n    getNestedLayoutBottomConnectorIds: getNestedLayoutBottomConnectorIds\n  };\n};"]},"metadata":{},"sourceType":"module"}