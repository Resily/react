{"ast":null,"code":"import PolylinesBuffer from '../../graphics/structs/PolylinesBuffer';\nimport PaletteItem from '../../graphics/structs/PaletteItem';\nimport { Layers, ZOrderType } from '../../enums';\nexport default function DrawHighlightPathAnnotationTask(getGraphics, connectorsOptionTask, highlightPathAnnotationOptionTask, connectionsGraphTask, zOrderType) {\n  function process() {\n    var graph = connectionsGraphTask.getGraph(),\n        highlightOptions = connectorsOptionTask.getOptions(),\n        annotations = highlightPathAnnotationOptionTask.getAnnotations(),\n        graphics = getGraphics();\n\n    switch (zOrderType) {\n      case ZOrderType.Background:\n        //ignore jslint\n        graphics.reset(\"placeholder\", Layers.BackgroundHighlightPathAnnotations);\n        break;\n\n      case ZOrderType.Foreground:\n        //ignore jslint\n        graphics.reset(\"placeholder\", Layers.ForegroundHighlightPathAnnotations);\n        break;\n    }\n\n    drawAnnotations(graphics, highlightOptions, annotations, graph);\n    return false;\n  }\n\n  function drawAnnotations(graphics, highlightOptions, annotations, graph) {\n    var index, len, index2, len2, index3, len3, firstItemId, nextItemId, treeItem, path, items, connectorEdge, annotationConfig, panel, buffer, from, to;\n\n    if (annotations.length > 0) {\n      buffer = new PolylinesBuffer();\n\n      switch (zOrderType) {\n        case ZOrderType.Background:\n          //ignore jslint\n          panel = graphics.activate(\"placeholder\", Layers.BackgroundHighlightPathAnnotations);\n          break;\n\n        case ZOrderType.Foreground:\n          //ignore jslint\n          panel = graphics.activate(\"placeholder\", Layers.ForegroundHighlightPathAnnotations);\n          break;\n      }\n      /* group path segments by from node */\n\n\n      var pairs = {};\n\n      for (index = 0, len = annotations.length; index < len; index += 1) {\n        annotationConfig = annotations[index];\n\n        if (annotationConfig.items != null && annotationConfig.items.length > 0) {\n          items = annotationConfig.items.slice(0);\n          firstItemId = items[0];\n\n          if (graph.hasNode(firstItemId)) {\n            for (index2 = 1, len2 = items.length; index2 < len2; index2 += 1) {\n              nextItemId = items[index2];\n\n              if (graph.hasNode(nextItemId)) {\n                if (pairs.hasOwnProperty(firstItemId)) {\n                  pairs[firstItemId].push(nextItemId);\n                } else {\n                  pairs[firstItemId] = [nextItemId];\n                }\n\n                firstItemId = nextItemId;\n              }\n            }\n          }\n        }\n      }\n      /* get shortest paths */\n\n\n      var paths = {};\n\n      for (from in pairs) {\n        paths[from] = {};\n\n        if (pairs.hasOwnProperty(from)) {\n          graph.getShortestPath(this, from, pairs[from], function (connectorEdge, fromItem, toItem) {\n            return connectorEdge.weight;\n          }, function (path2, to2) {\n            paths[from][to2] = path2;\n          }); //ignore jslint\n        }\n      }\n      /* trace annotations */\n\n\n      for (index = 0, len = annotations.length; index < len; index += 1) {\n        annotationConfig = annotations[index];\n        var paletteItem = new PaletteItem({\n          lineColor: annotationConfig.color != null ? annotationConfig.color : highlightOptions.highlightLinesColor,\n          lineWidth: annotationConfig.lineWidth != null ? annotationConfig.lineWidth : highlightOptions.highlightLinesWidth,\n          lineType: annotationConfig.lineType != null ? annotationConfig.lineType : highlightOptions.highlightLinesType,\n          fillColor: null,\n          opacity: annotationConfig.opacity\n        });\n        var polyline = buffer.getPolyline(paletteItem);\n\n        if (annotationConfig.items != null && annotationConfig.items.length > 0) {\n          items = annotationConfig.items.slice(0);\n          firstItemId = items[0];\n\n          if (graph.hasNode(firstItemId)) {\n            for (index2 = 1, len2 = items.length; index2 < len2; index2 += 1) {\n              nextItemId = items[index2];\n\n              if (graph.hasNode(nextItemId)) {\n                path = paths[firstItemId][nextItemId] || [];\n\n                for (index3 = path.length - 2; index3 >= 0; index3 -= 1) {\n                  from = path[index3 + 1];\n                  to = path[index3];\n                  connectorEdge = graph.edge(from, to);\n\n                  if (connectorEdge.from == from) {\n                    connectorEdge.polyline.clone().mergeTo(polyline);\n                  } else {\n                    polyline.addInverted(connectorEdge.polyline.clone());\n                  }\n\n                  if (annotationConfig.showArrows) {\n                    if (to == connectorEdge.parentsArrowId || to == connectorEdge.childrenArrowId) {\n                      polyline.addArrow(annotationConfig.lineWidth, function (arrowPolyline) {\n                        arrowPolyline.mergeTo(buffer.getPolyline(arrowPolyline.paletteItem));\n                      }); //ignore jslint\n                    }\n                  }\n                }\n\n                firstItemId = nextItemId;\n              }\n            }\n          }\n        }\n      }\n\n      graphics.polylinesBuffer(buffer);\n    }\n  }\n\n  return {\n    process: process\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/tasks/renders/DrawHighlightPathAnnotationTask.js"],"names":["PolylinesBuffer","PaletteItem","Layers","ZOrderType","DrawHighlightPathAnnotationTask","getGraphics","connectorsOptionTask","highlightPathAnnotationOptionTask","connectionsGraphTask","zOrderType","process","graph","getGraph","highlightOptions","getOptions","annotations","getAnnotations","graphics","Background","reset","BackgroundHighlightPathAnnotations","Foreground","ForegroundHighlightPathAnnotations","drawAnnotations","index","len","index2","len2","index3","len3","firstItemId","nextItemId","treeItem","path","items","connectorEdge","annotationConfig","panel","buffer","from","to","length","activate","pairs","slice","hasNode","hasOwnProperty","push","paths","getShortestPath","fromItem","toItem","weight","path2","to2","paletteItem","lineColor","color","highlightLinesColor","lineWidth","highlightLinesWidth","lineType","highlightLinesType","fillColor","opacity","polyline","getPolyline","edge","clone","mergeTo","addInverted","showArrows","parentsArrowId","childrenArrowId","addArrow","arrowPolyline","polylinesBuffer"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,wCAA5B;AACA,OAAOC,WAAP,MAAwB,oCAAxB;AACA,SAASC,MAAT,EAAiBC,UAAjB,QAAmC,aAAnC;AAEA,eAAe,SAASC,+BAAT,CAAyCC,WAAzC,EAAsDC,oBAAtD,EAA4EC,iCAA5E,EAA+GC,oBAA/G,EAAqIC,UAArI,EAAiJ;AAC9J,WAASC,OAAT,GAAmB;AACjB,QAAIC,KAAK,GAAGH,oBAAoB,CAACI,QAArB,EAAZ;AAAA,QACEC,gBAAgB,GAAGP,oBAAoB,CAACQ,UAArB,EADrB;AAAA,QAEEC,WAAW,GAAGR,iCAAiC,CAACS,cAAlC,EAFhB;AAAA,QAGEC,QAAQ,GAAGZ,WAAW,EAHxB;;AAKA,YAAQI,UAAR;AACE,WAAKN,UAAU,CAACe,UAAhB;AAA2B;AACzBD,QAAAA,QAAQ,CAACE,KAAT,CAAe,aAAf,EAA8BjB,MAAM,CAACkB,kCAArC;AACA;;AACF,WAAKjB,UAAU,CAACkB,UAAhB;AAA2B;AACzBJ,QAAAA,QAAQ,CAACE,KAAT,CAAe,aAAf,EAA8BjB,MAAM,CAACoB,kCAArC;AACA;AANJ;;AASAC,IAAAA,eAAe,CAACN,QAAD,EAAWJ,gBAAX,EAA6BE,WAA7B,EAA0CJ,KAA1C,CAAf;AAEA,WAAO,KAAP;AACD;;AAED,WAASY,eAAT,CAAyBN,QAAzB,EAAmCJ,gBAAnC,EAAqDE,WAArD,EAAkEJ,KAAlE,EAAyE;AACvE,QAAIa,KAAJ,EAAWC,GAAX,EACEC,MADF,EACUC,IADV,EAEEC,MAFF,EAEUC,IAFV,EAGEC,WAHF,EAGeC,UAHf,EAIEC,QAJF,EAKEC,IALF,EAMEC,KANF,EAOEC,aAPF,EAQEC,gBARF,EASEC,KATF,EASSC,MATT,EAUEC,IAVF,EAUQC,EAVR;;AAYA,QAAIzB,WAAW,CAAC0B,MAAZ,GAAqB,CAAzB,EAA4B;AAC1BH,MAAAA,MAAM,GAAG,IAAItC,eAAJ,EAAT;;AAEA,cAAQS,UAAR;AACE,aAAKN,UAAU,CAACe,UAAhB;AAA2B;AACzBmB,UAAAA,KAAK,GAAGpB,QAAQ,CAACyB,QAAT,CAAkB,aAAlB,EAAiCxC,MAAM,CAACkB,kCAAxC,CAAR;AACA;;AACF,aAAKjB,UAAU,CAACkB,UAAhB;AAA2B;AACzBgB,UAAAA,KAAK,GAAGpB,QAAQ,CAACyB,QAAT,CAAkB,aAAlB,EAAiCxC,MAAM,CAACoB,kCAAxC,CAAR;AACA;AANJ;AASA;;;AACA,UAAIqB,KAAK,GAAG,EAAZ;;AACA,WAAKnB,KAAK,GAAG,CAAR,EAAWC,GAAG,GAAGV,WAAW,CAAC0B,MAAlC,EAA0CjB,KAAK,GAAGC,GAAlD,EAAuDD,KAAK,IAAI,CAAhE,EAAmE;AACjEY,QAAAA,gBAAgB,GAAGrB,WAAW,CAACS,KAAD,CAA9B;;AACA,YAAIY,gBAAgB,CAACF,KAAjB,IAA0B,IAA1B,IAAkCE,gBAAgB,CAACF,KAAjB,CAAuBO,MAAvB,GAAgC,CAAtE,EAAyE;AACvEP,UAAAA,KAAK,GAAGE,gBAAgB,CAACF,KAAjB,CAAuBU,KAAvB,CAA6B,CAA7B,CAAR;AACAd,UAAAA,WAAW,GAAGI,KAAK,CAAC,CAAD,CAAnB;;AACA,cAAIvB,KAAK,CAACkC,OAAN,CAAcf,WAAd,CAAJ,EAAgC;AAC9B,iBAAKJ,MAAM,GAAG,CAAT,EAAYC,IAAI,GAAGO,KAAK,CAACO,MAA9B,EAAsCf,MAAM,GAAGC,IAA/C,EAAqDD,MAAM,IAAI,CAA/D,EAAkE;AAChEK,cAAAA,UAAU,GAAGG,KAAK,CAACR,MAAD,CAAlB;;AACA,kBAAIf,KAAK,CAACkC,OAAN,CAAcd,UAAd,CAAJ,EAA+B;AAC7B,oBAAIY,KAAK,CAACG,cAAN,CAAqBhB,WAArB,CAAJ,EAAuC;AACrCa,kBAAAA,KAAK,CAACb,WAAD,CAAL,CAAmBiB,IAAnB,CAAwBhB,UAAxB;AACD,iBAFD,MAEO;AACLY,kBAAAA,KAAK,CAACb,WAAD,CAAL,GAAqB,CAACC,UAAD,CAArB;AACD;;AACDD,gBAAAA,WAAW,GAAGC,UAAd;AACD;AACF;AACF;AACF;AACF;AAED;;;AACA,UAAIiB,KAAK,GAAG,EAAZ;;AACA,WAAKT,IAAL,IAAaI,KAAb,EAAoB;AAClBK,QAAAA,KAAK,CAACT,IAAD,CAAL,GAAc,EAAd;;AACA,YAAII,KAAK,CAACG,cAAN,CAAqBP,IAArB,CAAJ,EAAgC;AAC9B5B,UAAAA,KAAK,CAACsC,eAAN,CAAsB,IAAtB,EAA4BV,IAA5B,EAAkCI,KAAK,CAACJ,IAAD,CAAvC,EAA+C,UAAUJ,aAAV,EAAyBe,QAAzB,EAAmCC,MAAnC,EAA2C;AACxF,mBAAOhB,aAAa,CAACiB,MAArB;AACD,WAFD,EAEG,UAAUC,KAAV,EAAiBC,GAAjB,EAAsB;AACvBN,YAAAA,KAAK,CAACT,IAAD,CAAL,CAAYe,GAAZ,IAAmBD,KAAnB;AACD,WAJD,EAD8B,CAK1B;AACL;AACF;AAED;;;AACA,WAAK7B,KAAK,GAAG,CAAR,EAAWC,GAAG,GAAGV,WAAW,CAAC0B,MAAlC,EAA0CjB,KAAK,GAAGC,GAAlD,EAAuDD,KAAK,IAAI,CAAhE,EAAmE;AACjEY,QAAAA,gBAAgB,GAAGrB,WAAW,CAACS,KAAD,CAA9B;AAEA,YAAI+B,WAAW,GAAG,IAAItD,WAAJ,CAAgB;AAChCuD,UAAAA,SAAS,EAAGpB,gBAAgB,CAACqB,KAAjB,IAA0B,IAA1B,GAAiCrB,gBAAgB,CAACqB,KAAlD,GAA0D5C,gBAAgB,CAAC6C,mBADvD;AAEhCC,UAAAA,SAAS,EAAGvB,gBAAgB,CAACuB,SAAjB,IAA8B,IAA9B,GAAqCvB,gBAAgB,CAACuB,SAAtD,GAAkE9C,gBAAgB,CAAC+C,mBAF/D;AAGhCC,UAAAA,QAAQ,EAAGzB,gBAAgB,CAACyB,QAAjB,IAA6B,IAA7B,GAAoCzB,gBAAgB,CAACyB,QAArD,GAAgEhD,gBAAgB,CAACiD,kBAH5D;AAIhCC,UAAAA,SAAS,EAAE,IAJqB;AAKhCC,UAAAA,OAAO,EAAE5B,gBAAgB,CAAC4B;AALM,SAAhB,CAAlB;AAOA,YAAIC,QAAQ,GAAG3B,MAAM,CAAC4B,WAAP,CAAmBX,WAAnB,CAAf;;AAEA,YAAInB,gBAAgB,CAACF,KAAjB,IAA0B,IAA1B,IAAkCE,gBAAgB,CAACF,KAAjB,CAAuBO,MAAvB,GAAgC,CAAtE,EAAyE;AACvEP,UAAAA,KAAK,GAAGE,gBAAgB,CAACF,KAAjB,CAAuBU,KAAvB,CAA6B,CAA7B,CAAR;AACAd,UAAAA,WAAW,GAAGI,KAAK,CAAC,CAAD,CAAnB;;AAEA,cAAIvB,KAAK,CAACkC,OAAN,CAAcf,WAAd,CAAJ,EAAgC;AAC9B,iBAAKJ,MAAM,GAAG,CAAT,EAAYC,IAAI,GAAGO,KAAK,CAACO,MAA9B,EAAsCf,MAAM,GAAGC,IAA/C,EAAqDD,MAAM,IAAI,CAA/D,EAAkE;AAChEK,cAAAA,UAAU,GAAGG,KAAK,CAACR,MAAD,CAAlB;;AACA,kBAAIf,KAAK,CAACkC,OAAN,CAAcd,UAAd,CAAJ,EAA+B;AAC7BE,gBAAAA,IAAI,GAAGe,KAAK,CAAClB,WAAD,CAAL,CAAmBC,UAAnB,KAAkC,EAAzC;;AACA,qBAAKH,MAAM,GAAGK,IAAI,CAACQ,MAAL,GAAc,CAA5B,EAA+Bb,MAAM,IAAI,CAAzC,EAA4CA,MAAM,IAAI,CAAtD,EAAyD;AACvDW,kBAAAA,IAAI,GAAGN,IAAI,CAACL,MAAM,GAAG,CAAV,CAAX;AACAY,kBAAAA,EAAE,GAAGP,IAAI,CAACL,MAAD,CAAT;AACAO,kBAAAA,aAAa,GAAGxB,KAAK,CAACwD,IAAN,CAAW5B,IAAX,EAAiBC,EAAjB,CAAhB;;AACA,sBAAIL,aAAa,CAACI,IAAd,IAAsBA,IAA1B,EAAgC;AAC9BJ,oBAAAA,aAAa,CAAC8B,QAAd,CAAuBG,KAAvB,GAA+BC,OAA/B,CAAuCJ,QAAvC;AACD,mBAFD,MAEO;AACLA,oBAAAA,QAAQ,CAACK,WAAT,CAAqBnC,aAAa,CAAC8B,QAAd,CAAuBG,KAAvB,EAArB;AACD;;AACD,sBAAIhC,gBAAgB,CAACmC,UAArB,EAAiC;AAC/B,wBAAI/B,EAAE,IAAIL,aAAa,CAACqC,cAApB,IAAsChC,EAAE,IAAIL,aAAa,CAACsC,eAA9D,EAA+E;AAC7ER,sBAAAA,QAAQ,CAACS,QAAT,CAAkBtC,gBAAgB,CAACuB,SAAnC,EAA8C,UAAUgB,aAAV,EAAyB;AACrEA,wBAAAA,aAAa,CAACN,OAAd,CAAsB/B,MAAM,CAAC4B,WAAP,CAAmBS,aAAa,CAACpB,WAAjC,CAAtB;AACD,uBAFD,EAD6E,CAGzE;AACL;AACF;AACF;;AAEDzB,gBAAAA,WAAW,GAAGC,UAAd;AACD;AACF;AACF;AACF;AACF;;AAEDd,MAAAA,QAAQ,CAAC2D,eAAT,CAAyBtC,MAAzB;AACD;AACF;;AAED,SAAO;AACL5B,IAAAA,OAAO,EAAEA;AADJ,GAAP;AAGD;AAAA","sourcesContent":["import PolylinesBuffer from '../../graphics/structs/PolylinesBuffer';\nimport PaletteItem from '../../graphics/structs/PaletteItem';\nimport { Layers, ZOrderType } from '../../enums';\n\nexport default function DrawHighlightPathAnnotationTask(getGraphics, connectorsOptionTask, highlightPathAnnotationOptionTask, connectionsGraphTask, zOrderType) {\n  function process() {\n    var graph = connectionsGraphTask.getGraph(),\n      highlightOptions = connectorsOptionTask.getOptions(),\n      annotations = highlightPathAnnotationOptionTask.getAnnotations(),\n      graphics = getGraphics();\n\n    switch (zOrderType) {\n      case ZOrderType.Background://ignore jslint\n        graphics.reset(\"placeholder\", Layers.BackgroundHighlightPathAnnotations);\n        break;\n      case ZOrderType.Foreground://ignore jslint\n        graphics.reset(\"placeholder\", Layers.ForegroundHighlightPathAnnotations);\n        break;\n    }\n\n    drawAnnotations(graphics, highlightOptions, annotations, graph);\n\n    return false;\n  }\n\n  function drawAnnotations(graphics, highlightOptions, annotations, graph) {\n    var index, len,\n      index2, len2,\n      index3, len3,\n      firstItemId, nextItemId,\n      treeItem,\n      path,\n      items,\n      connectorEdge,\n      annotationConfig,\n      panel, buffer,\n      from, to;\n\n    if (annotations.length > 0) {\n      buffer = new PolylinesBuffer();\n\n      switch (zOrderType) {\n        case ZOrderType.Background://ignore jslint\n          panel = graphics.activate(\"placeholder\", Layers.BackgroundHighlightPathAnnotations);\n          break;\n        case ZOrderType.Foreground://ignore jslint\n          panel = graphics.activate(\"placeholder\", Layers.ForegroundHighlightPathAnnotations);\n          break;\n      }\n\n      /* group path segments by from node */\n      var pairs = {};\n      for (index = 0, len = annotations.length; index < len; index += 1) {\n        annotationConfig = annotations[index];\n        if (annotationConfig.items != null && annotationConfig.items.length > 0) {\n          items = annotationConfig.items.slice(0);\n          firstItemId = items[0];\n          if (graph.hasNode(firstItemId)) {\n            for (index2 = 1, len2 = items.length; index2 < len2; index2 += 1) {\n              nextItemId = items[index2];\n              if (graph.hasNode(nextItemId)) {\n                if (pairs.hasOwnProperty(firstItemId)) {\n                  pairs[firstItemId].push(nextItemId);\n                } else {\n                  pairs[firstItemId] = [nextItemId];\n                }\n                firstItemId = nextItemId;\n              }\n            }\n          }\n        }\n      }\n\n      /* get shortest paths */\n      var paths = {};\n      for (from in pairs) {\n        paths[from] = {};\n        if (pairs.hasOwnProperty(from)) {\n          graph.getShortestPath(this, from, pairs[from], function (connectorEdge, fromItem, toItem) {\n            return connectorEdge.weight;\n          }, function (path2, to2) {\n            paths[from][to2] = path2;\n          }); //ignore jslint\n        }\n      }\n\n      /* trace annotations */\n      for (index = 0, len = annotations.length; index < len; index += 1) {\n        annotationConfig = annotations[index];\n\n        var paletteItem = new PaletteItem({\n          lineColor: (annotationConfig.color != null ? annotationConfig.color : highlightOptions.highlightLinesColor),\n          lineWidth: (annotationConfig.lineWidth != null ? annotationConfig.lineWidth : highlightOptions.highlightLinesWidth),\n          lineType: (annotationConfig.lineType != null ? annotationConfig.lineType : highlightOptions.highlightLinesType),\n          fillColor: null,\n          opacity: annotationConfig.opacity\n        });\n        var polyline = buffer.getPolyline(paletteItem);\n\n        if (annotationConfig.items != null && annotationConfig.items.length > 0) {\n          items = annotationConfig.items.slice(0);\n          firstItemId = items[0];\n\n          if (graph.hasNode(firstItemId)) {\n            for (index2 = 1, len2 = items.length; index2 < len2; index2 += 1) {\n              nextItemId = items[index2];\n              if (graph.hasNode(nextItemId)) {\n                path = paths[firstItemId][nextItemId] || [];\n                for (index3 = path.length - 2; index3 >= 0; index3 -= 1) {\n                  from = path[index3 + 1];\n                  to = path[index3];\n                  connectorEdge = graph.edge(from, to);\n                  if (connectorEdge.from == from) {\n                    connectorEdge.polyline.clone().mergeTo(polyline);\n                  } else {\n                    polyline.addInverted(connectorEdge.polyline.clone());\n                  }\n                  if (annotationConfig.showArrows) {\n                    if (to == connectorEdge.parentsArrowId || to == connectorEdge.childrenArrowId) {\n                      polyline.addArrow(annotationConfig.lineWidth, function (arrowPolyline) {\n                        arrowPolyline.mergeTo(buffer.getPolyline(arrowPolyline.paletteItem));\n                      }); //ignore jslint\n                    }\n                  }\n                }\n\n                firstItemId = nextItemId;\n              }\n            }\n          }\n        }\n      }\n\n      graphics.polylinesBuffer(buffer);\n    }\n  }\n\n  return {\n    process: process\n  };\n};"]},"metadata":{},"sourceType":"module"}