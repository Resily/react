{"ast":null,"code":"import { isObject, cloneObject, isEmptyObject } from '../common';\n/**\n * Creates tree structure\n * @class Tree\n * \n * @param {Tree} source A source tree structure to clone properties from\n * @returns {Tree} Returns new tree structure\n */\n\nexport default function Tree(source) {\n  var _nodes = {},\n      // objects attached to nodes\n  _parents = {},\n      // parent node id for every node id. Both of them should exists in the tree.\n  _children = {},\n      // children node ids for every node id. All children and node itself should be in the tree.\n  _roots = {},\n      // id of non existing parent. If parent does not exists in the tree this hash contains its id.\n  _rootChildren = {},\n      // children of non existing parent. If parent id does not exists in the tree this collection contains it existing children.\n\n  /** @constant\n    @type {number}\n    @default\n  */\n  BREAK = 1,\n\n  /** @constant\n    @type {number}\n    @default\n  */\n  SKIP = 2;\n\n  _init(source);\n\n  function _init(source) {\n    if (isObject(source)) {\n      _nodes = cloneObject(source.nodes, true);\n      _parents = cloneObject(source.parents, true);\n      _children = cloneObject(source.children, false);\n      _roots = cloneObject(source.roots, false);\n      _rootChildren = cloneObject(source.rootChildren, true);\n    }\n  }\n  /**\n   * Callback for iterating tree nodes\n   * \n   * @callback onTreeItemCallback\n   * @param {string} itemid The node id\n   * @param {object} item The node\n   * @returns {boolean} Returns true to break the loop\n   */\n\n  /**\n   * Loops through nodes of tree structure\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {onTreeItemCallback} onItem Callback function to call for every tree node \n   */\n\n\n  function loop(thisArg, onItem) {\n    var item;\n\n    if (onItem != null) {\n      for (item in _nodes) {\n        if (_nodes.hasOwnProperty(item)) {\n          if (onItem.call(thisArg, item, _nodes[item])) {\n            break;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Callback for iterating the tree nodes level by level\n   * \n   * @callback onTreeItemWithLevelCallback\n   * @param {string} nodeid The node id\n   * @param {object} node The node context object\n   * @param {number} levelIndex The node level index\n   * @returns {number} Returns BREAK to break the loop and exit. Returns SKIP to skip node's branch traversing.\n   */\n\n  /**\n   * Loops through child nodes of the tree structure level by level\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {string} arg0 The node id to start children traversing\n   * @param {onTreeItemWithLevelCallback} arg1 Callback function to call for every child node \n   */\n\n\n  function loopLevels(thisArg, arg0, arg1) {\n    var levelIndex = 0,\n        items = [],\n        itemid,\n        onItem,\n        newItems,\n        key,\n        index,\n        len;\n\n    switch (arguments.length) {\n      case 2:\n        onItem = arg0;\n        break;\n\n      case 3:\n        itemid = arg0;\n        onItem = arg1;\n        break;\n    }\n\n    if (onItem != null) {\n      if (itemid == null) {\n        for (key in _rootChildren) {\n          if (_rootChildren.hasOwnProperty(key)) {\n            items = items.concat(_rootChildren[key]);\n          }\n        }\n      } else {\n        if (_children[itemid] != null) {\n          items = items.concat(_children[itemid]);\n        }\n      }\n\n      while (items.length > 0) {\n        newItems = [];\n\n        for (index = 0, len = items.length; index < len; index += 1) {\n          itemid = items[index];\n\n          switch (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex)) {\n            case BREAK:\n              newItems = [];\n              break;\n\n            case SKIP:\n              break;\n\n            default:\n              if (_children[itemid] != null) {\n                newItems = newItems.concat(_children[itemid]);\n              }\n\n              break;\n          }\n        }\n\n        items = newItems;\n        levelIndex += 1;\n      }\n    }\n  }\n  /**\n   * Callback for iterating nodes and providing parent in parameters\n   * \n   * @callback onTreeItemWithParentCallback\n   * @param {string} nodeid The node id\n   * @param {object} node The node context object\n   * @param {string} parentid The parent node id\n   * @param {object} parent The parent node context object\n   * @returns {number} Returns BREAK to break the loop and exit. Returns SKIP to skip node's branch traversing.\n   */\n\n  /**\n   * Traverse tree structure in post order.\n   * Children first - parent last\n   * @param {Object} thisArg The callback function invocation context\n   * @param {onTreeItemWithParentCallback} onItem Callback function to call for every node \n   */\n\n\n  function loopPostOrder(thisArg, onItem) {\n    var stack = [],\n        nodeid,\n        key,\n        index,\n        prevParent,\n        children;\n\n    if (onItem != null) {\n      for (key in _rootChildren) {\n        if (_rootChildren.hasOwnProperty(key)) {\n          stack = stack.concat(_rootChildren[key]);\n        }\n      }\n\n      while (stack.length > 0) {\n        nodeid = stack[stack.length - 1];\n\n        if (nodeid != prevParent && (children = _children[nodeid]) != null) {\n          for (index = children.length - 1; index >= 0; index -= 1) {\n            stack.push(children[index]);\n          }\n        } else {\n          stack.pop();\n          prevParent = _parents[nodeid];\n\n          if (onItem.call(thisArg, nodeid, _nodes[nodeid], prevParent, _nodes[prevParent])) {\n            break;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Traverse tree structure in pre order.\n   * Parent first - children next\n   * @param {Object} thisArg The callback function invocation context\n   * @param {onTreeItemWithParentCallback} onItem A callback function to call for every node \n   */\n\n\n  function loopPreOrder(thisArg, onItem) {\n    var stack = [],\n        nodeid,\n        key,\n        index,\n        parentid,\n        prevParent,\n        children;\n\n    if (onItem != null) {\n      for (key in _rootChildren) {\n        if (_rootChildren.hasOwnProperty(key)) {\n          stack = stack.concat(_rootChildren[key]);\n        }\n      }\n\n      while (stack.length > 0) {\n        nodeid = stack[stack.length - 1];\n\n        if (nodeid != prevParent) {\n          parentid = _parents[nodeid];\n\n          if (onItem.call(thisArg, nodeid, _nodes[nodeid], parentid, _nodes[parentid])) {\n            break;\n          }\n        }\n\n        if (nodeid != prevParent && (children = _children[nodeid]) != null) {\n          for (index = children.length - 1; index >= 0; index -= 1) {\n            stack.push(children[index]);\n          }\n        } else {\n          stack.pop();\n          prevParent = _parents[nodeid];\n        }\n      }\n    }\n  }\n  /**\n   * Callback for iterating nodes in euler walk order\n   * \n   * @callback onItemEulerWalkCallback\n   * @param {string} nodeid The node id\n   * @param {object} node Context object of the node\n   * @param {number} level The node's level\n   * @returns {boolean} Returns true to break the iteration of nodes and exit.\n   */\n\n  /**\n   * Loops tree nodes in \"Euler Walk\" order\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {onItemEulerWalkCallback} onItem Callback function to call for every node \n   */\n\n\n  function loopEulerWalk(thisArg, onItem) {\n    var stack = [],\n        nodeid,\n        levels = [],\n        level = 0,\n        key,\n        index,\n        len,\n        prevParent,\n        children;\n\n    if (onItem != null) {\n      for (key in _rootChildren) {\n        if (_rootChildren.hasOwnProperty(key)) {\n          children = _rootChildren[key];\n\n          for (index = 0, len = children.length; index < len; index += 1) {\n            stack.push(children[index]);\n            levels.push(0);\n          }\n        }\n      }\n\n      while (stack.length > 0) {\n        index = stack.length - 1;\n        nodeid = stack[index];\n        level = levels[index];\n\n        if (onItem.call(thisArg, nodeid, _nodes[nodeid], level)) {\n          break;\n        }\n\n        if (nodeid != prevParent && (children = _children[nodeid]) != null) {\n          for (index = children.length - 1; index >= 0; index -= 1) {\n            stack.push(children[index]);\n            levels.push(level + 1);\n\n            if (index > 0) {\n              stack.push(nodeid);\n              levels.push(level);\n            }\n          }\n        } else {\n          stack.pop();\n          levels.pop();\n          prevParent = _parents[nodeid];\n        }\n      }\n    }\n  }\n  /**\n   * Callback function to return pairs of nodes\n   * \n   * @callback onZipUpPairCallback\n   * @param {string} firstNodeId First node id\n   * @param {string} firstParentId Parent id of the first node\n   * @param {string} secondNodeid Second node id\n   * @param {string} secondParentId Parent id of the second node\n   * @returns {boolean} Returns true to break the iteration of nodes and exit.\n   */\n\n  /**\n   * Iterates hierarchy nodes by pairs starting with given pair of start and second nodes and up to the root of the hierarchy.\n   * Breaks iteration when callback function returns true.\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {string} firstNodeId The first node to start iteration\n   * @param {string} secondNodeid The second node to start iteration\n   * @param {onZipUpPairCallback} onZip Callback function to call for every pair of nodes on the way up in the tree structure\n   */\n\n\n  function zipUp(thisArg, firstNodeId, secondNodeid, onZip) {\n    var firstParentId, secondParentId;\n\n    if (onZip != null) {\n      while (firstNodeId != null && secondNodeid != null && firstNodeId != secondNodeid) {\n        firstParentId = _parents[firstNodeId];\n        secondParentId = _parents[secondNodeid];\n\n        if (onZip.call(thisArg, firstNodeId, firstParentId, secondNodeid, secondParentId)) {\n          break;\n        }\n\n        firstNodeId = firstParentId;\n        secondNodeid = secondParentId;\n      }\n    }\n  }\n  /**\n   * Loops parents up to the root of the hierarchy starting with the given node.\n   * Breaks iteration if callback function returns true.\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {string} nodeid The node id to start iteration from\n   * @param {onTreeItemCallback} onItem Callback function to call for every parent node\n   * @param {boolean} includingStartItem If true the first call to callback function is made with start node id\n   */\n\n\n  function loopParents(thisArg, nodeid, onItem, includingStartItem) {\n    // onItem(nodeid, node)\n    var parentid = nodeid;\n\n    if (_nodes[parentid] != null) {\n      if (onItem != null) {\n        if (includingStartItem === true) {\n          if (onItem.call(thisArg, parentid, _nodes[parentid])) {\n            return;\n          }\n        }\n\n        while ((parentid = _parents[parentid]) != null) {\n          if (onItem.call(thisArg, parentid, _nodes[parentid])) {\n            break;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Callback function to loop through children of the given node\n   * \n   * @callback onTreeChildItemCallback\n   * @param {string} nodeid Child node id\n   * @param {object} node Context object of the child node\n   * @param {number} index Index of the child node\n   * @param {number} lastIndex Index of the last child\n   * @returns {boolean} Returns true to break the iteration of nodes and exit.\n   */\n\n  /**\n   * Loops immediate children of the given node.\n   * Breaks iteration if callback function returns true.\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {string} nodeid The parent node id to loop children of\n   * @param {onTreeChildItemCallback} onItem Callback function to call for every child node\n   */\n\n\n  function loopChildren(thisArg, nodeid, onItem) {\n    // onItem(nodeid, node, index, lastIndex)\n    var items, itemid, index, len;\n\n    if (_nodes[nodeid] != null) {\n      items = _children[nodeid];\n\n      if (items != null) {\n        for (index = 0, len = items.length; index < len; index += 1) {\n          itemid = items[index];\n\n          if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Callback function to loop through range of children for the given node\n   * \n   * @callback onTreeNodeWithIndexItemCallback\n   * @param {string} nodeid Child node id\n   * @param {object} node Context object of the child node\n   * @param {number} index Index of the child node\n   * @returns {boolean} Returns true to break the iteration of nodes and exit.\n   */\n\n  /**\n   * Loops range of immediate children of the given node.\n   * Breaks iteration if callback function returns true.\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {string} nodeid The parent node id to loop children of\n   * @param {number} fromIndex Start index of iteration\n   * @param {number} toIndex End index of iteration\n   * @param {onTreeNodeWithIndexItemCallback} onItem Callback function to call for every child node\n   */\n\n\n  function loopChildrenRange(thisArg, nodeid, fromIndex, toIndex, onItem) {\n    var items, itemid, index, len;\n\n    if (_nodes[nodeid] != null) {\n      items = _children[nodeid];\n\n      if (items != null) {\n        if (fromIndex < toIndex) {\n          fromIndex = Math.max(fromIndex, 0);\n          toIndex = Math.min(toIndex, items.length - 1);\n\n          for (index = fromIndex; index <= toIndex; index += 1) {\n            itemid = items[index];\n\n            if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {\n              break;\n            }\n          }\n        } else {\n          fromIndex = Math.min(fromIndex, items.length - 1);\n          toIndex = Math.max(0, toIndex);\n\n          for (index = fromIndex; index >= toIndex; index -= 1) {\n            itemid = items[index];\n\n            if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Loops immediate children of the given node in reversed order.\n   * Breaks iteration if callback function returns true.\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {string} nodeid The parent node id to loop children of\n   * @param {onTreeChildItemCallback} onItem Callback function to call for every child node\n   */\n\n\n  function loopChildrenReversed(thisArg, nodeid, onItem) {\n    var items, itemid, index, lastIndex;\n\n    if (_nodes[nodeid] != null) {\n      items = _children[nodeid];\n      lastIndex = items.length - 1;\n\n      if (items != null) {\n        for (index = lastIndex; index >= 0; index -= 1) {\n          itemid = items[index];\n\n          if (onItem.call(thisArg, itemid, _nodes[itemid], index, lastIndex)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Orders children of the given node\n   * \n   * @param {string} nodeid The node id of the parent node which children should be ordered in the tree structure\n   * @param {string[]} children Collection of ordered children\n   */\n\n\n  function arrangeChildren(nodeid, children) {\n    var childid, index, len;\n    children = children.slice(0);\n\n    if (_nodes[nodeid] != null) {\n      if (_children[nodeid] != null) {\n        if (_children[nodeid].length == children.length) {\n          for (index = 0, len = children.length; index < len; index += 1) {\n            childid = children[index];\n\n            if (_parents[childid] != nodeid) {\n              throw \"Child \" + childid + \" does not belong to given node!\";\n            }\n          }\n\n          _children[nodeid] = children;\n        } else {\n          throw \"Collections of children don't match each other!\";\n        }\n      } else {\n        if (children.length > 0) {\n          throw \"Collections of children don't match each other!\";\n        }\n      }\n    }\n  }\n  /**\n   * Adds new tree item\n   * @param {string} parentid Parent id\n   * @param {string} nodeid New node id\n   * @param {object} node Context object of the new node\n   * @param {number} position Position of the new node in the collection of children\n   */\n\n\n  function add(parentid, nodeid, node, position) {\n    var index, len, children, childid;\n\n    if (_nodes[nodeid] != null) {\n      throw \"Node already exists\";\n    }\n\n    if (nodeid != null && node != null && _nodes[nodeid] == null) {\n      if (_nodes[parentid] != null) {\n        _parents[nodeid] = parentid; // existing parent\n\n        if (_children[parentid] != null) {\n          if (position == null) {\n            _children[parentid].push(nodeid);\n          } else {\n            _children[parentid].splice(position, 0, nodeid);\n          }\n        } else {\n          _children[parentid] = [nodeid];\n        }\n      } else {\n        _roots[nodeid] = parentid; // missing parent\n\n        if (_rootChildren[parentid] != null) {\n          if (position == null) {\n            _rootChildren[parentid].push(nodeid);\n          } else {\n            _rootChildren[parentid].splice(position, 0, nodeid);\n          }\n        } else {\n          _rootChildren[parentid] = [nodeid];\n        }\n      }\n\n      _nodes[nodeid] = node;\n\n      if (_rootChildren[nodeid] != null) {\n        _children[nodeid] = _rootChildren[nodeid];\n        delete _rootChildren[nodeid];\n        children = _children[nodeid];\n\n        for (index = 0, len = children.length; index < len; index += 1) {\n          childid = children[index];\n          delete _roots[childid];\n          _parents[childid] = nodeid;\n        }\n      }\n    }\n  }\n  /**\n   * Inserts bundle node into the tree structure. The new bundle node becomes only child node of the parent node.\n   * All immediate children of the parent node become children of the inserted bundle node.\n   * \n   * @param {string} nodeid Parent node id\n   * @param {string} bundleid New bundle node id\n   * @param {object} bundle Context object of the bundle node\n   */\n\n\n  function insert(nodeid, bundleid, bundle) {\n    if (_nodes[nodeid] != null && bundleid != null && _nodes[bundleid] == null && bundle != null) {\n      _nodes[bundleid] = bundle;\n\n      if (_children[nodeid] != null) {\n        _children[bundleid] = _children[nodeid];\n      }\n\n      _children[nodeid] = [bundleid];\n      loopChildren(this, bundleid, function (childid, node, index) {\n        _parents[childid] = bundleid;\n      });\n      _parents[bundleid] = nodeid;\n    }\n  }\n  /**\n   * Moves children form one node to another.\n   * \n   * @param {string} fromNodeid Source node node id\n   * @param {string} toNodeId Destination node id\n   */\n\n\n  function moveChildren(fromNodeid, toNodeId) {\n    if (_nodes[fromNodeid] != null && _nodes[toNodeId] != null && fromNodeid != toNodeId) {\n      if (_children[fromNodeid] != null) {\n        loopChildren(this, fromNodeid, function (childid, node, index) {\n          _parents[childid] = toNodeId;\n        });\n\n        if (_children[toNodeId] != null) {\n          _children[toNodeId] = _children[toNodeId].concat(_children[fromNodeid]);\n        } else {\n          _children[toNodeId] = _children[fromNodeid];\n        }\n\n        delete _children[fromNodeid];\n      }\n    }\n  }\n  /**\n   * Return true if structure has nodes\n   * \n   * @returns {boolean} Returns true if structure has nodes\n   */\n\n\n  function hasNodes() {\n    return !isEmptyObject(_rootChildren);\n  }\n  /**\n   * Returns parent node id\n   * \n   * @param {string} nodeid Node id\n   * @returns {string} Returns parent node id\n   */\n\n\n  function parentid(nodeid) {\n    var result = null;\n\n    if (_parents[nodeid] != null) {\n      result = _parents[nodeid];\n    }\n\n    return result;\n  }\n  /**\n   * Returns context object of the parent node\n   * \n   * @param {string} nodeid Node id\n   * @returns {object} Returns context object of the  parent node\n   */\n\n\n  function parent(nodeid) {\n    var result = null;\n\n    if (_parents[nodeid] != null) {\n      result = _nodes[_parents[nodeid]];\n    }\n\n    return result;\n  }\n  /**\n   * Returns true if node has children\n   * \n   * @param {string} nodeid Node id\n   * @returns {boolean} Returns true if node has children\n   */\n\n\n  function hasChildren(nodeid) {\n    return _children[nodeid] != null;\n  }\n  /**\n   * Returns number of children\n   * \n   * @param {string} nodeid Node id\n   * @returns {number} Returns number of child nodes\n   */\n\n\n  function countChildren(nodeid) {\n    return _children[nodeid] != null ? _children[nodeid].length : 0;\n  }\n  /**\n   * Returns number of siblings\n   * \n   * @param {string} nodeid Node id\n   * @returns {number} Returns number of siblings\n   */\n\n\n  function countSiblings(nodeid) {\n    var parent = parentid(nodeid);\n    return parent != null ? _children[parent].length : 0;\n  }\n  /**\n   * Returns index of the node in the children's collection\n   * \n   * @param {string} nodeid Node id\n   * @returns {number} Returns node index\n   */\n\n\n  function indexOf(nodeid) {\n    var parent = parentid(nodeid);\n    return parent != null ? _children[parent].findIndex(function (itemid) {\n      return itemid === nodeid;\n    }) : null;\n  }\n  /**\n   * Returns child node by index in the children's collection\n   * \n   * @param {string} nodeid Node id\n   * @param {number} index Child index\n   * @returns {object} Returns child node\n   */\n\n\n  function getChild(parentid, index) {\n    var result = null,\n        children;\n\n    if ((children = _children[parentid]) != null) {\n      result = _nodes[children[index]];\n    }\n\n    return result;\n  }\n\n  function _splice(collection, nodeid) {\n    var index,\n        len = collection.length;\n\n    for (index = 0; index < len; index += 1) {\n      if (collection[index] == nodeid) {\n        collection.splice(index, 1);\n        return len - 1;\n      }\n    }\n\n    return len;\n  }\n  /**\n   * Adds existing node to the children of the parent node\n   * \n   * @param {string} parentid Parent Node id\n   * @param {string} nodeid Node id\n   */\n\n\n  function adopt(parentid, nodeid) {\n    if (_nodes[parentid] != null && _nodes[nodeid] != null) {\n      if (parentid != nodeid) {\n        if (_roots.hasOwnProperty(nodeid)) {\n          if (!_splice(_rootChildren[_roots[nodeid]], nodeid)) {\n            delete _rootChildren[_roots[nodeid]];\n          }\n\n          delete _roots[nodeid];\n        }\n\n        if (_parents.hasOwnProperty(nodeid)) {\n          if (!_splice(_children[_parents[nodeid]], nodeid)) {\n            delete _children[_parents[nodeid]];\n          }\n        }\n\n        _parents[nodeid] = parentid;\n\n        if (_children[parentid] != null) {\n          _children[parentid].push(nodeid);\n        } else {\n          _children[parentid] = [nodeid];\n        }\n      } else {\n        throw \"Item cannot be parent of itself!\";\n      }\n    } else {\n      throw \"Both parent and child should be in hierarchy!\";\n    }\n  }\n  /**\n   * Returns context object\n   * @param {string} nodeid Node id\n   * @returns {object} Context object of the node\n   */\n\n\n  function node(nodeid) {\n    return _nodes[nodeid];\n  }\n  /**\n   * Validates internal data integrity of the structure\n   * \n   * @returns {boolean} Returns true if structure pass validation\n   */\n\n\n  function validate() {\n    var result = true,\n        key;\n\n    for (key in _roots) {\n      if (_roots.hasOwnProperty(key)) {\n        if (_roots[key] != null) {\n          result = false;\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Clones tree structure\n   * \n   * @returns {tree} Returns clone of the tree\n   */\n\n\n  function clone() {\n    return Tree({\n      nodes: _nodes,\n      parents: _parents,\n      children: _children,\n      roots: _roots,\n      rootChildren: _rootChildren\n    });\n  }\n  /**\n   * Callback for iterating tree node neighbours level by level\n   * \n   * @callback onTreeItemNeighbourCallback\n   * @param {string} itemid The node id\n   * @param {object} item The node\n   * @param {number} distance The neigbour node distance from the start node\n   * @returns {number} Returns true to skip further neighbous traversing.\n   */\n\n  /**\n   * Loops through the node neighbours of the tree structure level by level\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {string} itemid The node id to start traversing neighbour nodes\n   * @param {number} distance Stop iteration of neighbours when distance exceeds the given value\n   * @param {onTreeItemNeighbourCallback} onItem A callback function to call for every neighbour node \n   */\n\n\n  function loopNeighbours(thisArg, itemid, distance, onItem) {\n    var processed = {},\n        margin = [itemid],\n        newMargin,\n        currentDistance = 0;\n\n    if (onItem != null) {\n      if (_nodes.hasOwnProperty(itemid)) {\n        processed[itemid] = true;\n\n        while (margin.length > 0) {\n          newMargin = [];\n\n          for (var index = 0, len = margin.length; index < len; index += 1) {\n            var marginid = margin[index];\n\n            if (currentDistance > 0) {\n              if (onItem.call(thisArg, marginid, _nodes[marginid], currentDistance)) {\n                return;\n              }\n            }\n\n            if (currentDistance < distance) {\n              _loopNeighbours(this, marginid, function (neighbourid, neighbour) {\n                if (!processed.hasOwnProperty(neighbourid)) {\n                  newMargin.push(neighbourid);\n                  processed[neighbourid] = true;\n                }\n              });\n            }\n          }\n\n          margin = newMargin;\n          currentDistance += 1;\n        }\n      }\n    }\n  }\n\n  function _loopNeighbours(thisArg, itemid, onItem) {\n    if (onItem != null) {\n      if (_nodes.hasOwnProperty(itemid)) {\n        /* loop parent */\n        var parentItemId = parentid(itemid);\n\n        if (parentItemId != null) {\n          if (onItem.call(thisArg, parentItemId, _nodes[parentItemId])) {\n            return;\n          }\n        }\n        /* loop siblings */\n\n\n        loopChildren(thisArg, parentItemId, function (childItemId, childItem) {\n          if (childItemId != itemid) {\n            if (onItem.call(thisArg, childItemId, childItem)) {\n              return;\n            }\n          }\n        });\n        /* loop actual children */\n\n        loopChildren(thisArg, itemid, function (childItemId, childItem) {\n          if (onItem.call(thisArg, childItemId, childItem)) {\n            return;\n          }\n        });\n      }\n    }\n  }\n\n  return {\n    loop: loop,\n    loopLevels: loopLevels,\n    loopParents: loopParents,\n    loopChildren: loopChildren,\n    loopChildrenRange: loopChildrenRange,\n    loopChildrenReversed: loopChildrenReversed,\n    loopPostOrder: loopPostOrder,\n\n    /* children first - parent last */\n    loopPreOrder: loopPreOrder,\n\n    /* parent first - children next */\n    loopEulerWalk: loopEulerWalk,\n\n    /* pre order loop with every parent revisited for every child */\n    loopNeighbours: loopNeighbours,\n\n    /* loop items by distance. Siblings are as far as parent and children */\n    zipUp: zipUp,\n    parentid: parentid,\n    parent: parent,\n    adopt: adopt,\n    moveChildren: moveChildren,\n    node: node,\n    add: add,\n    insert: insert,\n    hasNodes: hasNodes,\n    hasChildren: hasChildren,\n    countChildren: countChildren,\n    countSiblings: countSiblings,\n    indexOf: indexOf,\n    getChild: getChild,\n    arrangeChildren: arrangeChildren,\n\n    /* force validation */\n    validate: validate,\n    clone: clone,\n    // callback return codes\n    BREAK: BREAK,\n    // break loop immidiatly\n    SKIP: SKIP // skip loop of current node children \n\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/Tree.js"],"names":["isObject","cloneObject","isEmptyObject","Tree","source","_nodes","_parents","_children","_roots","_rootChildren","BREAK","SKIP","_init","nodes","parents","children","roots","rootChildren","loop","thisArg","onItem","item","hasOwnProperty","call","loopLevels","arg0","arg1","levelIndex","items","itemid","newItems","key","index","len","arguments","length","concat","loopPostOrder","stack","nodeid","prevParent","push","pop","loopPreOrder","parentid","loopEulerWalk","levels","level","zipUp","firstNodeId","secondNodeid","onZip","firstParentId","secondParentId","loopParents","includingStartItem","loopChildren","loopChildrenRange","fromIndex","toIndex","Math","max","min","loopChildrenReversed","lastIndex","arrangeChildren","childid","slice","add","node","position","splice","insert","bundleid","bundle","moveChildren","fromNodeid","toNodeId","hasNodes","result","parent","hasChildren","countChildren","countSiblings","indexOf","findIndex","getChild","_splice","collection","adopt","validate","clone","loopNeighbours","distance","processed","margin","newMargin","currentDistance","marginid","_loopNeighbours","neighbourid","neighbour","parentItemId","childItemId","childItem"],"mappings":"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","sourcesContent":["import { isObject, cloneObject, isEmptyObject } from '../common'\n/**\n * Creates tree structure\n * @class Tree\n * \n * @param {Tree} source A source tree structure to clone properties from\n * @returns {Tree} Returns new tree structure\n */\nexport default function Tree(source) {\n    var _nodes = {},        // objects attached to nodes\n      _parents = {},      // parent node id for every node id. Both of them should exists in the tree.\n      _children = {},     // children node ids for every node id. All children and node itself should be in the tree.\n      _roots = {},        // id of non existing parent. If parent does not exists in the tree this hash contains its id.\n      _rootChildren = {}, // children of non existing parent. If parent id does not exists in the tree this collection contains it existing children.\n      /** @constant\n        @type {number}\n        @default\n      */\n      BREAK = 1,\n      /** @constant\n        @type {number}\n        @default\n      */\n      SKIP = 2;\n  \n    _init(source);\n  \n    function _init(source) {\n      if (isObject(source)) {\n        _nodes = cloneObject(source.nodes, true);\n        _parents = cloneObject(source.parents, true);\n        _children = cloneObject(source.children, false);\n        _roots = cloneObject(source.roots, false);\n        _rootChildren = cloneObject(source.rootChildren, true);\n      }\n    }\n  \n    /**\n     * Callback for iterating tree nodes\n     * \n     * @callback onTreeItemCallback\n     * @param {string} itemid The node id\n     * @param {object} item The node\n     * @returns {boolean} Returns true to break the loop\n     */\n  \n    /**\n     * Loops through nodes of tree structure\n     * \n     * @param {Object} thisArg The callback function invocation context\n     * @param {onTreeItemCallback} onItem Callback function to call for every tree node \n     */\n    function loop(thisArg, onItem) {\n      var item;\n      if (onItem != null) {\n        for (item in _nodes) {\n          if (_nodes.hasOwnProperty(item)) {\n            if (onItem.call(thisArg, item, _nodes[item])) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  \n    /**\n     * Callback for iterating the tree nodes level by level\n     * \n     * @callback onTreeItemWithLevelCallback\n     * @param {string} nodeid The node id\n     * @param {object} node The node context object\n     * @param {number} levelIndex The node level index\n     * @returns {number} Returns BREAK to break the loop and exit. Returns SKIP to skip node's branch traversing.\n     */\n  \n    /**\n     * Loops through child nodes of the tree structure level by level\n     * \n     * @param {Object} thisArg The callback function invocation context\n     * @param {string} arg0 The node id to start children traversing\n     * @param {onTreeItemWithLevelCallback} arg1 Callback function to call for every child node \n     */\n    function loopLevels(thisArg, arg0, arg1) {\n      var levelIndex = 0,\n        items = [],\n        itemid,\n        onItem,\n        newItems,\n        key,\n        index, len;\n  \n      switch (arguments.length) {\n        case 2:\n          onItem = arg0;\n          break;\n        case 3:\n          itemid = arg0;\n          onItem = arg1;\n          break;\n      }\n  \n      if (onItem != null) {\n  \n        if (itemid == null) {\n          for (key in _rootChildren) {\n            if (_rootChildren.hasOwnProperty(key)) {\n              items = items.concat(_rootChildren[key]);\n            }\n          }\n        } else {\n          if (_children[itemid] != null) {\n            items = items.concat(_children[itemid]);\n          }\n        }\n  \n        while (items.length > 0) {\n          newItems = [];\n  \n          for (index = 0, len = items.length; index < len; index += 1) {\n            itemid = items[index];\n            switch (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex)) {\n              case BREAK:\n                newItems = [];\n                break;\n              case SKIP:\n                break;\n              default:\n                if (_children[itemid] != null) {\n                  newItems = newItems.concat(_children[itemid]);\n                }\n                break;\n            }\n          }\n  \n          items = newItems;\n          levelIndex += 1;\n        }\n      }\n    }\n  \n    /**\n     * Callback for iterating nodes and providing parent in parameters\n     * \n     * @callback onTreeItemWithParentCallback\n     * @param {string} nodeid The node id\n     * @param {object} node The node context object\n     * @param {string} parentid The parent node id\n     * @param {object} parent The parent node context object\n     * @returns {number} Returns BREAK to break the loop and exit. Returns SKIP to skip node's branch traversing.\n     */\n  \n    /**\n     * Traverse tree structure in post order.\n     * Children first - parent last\n     * @param {Object} thisArg The callback function invocation context\n     * @param {onTreeItemWithParentCallback} onItem Callback function to call for every node \n     */\n    function loopPostOrder(thisArg, onItem) {\n      var stack = [], nodeid,\n        key,\n        index,\n        prevParent,\n        children;\n  \n      if (onItem != null) {\n  \n        for (key in _rootChildren) {\n          if (_rootChildren.hasOwnProperty(key)) {\n            stack = stack.concat(_rootChildren[key]);\n          }\n        }\n  \n        while (stack.length > 0) {\n          nodeid = stack[stack.length - 1];\n          if (nodeid != prevParent && (children = _children[nodeid]) != null) {\n            for (index = children.length - 1; index >= 0; index -= 1) {\n              stack.push(children[index]);\n            }\n          } else {\n            stack.pop();\n            prevParent = _parents[nodeid];\n  \n            if (onItem.call(thisArg, nodeid, _nodes[nodeid], prevParent, _nodes[prevParent])) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  \n  \n    /**\n     * Traverse tree structure in pre order.\n     * Parent first - children next\n     * @param {Object} thisArg The callback function invocation context\n     * @param {onTreeItemWithParentCallback} onItem A callback function to call for every node \n     */\n    function loopPreOrder(thisArg, onItem) {\n      var stack = [], nodeid,\n        key,\n        index,\n        parentid,\n        prevParent,\n        children;\n  \n      if (onItem != null) {\n  \n        for (key in _rootChildren) {\n          if (_rootChildren.hasOwnProperty(key)) {\n            stack = stack.concat(_rootChildren[key]);\n          }\n        }\n  \n        while (stack.length > 0) {\n          nodeid = stack[stack.length - 1];\n          if (nodeid != prevParent) {\n            parentid = _parents[nodeid];\n            if (onItem.call(thisArg, nodeid, _nodes[nodeid], parentid, _nodes[parentid])) {\n              break;\n            }\n          }\n          if (nodeid != prevParent && (children = _children[nodeid]) != null) {\n            for (index = children.length - 1; index >= 0; index -= 1) {\n              stack.push(children[index]);\n            }\n          } else {\n            stack.pop();\n            prevParent = _parents[nodeid];\n          }\n        }\n      }\n    }\n  \n    /**\n     * Callback for iterating nodes in euler walk order\n     * \n     * @callback onItemEulerWalkCallback\n     * @param {string} nodeid The node id\n     * @param {object} node Context object of the node\n     * @param {number} level The node's level\n     * @returns {boolean} Returns true to break the iteration of nodes and exit.\n     */\n  \n    /**\n     * Loops tree nodes in \"Euler Walk\" order\n     * \n     * @param {Object} thisArg The callback function invocation context\n     * @param {onItemEulerWalkCallback} onItem Callback function to call for every node \n     */\n    function loopEulerWalk(thisArg, onItem) {\n      var stack = [],\n        nodeid,\n        levels = [],\n        level = 0,\n        key,\n        index, len,\n        prevParent,\n        children;\n  \n      if (onItem != null) {\n  \n        for (key in _rootChildren) {\n          if (_rootChildren.hasOwnProperty(key)) {\n            children = _rootChildren[key];\n            for (index = 0, len = children.length; index < len; index += 1) {\n              stack.push(children[index]);\n              levels.push(0);\n            }\n          }\n        }\n        while (stack.length > 0) {\n          index = stack.length - 1;\n          nodeid = stack[index];\n          level = levels[index];\n  \n          if (onItem.call(thisArg, nodeid, _nodes[nodeid], level)) {\n            break;\n          }\n  \n          if (nodeid != prevParent && (children = _children[nodeid]) != null) {\n            for (index = children.length - 1; index >= 0; index -= 1) {\n              stack.push(children[index]);\n              levels.push(level + 1);\n              if (index > 0) {\n                stack.push(nodeid);\n                levels.push(level);\n              }\n            }\n          } else {\n            stack.pop();\n            levels.pop();\n  \n            prevParent = _parents[nodeid];\n          }\n        }\n      }\n    }\n  \n    /**\n     * Callback function to return pairs of nodes\n     * \n     * @callback onZipUpPairCallback\n     * @param {string} firstNodeId First node id\n     * @param {string} firstParentId Parent id of the first node\n     * @param {string} secondNodeid Second node id\n     * @param {string} secondParentId Parent id of the second node\n     * @returns {boolean} Returns true to break the iteration of nodes and exit.\n     */\n  \n    /**\n     * Iterates hierarchy nodes by pairs starting with given pair of start and second nodes and up to the root of the hierarchy.\n     * Breaks iteration when callback function returns true.\n     * \n     * @param {Object} thisArg The callback function invocation context\n     * @param {string} firstNodeId The first node to start iteration\n     * @param {string} secondNodeid The second node to start iteration\n     * @param {onZipUpPairCallback} onZip Callback function to call for every pair of nodes on the way up in the tree structure\n     */\n    function zipUp(thisArg, firstNodeId, secondNodeid, onZip) {\n      var firstParentId,\n        secondParentId;\n  \n      if (onZip != null) {\n        while (firstNodeId != null && secondNodeid != null && firstNodeId != secondNodeid) {\n          firstParentId = _parents[firstNodeId];\n          secondParentId = _parents[secondNodeid];\n          if (onZip.call(thisArg, firstNodeId, firstParentId, secondNodeid, secondParentId)) {\n            break;\n          }\n          firstNodeId = firstParentId;\n          secondNodeid = secondParentId;\n        }\n      }\n    }\n  \n    /**\n     * Loops parents up to the root of the hierarchy starting with the given node.\n     * Breaks iteration if callback function returns true.\n     * \n     * @param {Object} thisArg The callback function invocation context\n     * @param {string} nodeid The node id to start iteration from\n     * @param {onTreeItemCallback} onItem Callback function to call for every parent node\n     * @param {boolean} includingStartItem If true the first call to callback function is made with start node id\n     */\n    function loopParents(thisArg, nodeid, onItem, includingStartItem) { // onItem(nodeid, node)\n      var parentid = nodeid;\n      if (_nodes[parentid] != null) {\n        if (onItem != null) {\n          if (includingStartItem === true) {\n            if (onItem.call(thisArg, parentid, _nodes[parentid])) {\n              return;\n            }\n          }\n          while ((parentid = _parents[parentid]) != null) {\n            if (onItem.call(thisArg, parentid, _nodes[parentid])) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  \n    /**\n     * Callback function to loop through children of the given node\n     * \n     * @callback onTreeChildItemCallback\n     * @param {string} nodeid Child node id\n     * @param {object} node Context object of the child node\n     * @param {number} index Index of the child node\n     * @param {number} lastIndex Index of the last child\n     * @returns {boolean} Returns true to break the iteration of nodes and exit.\n     */\n  \n    /**\n     * Loops immediate children of the given node.\n     * Breaks iteration if callback function returns true.\n     * \n     * @param {Object} thisArg The callback function invocation context\n     * @param {string} nodeid The parent node id to loop children of\n     * @param {onTreeChildItemCallback} onItem Callback function to call for every child node\n     */\n    function loopChildren(thisArg, nodeid, onItem) { // onItem(nodeid, node, index, lastIndex)\n      var items,\n        itemid,\n        index, len;\n      if (_nodes[nodeid] != null) {\n        items = _children[nodeid];\n        if (items != null) {\n          for (index = 0, len = items.length; index < len; index += 1) {\n            itemid = items[index];\n            if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  \n    /**\n     * Callback function to loop through range of children for the given node\n     * \n     * @callback onTreeNodeWithIndexItemCallback\n     * @param {string} nodeid Child node id\n     * @param {object} node Context object of the child node\n     * @param {number} index Index of the child node\n     * @returns {boolean} Returns true to break the iteration of nodes and exit.\n     */\n  \n    /**\n     * Loops range of immediate children of the given node.\n     * Breaks iteration if callback function returns true.\n     * \n     * @param {Object} thisArg The callback function invocation context\n     * @param {string} nodeid The parent node id to loop children of\n     * @param {number} fromIndex Start index of iteration\n     * @param {number} toIndex End index of iteration\n     * @param {onTreeNodeWithIndexItemCallback} onItem Callback function to call for every child node\n     */\n    function loopChildrenRange(thisArg, nodeid, fromIndex, toIndex, onItem) {\n      var items,\n        itemid,\n        index, len;\n      if (_nodes[nodeid] != null) {\n        items = _children[nodeid];\n        if (items != null) {\n          if (fromIndex < toIndex) {\n            fromIndex = Math.max(fromIndex, 0);\n            toIndex = Math.min(toIndex, items.length - 1);\n            for (index = fromIndex; index <= toIndex; index += 1) {\n              itemid = items[index];\n              if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {\n                break;\n              }\n            }\n          } else {\n            fromIndex = Math.min(fromIndex, items.length - 1);\n            toIndex = Math.max(0, toIndex);\n            for (index = fromIndex; index >= toIndex; index -= 1) {\n              itemid = items[index];\n              if (onItem.call(thisArg, itemid, _nodes[itemid], index, len - 1)) {\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n  \n    /**\n     * Loops immediate children of the given node in reversed order.\n     * Breaks iteration if callback function returns true.\n     * \n     * @param {Object} thisArg The callback function invocation context\n     * @param {string} nodeid The parent node id to loop children of\n     * @param {onTreeChildItemCallback} onItem Callback function to call for every child node\n     */\n    function loopChildrenReversed(thisArg, nodeid, onItem) {\n      var items,\n        itemid,\n        index, lastIndex;\n      if (_nodes[nodeid] != null) {\n        items = _children[nodeid];\n        lastIndex = items.length - 1;\n        if (items != null) {\n          for (index = lastIndex; index >= 0; index -= 1) {\n            itemid = items[index];\n            if (onItem.call(thisArg, itemid, _nodes[itemid], index, lastIndex)) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  \n    /**\n     * Orders children of the given node\n     * \n     * @param {string} nodeid The node id of the parent node which children should be ordered in the tree structure\n     * @param {string[]} children Collection of ordered children\n     */\n    function arrangeChildren(nodeid, children) {\n      var childid,\n        index, len;\n  \n      children = children.slice(0);\n      if (_nodes[nodeid] != null) {\n        if (_children[nodeid] != null) {\n          if (_children[nodeid].length == children.length) {\n            for (index = 0, len = children.length; index < len; index += 1) {\n              childid = children[index];\n              if (_parents[childid] != nodeid) {\n                throw \"Child \" + childid + \" does not belong to given node!\";\n              }\n            }\n            _children[nodeid] = children;\n          } else {\n            throw \"Collections of children don't match each other!\";\n          }\n        } else {\n          if (children.length > 0) {\n            throw \"Collections of children don't match each other!\";\n          }\n        }\n      }\n    }\n  \n    /**\n     * Adds new tree item\n     * @param {string} parentid Parent id\n     * @param {string} nodeid New node id\n     * @param {object} node Context object of the new node\n     * @param {number} position Position of the new node in the collection of children\n     */\n    function add(parentid, nodeid, node, position) {\n      var index, len, children, childid;\n  \n      if (_nodes[nodeid] != null) {\n        throw \"Node already exists\";\n      }\n  \n      if (nodeid != null && node != null && _nodes[nodeid] == null) {\n  \n        if (_nodes[parentid] != null) {\n          _parents[nodeid] = parentid;\n  \n          // existing parent\n          if (_children[parentid] != null) {\n            if (position == null) {\n              _children[parentid].push(nodeid);\n            } else {\n              _children[parentid].splice(position, 0, nodeid);\n            }\n          } else {\n            _children[parentid] = [nodeid];\n          }\n        } else {\n          _roots[nodeid] = parentid;\n  \n          // missing parent\n          if (_rootChildren[parentid] != null) {\n            if (position == null) {\n              _rootChildren[parentid].push(nodeid);\n            } else {\n              _rootChildren[parentid].splice(position, 0, nodeid);\n            }\n          } else {\n            _rootChildren[parentid] = [nodeid];\n          }\n        }\n  \n        _nodes[nodeid] = node;\n  \n        if (_rootChildren[nodeid] != null) {\n          _children[nodeid] = _rootChildren[nodeid];\n          delete _rootChildren[nodeid];\n  \n          children = _children[nodeid];\n          for (index = 0, len = children.length; index < len; index += 1) {\n            childid = children[index];\n  \n            delete _roots[childid];\n  \n            _parents[childid] = nodeid;\n          }\n  \n        }\n  \n      }\n    }\n  \n    /**\n     * Inserts bundle node into the tree structure. The new bundle node becomes only child node of the parent node.\n     * All immediate children of the parent node become children of the inserted bundle node.\n     * \n     * @param {string} nodeid Parent node id\n     * @param {string} bundleid New bundle node id\n     * @param {object} bundle Context object of the bundle node\n     */\n    function insert(nodeid, bundleid, bundle) {\n      if (_nodes[nodeid] != null && bundleid != null && _nodes[bundleid] == null && bundle != null) {\n  \n        _nodes[bundleid] = bundle;\n  \n        if (_children[nodeid] != null) {\n          _children[bundleid] = _children[nodeid];\n        }\n        _children[nodeid] = [bundleid];\n  \n        loopChildren(this, bundleid, function (childid, node, index) {\n          _parents[childid] = bundleid;\n        });\n        _parents[bundleid] = nodeid;\n      }\n    }\n  \n    /**\n     * Moves children form one node to another.\n     * \n     * @param {string} fromNodeid Source node node id\n     * @param {string} toNodeId Destination node id\n     */\n    function moveChildren(fromNodeid, toNodeId) {\n      if (_nodes[fromNodeid] != null && _nodes[toNodeId] != null && fromNodeid != toNodeId) {\n  \n        if (_children[fromNodeid] != null) {\n  \n          loopChildren(this, fromNodeid, function (childid, node, index) {\n            _parents[childid] = toNodeId;\n          });\n  \n          if (_children[toNodeId] != null) {\n            _children[toNodeId] = _children[toNodeId].concat(_children[fromNodeid]);\n          } else {\n            _children[toNodeId] = _children[fromNodeid];\n          }\n          delete _children[fromNodeid];\n        }\n      }\n    }\n  \n    /**\n     * Return true if structure has nodes\n     * \n     * @returns {boolean} Returns true if structure has nodes\n     */\n    function hasNodes() {\n      return !isEmptyObject(_rootChildren);\n    }\n  \n    /**\n     * Returns parent node id\n     * \n     * @param {string} nodeid Node id\n     * @returns {string} Returns parent node id\n     */\n    function parentid(nodeid) {\n      var result = null;\n  \n      if (_parents[nodeid] != null) {\n        result = _parents[nodeid];\n      }\n  \n      return result;\n    }\n  \n    /**\n     * Returns context object of the parent node\n     * \n     * @param {string} nodeid Node id\n     * @returns {object} Returns context object of the  parent node\n     */\n    function parent(nodeid) {\n      var result = null;\n  \n      if (_parents[nodeid] != null) {\n        result = _nodes[_parents[nodeid]];\n      }\n  \n      return result;\n    }\n  \n    /**\n     * Returns true if node has children\n     * \n     * @param {string} nodeid Node id\n     * @returns {boolean} Returns true if node has children\n     */\n    function hasChildren(nodeid) {\n      return _children[nodeid] != null;\n    }\n  \n    /**\n     * Returns number of children\n     * \n     * @param {string} nodeid Node id\n     * @returns {number} Returns number of child nodes\n     */\n    function countChildren(nodeid) {\n      return _children[nodeid] != null ? _children[nodeid].length : 0;\n    }\n  \n    /**\n     * Returns number of siblings\n     * \n     * @param {string} nodeid Node id\n     * @returns {number} Returns number of siblings\n     */\n    function countSiblings(nodeid) {\n      var parent = parentid(nodeid);\n      return parent != null ? _children[parent].length : 0;\n    }\n  \n    /**\n     * Returns index of the node in the children's collection\n     * \n     * @param {string} nodeid Node id\n     * @returns {number} Returns node index\n     */\n    function indexOf(nodeid) {\n      var parent = parentid(nodeid);\n      return parent != null ? _children[parent].findIndex( itemid => itemid === nodeid) : null;\n    }\n  \n    /**\n     * Returns child node by index in the children's collection\n     * \n     * @param {string} nodeid Node id\n     * @param {number} index Child index\n     * @returns {object} Returns child node\n     */\n    function getChild(parentid, index) {\n      var result = null,\n        children;\n      if ((children = _children[parentid]) != null) {\n        result = _nodes[children[index]];\n      }\n      return result;\n    }\n  \n    function _splice(collection, nodeid) {\n      var index, len = collection.length;\n      for (index = 0; index < len; index += 1) {\n        if (collection[index] == nodeid) {\n          collection.splice(index, 1);\n          return len - 1;\n        }\n      }\n      return len;\n    }\n  \n    /**\n     * Adds existing node to the children of the parent node\n     * \n     * @param {string} parentid Parent Node id\n     * @param {string} nodeid Node id\n     */\n    function adopt(parentid, nodeid) {\n      if (_nodes[parentid] != null && _nodes[nodeid] != null) {\n        if (parentid != nodeid) {\n          if (_roots.hasOwnProperty(nodeid)) {\n            if (!_splice(_rootChildren[_roots[nodeid]], nodeid)) {\n              delete _rootChildren[_roots[nodeid]];\n            }\n            delete _roots[nodeid];\n          }\n  \n          if (_parents.hasOwnProperty(nodeid)) {\n            if (!_splice(_children[_parents[nodeid]], nodeid)) {\n              delete _children[_parents[nodeid]];\n            }\n          }\n  \n          _parents[nodeid] = parentid;\n          if (_children[parentid] != null) {\n            _children[parentid].push(nodeid);\n          } else {\n            _children[parentid] = [nodeid];\n          }\n        }\n        else {\n          throw \"Item cannot be parent of itself!\";\n        }\n      } else {\n        throw \"Both parent and child should be in hierarchy!\";\n      }\n    }\n  \n    /**\n     * Returns context object\n     * @param {string} nodeid Node id\n     * @returns {object} Context object of the node\n     */\n    function node(nodeid) {\n      return _nodes[nodeid];\n    }\n  \n    /**\n     * Validates internal data integrity of the structure\n     * \n     * @returns {boolean} Returns true if structure pass validation\n     */\n    function validate() {\n      var result = true,\n        key;\n  \n      for (key in _roots) {\n        if (_roots.hasOwnProperty(key)) {\n          if (_roots[key] != null) {\n            result = false;\n            break;\n          }\n        }\n      }\n  \n      return result;\n    }\n  \n    /**\n     * Clones tree structure\n     * \n     * @returns {tree} Returns clone of the tree\n     */\n    function clone() {\n      return Tree({\n        nodes: _nodes,\n        parents: _parents,\n        children: _children,\n        roots: _roots,\n        rootChildren: _rootChildren\n      });\n    }\n  \n  \n    /**\n     * Callback for iterating tree node neighbours level by level\n     * \n     * @callback onTreeItemNeighbourCallback\n     * @param {string} itemid The node id\n     * @param {object} item The node\n     * @param {number} distance The neigbour node distance from the start node\n     * @returns {number} Returns true to skip further neighbous traversing.\n     */\n  \n    /**\n     * Loops through the node neighbours of the tree structure level by level\n     * \n     * @param {Object} thisArg The callback function invocation context\n     * @param {string} itemid The node id to start traversing neighbour nodes\n     * @param {number} distance Stop iteration of neighbours when distance exceeds the given value\n     * @param {onTreeItemNeighbourCallback} onItem A callback function to call for every neighbour node \n     */\n    function loopNeighbours(thisArg, itemid, distance, onItem) {\n      var processed = {},\n        margin = [itemid],\n        newMargin,\n        currentDistance = 0;\n  \n      if (onItem != null) {\n        if (_nodes.hasOwnProperty(itemid)) {\n          processed[itemid] = true;\n          while (margin.length > 0) {\n            newMargin = [];\n            for (var index = 0, len = margin.length; index < len; index += 1) {\n              var marginid = margin[index];\n              if (currentDistance > 0) {\n                if (onItem.call(thisArg, marginid, _nodes[marginid], currentDistance)) {\n                  return;\n                }\n              }\n              if (currentDistance < distance) {\n                _loopNeighbours(this, marginid, function (neighbourid, neighbour) {\n                  if (!processed.hasOwnProperty(neighbourid)) {\n                    newMargin.push(neighbourid);\n                    processed[neighbourid] = true;\n                  }\n                });\n              }\n            }\n            margin = newMargin;\n            currentDistance += 1;\n          }\n        }\n      }\n    }\n  \n    function _loopNeighbours(thisArg, itemid, onItem) {\n      if (onItem != null) {\n        if (_nodes.hasOwnProperty(itemid)) {\n          /* loop parent */\n          var parentItemId = parentid(itemid);\n          if (parentItemId != null) {\n            if (onItem.call(thisArg, parentItemId, _nodes[parentItemId])) {\n              return;\n            }\n          }\n          /* loop siblings */\n          loopChildren(thisArg, parentItemId, function (childItemId, childItem) {\n            if (childItemId != itemid) {\n              if (onItem.call(thisArg, childItemId, childItem)) {\n                return;\n              }\n            }\n          });\n          /* loop actual children */\n          loopChildren(thisArg, itemid, function (childItemId, childItem) {\n            if (onItem.call(thisArg, childItemId, childItem)) {\n              return;\n            }\n          });\n        }\n      }\n    }\n  \n    return {\n      loop: loop,\n      loopLevels: loopLevels,\n      loopParents: loopParents,\n      loopChildren: loopChildren,\n      loopChildrenRange: loopChildrenRange,\n      loopChildrenReversed: loopChildrenReversed,\n      loopPostOrder: loopPostOrder, /* children first - parent last */\n      loopPreOrder: loopPreOrder, /* parent first - children next */\n      loopEulerWalk: loopEulerWalk, /* pre order loop with every parent revisited for every child */\n      loopNeighbours: loopNeighbours, /* loop items by distance. Siblings are as far as parent and children */\n      zipUp: zipUp,\n      parentid: parentid,\n      parent: parent,\n      adopt: adopt,\n      moveChildren: moveChildren,\n      node: node,\n      add: add,\n      insert: insert,\n      hasNodes: hasNodes,\n      hasChildren: hasChildren,\n      countChildren: countChildren,\n      countSiblings: countSiblings,\n      indexOf: indexOf,\n      getChild: getChild,\n      arrangeChildren: arrangeChildren,\n  \n      /* force validation */\n      validate: validate,\n      clone: clone,\n  \n      // callback return codes\n      BREAK: BREAK, // break loop immidiatly\n      SKIP: SKIP // skip loop of current node children \n    };\n  };"]},"metadata":{},"sourceType":"module"}