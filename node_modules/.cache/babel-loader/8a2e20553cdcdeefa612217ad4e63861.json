{"ast":null,"code":"import PaletteItem from './PaletteItem';\nimport MoveSegment from './MoveSegment';\nimport LineSegment from './LineSegment';\nimport QuadraticArcSegment from './QuadraticArcSegment';\nimport Point from './Point';\nimport Vector from './Vector';\nimport { SegmentType, VectorRelationType } from '../../enums';\nimport { isNullOrEmpty } from '../../common';\nexport default function Polyline(newPaletteItem) {\n  var paletteItem = new PaletteItem(),\n      segments = [],\n      self,\n      arrowPaletteItem;\n\n  switch (arguments.length) {\n    case 1:\n      paletteItem = newPaletteItem;\n      break;\n  }\n\n  arrowPaletteItem = new PaletteItem({\n    lineColor: paletteItem.lineColor,\n    lineWidth: 0,\n    fillColor: paletteItem.lineColor,\n    opacity: paletteItem.opacity || 1\n  });\n\n  function getStartPoint() {\n    var result = null;\n\n    if (segments.length > 0) {\n      result = segments[0].getEndPoint();\n    }\n\n    return result;\n  }\n\n  function getEndPoint() {\n    var result = null;\n\n    if (segments.length > 0) {\n      result = segments[segments.length - 1].getEndPoint();\n    }\n\n    return result;\n  }\n\n  function addSegment(segment) {\n    segments.push(segment);\n  }\n\n  function addSegments(newSegments) {\n    var index, len;\n\n    for (index = 0, len = newSegments.length; index < len; index += 1) {\n      segments.push(newSegments[index]);\n    }\n  }\n\n  function mergeTo(polyline) {\n    polyline.addSegments(segments);\n  }\n\n  function clone() {\n    var index,\n        len,\n        result = new Polyline(paletteItem),\n        cloneSegments = [],\n        segment;\n\n    for (index = 0, len = segments.length; index < len; index += 1) {\n      segment = segments[index];\n      cloneSegments.push(segment.clone());\n    }\n\n    result.addSegments(cloneSegments);\n    return result;\n  }\n\n  function length() {\n    return segments.length;\n  }\n\n  function loop(thisArg, onItem) {\n    var index, len, segment;\n\n    if (onItem != null) {\n      for (index = 0, len = segments.length; index < len; index += 1) {\n        segment = segments[index];\n\n        if (segment) {\n          if (onItem.call(thisArg, segment, index)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  function loopReversed(thisArg, onItem) {\n    var index, segment;\n\n    if (onItem != null) {\n      for (index = segments.length - 1; index >= 0; index -= 1) {\n        segment = segments[index];\n\n        if (segment) {\n          if (onItem.call(thisArg, segment, index)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  function transform(transformArg, forward) {\n    loop(this, function (segment) {\n      if (segment.transform != null) {\n        segment.transform(transformArg, forward);\n      }\n    });\n  }\n\n  function isInvertable() {\n    return isNullOrEmpty(paletteItem.fillColor);\n  }\n\n  function addInverted(polyline) {\n    var hasMoved = false,\n        stack = [];\n\n    if (isInvertable()) {\n      polyline.loopReversed(this, function (segment, index) {\n        if (segment.segmentType != SegmentType.Dot) {\n          if (!hasMoved) {\n            segments.push(new MoveSegment(segment.getEndPoint()));\n            hasMoved = true;\n          }\n\n          stack.unshift(segment);\n\n          if (stack.length > 1) {\n            stack[1].invert(stack[0].getEndPoint());\n            segments.push(stack[1]);\n            stack.length = 1;\n          }\n        }\n      });\n    } else {\n      polyline.mergeTo(self);\n    }\n  }\n\n  function _getArrow(fromX, fromY, toX, toY, length, width) {\n    var result = new Polyline(arrowPaletteItem),\n        index,\n        len,\n        point,\n        x,\n        y,\n        perimeter = [new Point(length, -width / 2), new Point(0, 0), new Point(length, width / 2), new Point(length / 4 * 3, 0)],\n        angle = Math.atan2(fromY - toY, fromX - toX);\n    /* rotate and translate points */\n\n    for (index = 0, len = perimeter.length; index < len; index += 1) {\n      point = perimeter[index];\n      x = point.x * Math.cos(angle) - point.y * Math.sin(angle);\n      y = point.x * Math.sin(angle) + point.y * Math.cos(angle);\n      point.x = x + toX;\n      point.y = y + toY;\n    }\n    /* create arrow shape*/\n\n\n    result.addSegment(new MoveSegment(perimeter[0].x, perimeter[0].y));\n    result.addSegment(new LineSegment(perimeter[1].x, perimeter[1].y));\n    result.addSegment(new LineSegment(perimeter[2].x, perimeter[2].y));\n    result.addSegment(new QuadraticArcSegment(perimeter[3].x, perimeter[3].y, perimeter[0].x, perimeter[0].y));\n    return result;\n  }\n\n  function addOffsetArrow(forward, lineWidth, offsetPercent, minimumDistance, onAddArrowSegments) {\n    var prevEndPoint,\n        currentEndPoint,\n        currentSegment,\n        newEndPoint,\n        newPrevEndPoint,\n        polyline,\n        len = segments.length,\n        arrowTipLength = lineWidth * 3,\n        arrowTipWidth = lineWidth * 2,\n        offset,\n        distance;\n\n    switch (lineWidth) {\n      case 1:\n        arrowTipLength = 8;\n        arrowTipWidth = 6;\n        break;\n\n      case 2:\n        arrowTipLength = 12;\n        arrowTipWidth = 8;\n        break;\n\n      case 3:\n        arrowTipLength = 16;\n        arrowTipWidth = 10;\n        break;\n    }\n\n    if (onAddArrowSegments != null && len > 1) {\n      prevEndPoint = segments[len - 2].getEndPoint();\n      currentSegment = segments[len - 1];\n\n      if (currentSegment.offsetPoint != null) {\n        currentEndPoint = new Point(currentSegment.getEndPoint());\n        distance = prevEndPoint.distanceTo(currentEndPoint);\n\n        if (distance > minimumDistance) {\n          offset = distance * offsetPercent;\n\n          if (forward) {\n            newEndPoint = currentSegment.offsetPoint(prevEndPoint, currentEndPoint, offset);\n            polyline = _getArrow(prevEndPoint.x, prevEndPoint.y, newEndPoint.x, newEndPoint.y, arrowTipLength, arrowTipWidth);\n          } else {\n            newPrevEndPoint = currentSegment.offsetPoint(currentEndPoint, prevEndPoint, offset);\n            polyline = _getArrow(currentEndPoint.x, currentEndPoint.y, newPrevEndPoint.x, newPrevEndPoint.y, arrowTipLength, arrowTipWidth);\n          }\n\n          onAddArrowSegments(polyline);\n        }\n      }\n    }\n  }\n\n  function addArrow(lineWidth, onAddArrowSegments) {\n    var prevEndPoint,\n        currentEndPoint,\n        currentSegment,\n        newEndPoint,\n        polyline,\n        len = segments.length,\n        arrowTipLength = lineWidth * 3,\n        arrowTipWidth = lineWidth * 2;\n\n    switch (lineWidth) {\n      case 1:\n        arrowTipLength = 8;\n        arrowTipWidth = 6;\n        break;\n\n      case 2:\n        arrowTipLength = 12;\n        arrowTipWidth = 8;\n        break;\n\n      case 3:\n        arrowTipLength = 16;\n        arrowTipWidth = 10;\n        break;\n    }\n\n    if (onAddArrowSegments != null && len > 1) {\n      prevEndPoint = segments[len - 2].getEndPoint();\n      currentSegment = segments[len - 1];\n\n      if (currentSegment.trim != null) {\n        currentEndPoint = new Point(currentSegment.getEndPoint());\n\n        if (currentEndPoint.distanceTo(prevEndPoint) > arrowTipLength) {\n          newEndPoint = currentSegment.trim(prevEndPoint, arrowTipLength);\n          polyline = _getArrow(newEndPoint.x, newEndPoint.y, currentEndPoint.x, currentEndPoint.y, arrowTipLength, arrowTipWidth);\n          onAddArrowSegments(polyline, newEndPoint);\n        }\n      }\n    }\n  }\n\n  function optimizeMoveSegments() {\n    var index,\n        len,\n        cursorIndex,\n        key,\n        optimizedSegments,\n        segment,\n        nextSegment,\n        links = {},\n        jumps = [],\n        processed = [];\n\n    for (index = 0, len = segments.length; index < len - 1; index += 1) {\n      segment = segments[index];\n      nextSegment = segments[index + 1];\n\n      switch (segment.segmentType) {\n        case SegmentType.Line:\n        case SegmentType.QuadraticArc:\n        case SegmentType.CubicArc:\n          switch (nextSegment.segmentType) {\n            case SegmentType.Move:\n            case SegmentType.Dot:\n              key = segment.x + \"&\" + segment.y;\n\n              if (!links.hasOwnProperty(key)) {\n                links[key] = index;\n              }\n\n              break;\n\n            default:\n              break;\n          }\n\n          break;\n\n        case SegmentType.Move:\n          key = segment.x + \"&\" + segment.y;\n\n          if (links.hasOwnProperty(key) && !jumps[links[key]]) {\n            jumps[links[key]] = index + 1;\n            processed[index] = true;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    optimizedSegments = [];\n\n    for (index = 0; index < len; index += 1) {\n      if (!processed[index]) {\n        segment = segments[index];\n        optimizedSegments.push(segment);\n        processed[index] = true;\n\n        if (jumps[index] > 0) {\n          cursorIndex = jumps[index];\n\n          while (cursorIndex < len && !processed[cursorIndex]) {\n            segment = segments[cursorIndex];\n            optimizedSegments.push(segment);\n            processed[cursorIndex] = true;\n\n            if (jumps[cursorIndex] > 0) {\n              cursorIndex = jumps[cursorIndex];\n            } else {\n              cursorIndex += 1;\n            }\n          }\n        }\n      }\n    }\n\n    segments = optimizedSegments;\n  }\n\n  function toString() {\n    return paletteItem.toString();\n  }\n  /* private classes */\n\n\n  function Vertex(segment, pointIndex) {\n    this.segment = segment;\n    this.pointIndex = pointIndex;\n  }\n\n  Vertex.prototype.pushToSegment = function (point) {\n    this.segment.setPoint(point, this.pointIndex);\n  };\n\n  function _joinVectors(prev, current, offset, polyline, isLoop) {\n    var relationType = prev.relateTo(current),\n        offset2 = isLoop ? 0 : offset,\n        joinSegment,\n        joinVector,\n        newToPoint;\n\n    if (relationType == VectorRelationType.Collinear) {\n      /* Vectors are collinear vectors so we don't search for intersection */\n      current.offset(offset2);\n    } else {\n      if (relationType == VectorRelationType.Opposite && current.from.context.pointIndex === 0) {\n        /* Vectors are opposite vectors which belong to 2 different segments\n          so we add an extra line segment in between of them\n        */\n        joinSegment = new LineSegment(current.from);\n        polyline.addSegment(joinSegment);\n        current.offset(offset2);\n        newToPoint = current.from.clone();\n        newToPoint.context = new Vertex(joinSegment, 0);\n        joinVector = new Vector(prev.to.clone(), newToPoint);\n\n        if (!isLoop) {\n          current.from = newToPoint.clone();\n        }\n\n        joinVector.offset(offset);\n        joinVector.intersect(prev);\n        joinVector.from.context.pushToSegment(joinVector.from);\n        current.intersect(joinVector);\n\n        if (isLoop) {\n          joinVector.to.context.pushToSegment(joinVector.to);\n        }\n      } else {\n        current.offset(offset2);\n        current.intersect(prev);\n      }\n    }\n\n    current.from.context.pushToSegment(current.from);\n  }\n\n  function _closeVector(vectorStack, startVectors, offset, polyline) {\n    var startVector,\n        prevVector = vectorStack[0],\n        closurePoint = prevVector.to.context.segment.getEndPoint().toString();\n\n    if (startVectors.hasOwnProperty(closurePoint)) {\n      startVector = startVectors[closurePoint];\n\n      _joinVectors(prevVector, startVector, offset, polyline, true);\n\n      delete startVectors[closurePoint];\n    }\n\n    prevVector.to.context.pushToSegment(prevVector.to);\n    vectorStack.length = 0;\n  }\n\n  function getOffsetPolyine(offset) {\n    var result = new Polyline(paletteItem),\n        startVectors = {},\n        pointStack = [],\n        vectorStack = [];\n    loop(this, function (segment) {\n      var newSegment = segment.clone(),\n          newPoint;\n\n      switch (newSegment.segmentType) {\n        case SegmentType.Dot:\n        case SegmentType.Move:\n          if (vectorStack.length > 0) {\n            _closeVector(vectorStack, startVectors, offset, result);\n          }\n\n          pointStack.length = 0;\n\n          if (newSegment.segmentType == SegmentType.Move) {\n            newPoint = new Point(newSegment);\n            newPoint.context = new Vertex(newSegment, 0);\n            pointStack.push(newPoint);\n          }\n\n          break;\n\n        default:\n          newSegment.loop(this, function (x, y, index) {\n            var newPoint = new Point(x, y),\n                current,\n                prev,\n                closurePoint;\n            newPoint.context = new Vertex(newSegment, index);\n            pointStack.unshift(newPoint);\n\n            if (pointStack.length > 1) {\n              vectorStack.unshift(new Vector(pointStack[1].clone(), pointStack[0].clone()));\n              pointStack.length = 1;\n            }\n\n            switch (vectorStack.length) {\n              case 1:\n                /* first Vector in stack we add to start Vectors collection for possible join into perimeter*/\n                current = vectorStack[0];\n                closurePoint = current.from.toString();\n                startVectors[closurePoint] = current;\n                current.offset(offset);\n                current.from.context.pushToSegment(current.from);\n                break;\n\n              case 2:\n                prev = vectorStack[1];\n                current = vectorStack[0];\n\n                _joinVectors(prev, current, offset, result, false);\n\n                vectorStack.length = 1;\n                break;\n\n              default:\n                break;\n            }\n          });\n          break;\n      }\n\n      result.addSegment(newSegment);\n    });\n\n    if (vectorStack.length > 0) {\n      _closeVector(vectorStack, startVectors, offset, result);\n    }\n\n    return result;\n  }\n\n  self = {\n    paletteItem: paletteItem,\n    arrowPaletteItem: arrowPaletteItem,\n    addSegment: addSegment,\n    addSegments: addSegments,\n    mergeTo: mergeTo,\n    length: length,\n    loop: loop,\n    loopReversed: loopReversed,\n    transform: transform,\n    isInvertable: isInvertable,\n    addInverted: addInverted,\n    addArrow: addArrow,\n    addOffsetArrow: addOffsetArrow,\n    optimizeMoveSegments: optimizeMoveSegments,\n    getOffsetPolyine: getOffsetPolyine,\n    toString: toString,\n    getStartPoint: getStartPoint,\n    getEndPoint: getEndPoint,\n    clone: clone\n  };\n  return self;\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/graphics/structs/Polyline.js"],"names":["PaletteItem","MoveSegment","LineSegment","QuadraticArcSegment","Point","Vector","SegmentType","VectorRelationType","isNullOrEmpty","Polyline","newPaletteItem","paletteItem","segments","self","arrowPaletteItem","arguments","length","lineColor","lineWidth","fillColor","opacity","getStartPoint","result","getEndPoint","addSegment","segment","push","addSegments","newSegments","index","len","mergeTo","polyline","clone","cloneSegments","loop","thisArg","onItem","call","loopReversed","transform","transformArg","forward","isInvertable","addInverted","hasMoved","stack","segmentType","Dot","unshift","invert","_getArrow","fromX","fromY","toX","toY","width","point","x","y","perimeter","angle","Math","atan2","cos","sin","addOffsetArrow","offsetPercent","minimumDistance","onAddArrowSegments","prevEndPoint","currentEndPoint","currentSegment","newEndPoint","newPrevEndPoint","arrowTipLength","arrowTipWidth","offset","distance","offsetPoint","distanceTo","addArrow","trim","optimizeMoveSegments","cursorIndex","key","optimizedSegments","nextSegment","links","jumps","processed","Line","QuadraticArc","CubicArc","Move","hasOwnProperty","toString","Vertex","pointIndex","prototype","pushToSegment","setPoint","_joinVectors","prev","current","isLoop","relationType","relateTo","offset2","joinSegment","joinVector","newToPoint","Collinear","Opposite","from","context","to","intersect","_closeVector","vectorStack","startVectors","startVector","prevVector","closurePoint","getOffsetPolyine","pointStack","newSegment","newPoint"],"mappings":"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","sourcesContent":["import PaletteItem from './PaletteItem';\nimport MoveSegment from './MoveSegment';\nimport LineSegment from './LineSegment';\nimport QuadraticArcSegment from './QuadraticArcSegment';\nimport Point from './Point';\nimport Vector from './Vector';\nimport { SegmentType, VectorRelationType } from '../../enums';\nimport { isNullOrEmpty } from '../../common';\n\nexport default function Polyline(newPaletteItem) {\n  var paletteItem = new PaletteItem(),\n    segments = [],\n    self,\n    arrowPaletteItem;\n\n  switch (arguments.length) {\n    case 1:\n      paletteItem = newPaletteItem;\n      break;\n  }\n\n  arrowPaletteItem = new PaletteItem({\n    lineColor: paletteItem.lineColor,\n    lineWidth: 0,\n    fillColor: paletteItem.lineColor,\n    opacity: paletteItem.opacity || 1\n  });\n\n  function getStartPoint() {\n    var result = null;\n    if (segments.length > 0) {\n      result = segments[0].getEndPoint();\n    }\n    return result;\n  }\n\n  function getEndPoint() {\n    var result = null;\n    if (segments.length > 0) {\n      result = segments[segments.length - 1].getEndPoint();\n    }\n    return result;\n  }\n\n  function addSegment(segment) {\n    segments.push(segment);\n  }\n\n  function addSegments(newSegments) {\n    var index, len;\n    for (index = 0, len = newSegments.length; index < len; index += 1) {\n      segments.push(newSegments[index]);\n    }\n  }\n\n  function mergeTo(polyline) {\n    polyline.addSegments(segments);\n  }\n\n  function clone() {\n    var index, len,\n      result = new Polyline(paletteItem),\n      cloneSegments = [],\n      segment;\n    for (index = 0, len = segments.length; index < len; index += 1) {\n      segment = segments[index];\n      cloneSegments.push(segment.clone());\n    }\n    result.addSegments(cloneSegments);\n    return result;\n  }\n\n  function length() {\n    return segments.length;\n  }\n\n  function loop(thisArg, onItem) {\n    var index, len,\n      segment;\n    if (onItem != null) {\n      for (index = 0, len = segments.length; index < len; index += 1) {\n        segment = segments[index];\n        if (segment) {\n          if (onItem.call(thisArg, segment, index)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  function loopReversed(thisArg, onItem) {\n    var index,\n      segment;\n    if (onItem != null) {\n      for (index = segments.length - 1; index >= 0; index -= 1) {\n        segment = segments[index];\n        if (segment) {\n          if (onItem.call(thisArg, segment, index)) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  function transform(transformArg, forward) {\n    loop(this, function (segment) {\n      if (segment.transform != null) {\n        segment.transform(transformArg, forward);\n      }\n    });\n  }\n\n  function isInvertable() {\n    return isNullOrEmpty(paletteItem.fillColor);\n  }\n\n  function addInverted(polyline) {\n    var hasMoved = false,\n      stack = [];\n\n    if (isInvertable()) {\n      polyline.loopReversed(this, function (segment, index) {\n        if (segment.segmentType != SegmentType.Dot) {\n          if (!hasMoved) {\n            segments.push(new MoveSegment(segment.getEndPoint()));\n            hasMoved = true;\n          }\n          stack.unshift(segment);\n\n          if (stack.length > 1) {\n            stack[1].invert(stack[0].getEndPoint());\n            segments.push(stack[1]);\n            stack.length = 1;\n          }\n\n        }\n      });\n    } else {\n      polyline.mergeTo(self);\n    }\n  }\n\n  function _getArrow(fromX, fromY, toX, toY, length, width) {\n    var result = new Polyline(arrowPaletteItem),\n      index, len,\n      point, x, y,\n      perimeter = [new Point(length, -width / 2),\n      new Point(0, 0),\n      new Point(length, width / 2),\n      new Point(length / 4 * 3, 0)\n      ],\n      angle = Math.atan2((fromY - toY), (fromX - toX));\n\n    /* rotate and translate points */\n    for (index = 0, len = perimeter.length; index < len; index += 1) {\n      point = perimeter[index];\n      x = point.x * Math.cos(angle) - point.y * Math.sin(angle);\n      y = point.x * Math.sin(angle) + point.y * Math.cos(angle);\n      point.x = x + toX;\n      point.y = y + toY;\n    }\n\n    /* create arrow shape*/\n    result.addSegment(new MoveSegment(perimeter[0].x, perimeter[0].y));\n    result.addSegment(new LineSegment(perimeter[1].x, perimeter[1].y));\n    result.addSegment(new LineSegment(perimeter[2].x, perimeter[2].y));\n    result.addSegment(new QuadraticArcSegment(perimeter[3].x, perimeter[3].y, perimeter[0].x, perimeter[0].y));\n\n    return result;\n  }\n\n  function addOffsetArrow(forward, lineWidth, offsetPercent, minimumDistance, onAddArrowSegments) {\n    var prevEndPoint,\n      currentEndPoint,\n      currentSegment,\n      newEndPoint, newPrevEndPoint,\n      polyline,\n      len = segments.length,\n      arrowTipLength = lineWidth * 3,\n      arrowTipWidth = lineWidth * 2,\n      offset,\n      distance;\n\n    switch (lineWidth) {\n      case 1:\n        arrowTipLength = 8;\n        arrowTipWidth = 6;\n        break;\n      case 2:\n        arrowTipLength = 12;\n        arrowTipWidth = 8;\n        break;\n      case 3:\n        arrowTipLength = 16;\n        arrowTipWidth = 10;\n        break;\n    }\n\n    if (onAddArrowSegments != null && len > 1) {\n      prevEndPoint = segments[len - 2].getEndPoint();\n      currentSegment = segments[len - 1];\n      if (currentSegment.offsetPoint != null) {\n        currentEndPoint = new Point(currentSegment.getEndPoint());\n\n        distance = prevEndPoint.distanceTo(currentEndPoint);\n        if (distance > minimumDistance) {\n          offset = distance * offsetPercent;\n\n          if (forward) {\n            newEndPoint = currentSegment.offsetPoint(prevEndPoint, currentEndPoint, offset);\n            polyline = _getArrow(prevEndPoint.x, prevEndPoint.y, newEndPoint.x, newEndPoint.y, arrowTipLength, arrowTipWidth);\n          } else {\n            newPrevEndPoint = currentSegment.offsetPoint(currentEndPoint, prevEndPoint, offset);\n            polyline = _getArrow(currentEndPoint.x, currentEndPoint.y, newPrevEndPoint.x, newPrevEndPoint.y, arrowTipLength, arrowTipWidth);\n          }\n          onAddArrowSegments(polyline);\n        }\n      }\n    }\n  }\n\n  function addArrow(lineWidth, onAddArrowSegments) {\n    var prevEndPoint,\n      currentEndPoint,\n      currentSegment,\n      newEndPoint,\n      polyline,\n      len = segments.length,\n      arrowTipLength = lineWidth * 3,\n      arrowTipWidth = lineWidth * 2;\n\n    switch (lineWidth) {\n      case 1:\n        arrowTipLength = 8;\n        arrowTipWidth = 6;\n        break;\n      case 2:\n        arrowTipLength = 12;\n        arrowTipWidth = 8;\n        break;\n      case 3:\n        arrowTipLength = 16;\n        arrowTipWidth = 10;\n        break;\n    }\n\n    if (onAddArrowSegments != null && len > 1) {\n      prevEndPoint = segments[len - 2].getEndPoint();\n      currentSegment = segments[len - 1];\n      if (currentSegment.trim != null) {\n        currentEndPoint = new Point(currentSegment.getEndPoint());\n        if (currentEndPoint.distanceTo(prevEndPoint) > arrowTipLength) {\n          newEndPoint = currentSegment.trim(prevEndPoint, arrowTipLength);\n\n          polyline = _getArrow(newEndPoint.x, newEndPoint.y, currentEndPoint.x, currentEndPoint.y, arrowTipLength, arrowTipWidth);\n          onAddArrowSegments(polyline, newEndPoint);\n        }\n      }\n    }\n  }\n\n  function optimizeMoveSegments() {\n    var index, len,\n      cursorIndex,\n      key,\n      optimizedSegments,\n      segment, nextSegment,\n      links = {},\n      jumps = [],\n      processed = [];\n\n    for (index = 0, len = segments.length; index < len - 1; index += 1) {\n      segment = segments[index];\n      nextSegment = segments[index + 1];\n      switch (segment.segmentType) {\n        case SegmentType.Line:\n        case SegmentType.QuadraticArc:\n        case SegmentType.CubicArc:\n          switch (nextSegment.segmentType) {\n            case SegmentType.Move:\n            case SegmentType.Dot:\n              key = segment.x + \"&\" + segment.y;\n              if (!links.hasOwnProperty(key)) {\n                links[key] = index;\n              }\n              break;\n            default:\n              break;\n          }\n          break;\n        case SegmentType.Move:\n          key = segment.x + \"&\" + segment.y;\n          if (links.hasOwnProperty(key) && !jumps[links[key]]) {\n            jumps[links[key]] = index + 1;\n            processed[index] = true;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n    optimizedSegments = [];\n    for (index = 0; index < len; index += 1) {\n      if (!processed[index]) {\n        segment = segments[index];\n        optimizedSegments.push(segment);\n        processed[index] = true;\n\n        if (jumps[index] > 0) {\n          cursorIndex = jumps[index];\n          while (cursorIndex < len && !processed[cursorIndex]) {\n            segment = segments[cursorIndex];\n            optimizedSegments.push(segment);\n            processed[cursorIndex] = true;\n\n            if (jumps[cursorIndex] > 0) {\n              cursorIndex = jumps[cursorIndex];\n            } else {\n              cursorIndex += 1;\n            }\n          }\n        }\n      }\n    }\n    segments = optimizedSegments;\n  }\n\n  function toString() {\n    return paletteItem.toString();\n  }\n\n  /* private classes */\n  function Vertex(segment, pointIndex) {\n    this.segment = segment;\n    this.pointIndex = pointIndex;\n  }\n\n  Vertex.prototype.pushToSegment = function (point) {\n    this.segment.setPoint(point, this.pointIndex);\n  };\n\n  function _joinVectors(prev, current, offset, polyline, isLoop) {\n    var relationType = prev.relateTo(current),\n      offset2 = isLoop ? 0 : offset,\n      joinSegment,\n      joinVector,\n      newToPoint;\n    if (relationType == VectorRelationType.Collinear) {\n      /* Vectors are collinear vectors so we don't search for intersection */\n      current.offset(offset2);\n    } else {\n      if (relationType == VectorRelationType.Opposite && current.from.context.pointIndex === 0) {\n        /* Vectors are opposite vectors which belong to 2 different segments\n          so we add an extra line segment in between of them\n        */\n        joinSegment = new LineSegment(current.from);\n        polyline.addSegment(joinSegment);\n\n        current.offset(offset2);\n\n        newToPoint = current.from.clone();\n        newToPoint.context = new Vertex(joinSegment, 0);\n\n        joinVector = new Vector(prev.to.clone(), newToPoint);\n        if (!isLoop) {\n          current.from = newToPoint.clone();\n        }\n\n        joinVector.offset(offset);\n        joinVector.intersect(prev);\n        joinVector.from.context.pushToSegment(joinVector.from);\n        current.intersect(joinVector);\n\n        if (isLoop) {\n          joinVector.to.context.pushToSegment(joinVector.to);\n        }\n      } else {\n        current.offset(offset2);\n        current.intersect(prev);\n      }\n    }\n    current.from.context.pushToSegment(current.from);\n  }\n\n  function _closeVector(vectorStack, startVectors, offset, polyline) {\n    var startVector,\n      prevVector = vectorStack[0],\n      closurePoint = prevVector.to.context.segment.getEndPoint().toString();\n    if (startVectors.hasOwnProperty(closurePoint)) {\n      startVector = startVectors[closurePoint];\n\n      _joinVectors(prevVector, startVector, offset, polyline, true);\n\n      delete startVectors[closurePoint];\n    }\n    prevVector.to.context.pushToSegment(prevVector.to);\n    vectorStack.length = 0;\n  }\n\n  function getOffsetPolyine(offset) {\n    var result = new Polyline(paletteItem),\n      startVectors = {},\n      pointStack = [],\n      vectorStack = [];\n\n    loop(this, function (segment) {\n      var newSegment = segment.clone(),\n        newPoint;\n\n      switch (newSegment.segmentType) {\n        case SegmentType.Dot:\n        case SegmentType.Move:\n          if (vectorStack.length > 0) {\n            _closeVector(vectorStack, startVectors, offset, result);\n          }\n          pointStack.length = 0;\n          if (newSegment.segmentType == SegmentType.Move) {\n            newPoint = new Point(newSegment);\n            newPoint.context = new Vertex(newSegment, 0);\n            pointStack.push(newPoint);\n          }\n          break;\n        default:\n          newSegment.loop(this, function (x, y, index) {\n            var newPoint = new Point(x, y),\n              current,\n              prev,\n              closurePoint;\n\n            newPoint.context = new Vertex(newSegment, index);\n            pointStack.unshift(newPoint);\n            if (pointStack.length > 1) {\n              vectorStack.unshift(new Vector(pointStack[1].clone(), pointStack[0].clone()));\n              pointStack.length = 1;\n            }\n\n            switch (vectorStack.length) {\n              case 1:\n                /* first Vector in stack we add to start Vectors collection for possible join into perimeter*/\n                current = vectorStack[0];\n                closurePoint = current.from.toString();\n                startVectors[closurePoint] = current;\n                current.offset(offset);\n                current.from.context.pushToSegment(current.from);\n                break;\n              case 2:\n                prev = vectorStack[1];\n                current = vectorStack[0];\n\n                _joinVectors(prev, current, offset, result, false);\n\n                vectorStack.length = 1;\n                break;\n              default:\n                break;\n            }\n          });\n          break;\n      }\n      result.addSegment(newSegment);\n    });\n    if (vectorStack.length > 0) {\n      _closeVector(vectorStack, startVectors, offset, result);\n    }\n    return result;\n  }\n\n  self = {\n    paletteItem: paletteItem,\n    arrowPaletteItem: arrowPaletteItem,\n    addSegment: addSegment,\n    addSegments: addSegments,\n    mergeTo: mergeTo,\n    length: length,\n    loop: loop,\n    loopReversed: loopReversed,\n    transform: transform,\n    isInvertable: isInvertable,\n    addInverted: addInverted,\n    addArrow: addArrow,\n    addOffsetArrow: addOffsetArrow,\n    optimizeMoveSegments: optimizeMoveSegments,\n    getOffsetPolyine: getOffsetPolyine,\n    toString: toString,\n    getStartPoint: getStartPoint,\n    getEndPoint: getEndPoint,\n    clone: clone\n  };\n\n  return self;\n};"]},"metadata":{},"sourceType":"module"}