{"ast":null,"code":"/**\n * Graph edge structure\n * @class Edge\n * @property {string} from From node id\n * @property {string} to To node id\n */\nexport function Edge(from, to) {\n  this.from = from;\n  this.to = to;\n}\n/**\n * This function finds [optimal collection of feedback edges](https://en.wikipedia.org/wiki/Feedback_arc_set) needed to be cut in \n * order to eliminate loops in family structure.\n * \n * @param {Family} family Family structure\n * @returns {Edge[]} Returns optimal collection of feedback loops \n */\n\nexport default function getFamilyLoops(family, debug) {\n  var loops = [],\n      loop,\n      index,\n      len,\n      index2,\n      len2,\n      fromNode,\n      toNode,\n      edge;\n  var tempFamily = family.clone();\n  family.loopTopo(this, function (itemid) {\n    tempFamily.removeNode(itemid);\n  });\n  family.loopTopoReversed(this, function (itemid) {\n    tempFamily.removeNode(itemid);\n  });\n  var cleanFamily = tempFamily.clone();\n  cleanFamily.loop(this, function (itemid) {\n    if (tempFamily.node(itemid) != null) {\n      cleanFamily.loopParents(this, itemid, function (parentid) {\n        loops.push(new Edge(parentid, itemid));\n        tempFamily.removeChildRelation(parentid, itemid);\n        return cleanFamily.SKIP;\n      });\n      var itemsToRemove = [];\n      tempFamily.loopTopo(this, function (itemid) {\n        itemsToRemove.push(itemid);\n      });\n      tempFamily.loopTopoReversed(this, function (itemid) {\n        itemsToRemove.push(itemid);\n      });\n\n      for (var index = 0; index < itemsToRemove.length; index += 1) {\n        tempFamily.removeNode(itemsToRemove[index]);\n      }\n    }\n  });\n  /* Invert loops */\n\n  for (index = 0, len = loops.length; index < len; index += 1) {\n    loop = loops[index];\n\n    if (!cleanFamily.removeChildRelation(loop.from, loop.to)) {\n      throw \"Relation does not exists\";\n    }\n  }\n\n  if (debug && cleanFamily.hasLoops()) {\n    throw \"Failed to clean loops in family\";\n  }\n\n  var graph = cleanFamily.getGraph(this, function (from, to) {\n    return {\n      from: from,\n      to: to,\n      capacity: 1,\n      flow: 0\n    };\n  });\n  var from = \"__1000__\";\n  var to = \"__2000__\";\n  var defaultMinimalFlow = loops.length;\n\n  for (index = 0, len = loops.length; index < len; index += 1) {\n    loop = loops[index];\n    edge = graph.edge(loop.from, to);\n\n    if (edge == null) {\n      graph.addEdge(loop.from, to, {\n        from: loop.from,\n        to: to,\n        capacity: 1,\n        flow: 0,\n        tos: [loop.to]\n      });\n    } else {\n      edge.capacity += 1;\n      edge.tos.push(loop.to);\n    }\n\n    edge = graph.edge(from, loop.to);\n\n    if (edge == null) {\n      graph.addEdge(from, loop.to, {\n        from: from,\n        to: loop.to,\n        capacity: 1,\n        flow: 0,\n        froms: [loop.from]\n      });\n    } else {\n      edge.capacity += 1;\n      edge.froms.push(loop.from);\n    }\n  }\n\n  var totalFlow = 0;\n  var levelGraph = null;\n\n  while (true) {\n    levelGraph = graph.getLevelGraph(this, from, function (fromNode, toNode, edge) {\n      if (fromNode == edge.from) {\n        return edge.capacity > edge.flow;\n      } else {\n        return edge.flow > 0;\n      }\n    });\n\n    if (!levelGraph.hasNode(to)) {\n      break;\n    }\n\n    while (true) {\n      var connectionPath = graph.dfsPath(this, from, to, function (fromNode, toNode, edge) {\n        if (fromNode == edge.from) {\n          return edge.capacity > edge.flow;\n        } else {\n          return edge.flow > 0;\n        }\n      });\n\n      if (connectionPath.length == 0) {\n        break;\n      } // Find maximum flow for given path\n\n\n      var flow = Infinity;\n\n      for (index = 0, len = connectionPath.length; index < len - 1; index += 1) {\n        fromNode = connectionPath[index];\n        toNode = connectionPath[index + 1];\n        edge = graph.edge(fromNode, toNode);\n        var edgeFlow = 0;\n\n        if (edge.from == fromNode) {\n          edgeFlow = edge.capacity - edge.flow;\n        } else {\n          edgeFlow = edge.flow;\n        }\n\n        if (edgeFlow == 0) {\n          throw \"Broken flow path\";\n        }\n\n        flow = Math.min(flow, edgeFlow);\n      } // Update graph\n\n\n      for (index = 0, len = connectionPath.length; index < len - 1; index += 1) {\n        fromNode = connectionPath[index];\n        toNode = connectionPath[index + 1];\n        edge = graph.edge(fromNode, toNode);\n\n        if (edge.from == fromNode) {\n          edge.flow += flow;\n        } else {\n          edge.flow -= flow;\n        }\n      }\n\n      totalFlow += flow;\n    }\n  }\n\n  if (totalFlow < defaultMinimalFlow) {\n    var residueGraph = graph.getLevelGraph(this, from, function (fromNode, toNode, edge) {\n      if (fromNode == edge.from) {\n        return edge.capacity > edge.flow;\n      }\n\n      return false;\n    }); // graph.loopNodes(this, from, function (nodeid) {\n    //   console.log(\"Nodeid: \" + nodeid);\n    //   graph.loopNodeEdges(this, nodeid, function (neighbour, edge) {\n    //     if (edge.to == neighbour) {\n    //       console.log(\"neighbour: \" + neighbour + \", edge=\" + JSON.stringify(edge));\n    //     }\n    //   })\n    // });\n    // var resedueNodes = [];\n    // residueGraph.loopNodes(this, from, function (nodeid) {\n    //   resedueNodes.push(nodeid);\n    // });\n    // console.log(\"Residue graph: \" + resedueNodes.join(\", \"));\n\n    var edgesToBreak = [];\n    residueGraph.loopNodes(this, from, function (nodeid) {\n      graph.loopNodeEdges(this, nodeid, function (toNode, edge) {\n        if (edge.to == toNode) {\n          if (!residueGraph.hasNode(toNode)) {\n            // console.log(\"Edge to test: from: \" + nodeid + \", to \" + toNode);\n            var isIsolated = true;\n            graph.dfsLoop(this, toNode, function (fromNode, toNode2, edge) {\n              if (edge.from == fromNode) {\n                return edge.capacity > 0;\n              }\n\n              return false;\n            }, function (foundid) {\n              if (residueGraph.hasNode(foundid)) {\n                // console.log(\"Non-isolated: \" + toNode + \", hits residue node\" + foundid);\n                isIsolated = false;\n                return true;\n              }\n\n              return false;\n            });\n\n            if (isIsolated) {\n              edgesToBreak.push(new Edge(nodeid, toNode));\n            }\n          }\n        }\n      });\n    }); // collect loops to break\n\n    var optimizedLoops = [];\n    var validatedFlow = 0;\n\n    for (index = 0, len = edgesToBreak.length; index < len; index += 1) {\n      var edgeToBreak = edgesToBreak[index];\n\n      if (edgeToBreak.from == from) {\n        edge = graph.edge(edgeToBreak.from, edgeToBreak.to);\n\n        for (index2 = 0, len2 = edge.froms.length; index2 < len2; index2 += 1) {\n          optimizedLoops.push(new Edge(edge.froms[index2], edgeToBreak.to));\n          validatedFlow += 1;\n        }\n      } else if (edgeToBreak.to == to) {\n        edge = graph.edge(edgeToBreak.from, edgeToBreak.to);\n\n        for (index2 = 0, len2 = edge.tos.length; index2 < len2; index2 += 1) {\n          optimizedLoops.push(new Edge(edgeToBreak.from, edge.tos[index2]));\n          validatedFlow += 1;\n        }\n      } else {\n        optimizedLoops.push(edgeToBreak);\n        validatedFlow += 1;\n      }\n    }\n\n    if (validatedFlow != totalFlow) {\n      throw \"Failed to properly collect edges cutting maximum flow\";\n    }\n\n    loops = optimizedLoops;\n  }\n\n  return loops;\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/getFamilyLoops.js"],"names":["Edge","from","to","getFamilyLoops","family","debug","loops","loop","index","len","index2","len2","fromNode","toNode","edge","tempFamily","clone","loopTopo","itemid","removeNode","loopTopoReversed","cleanFamily","node","loopParents","parentid","push","removeChildRelation","SKIP","itemsToRemove","length","hasLoops","graph","getGraph","capacity","flow","defaultMinimalFlow","addEdge","tos","froms","totalFlow","levelGraph","getLevelGraph","hasNode","connectionPath","dfsPath","Infinity","edgeFlow","Math","min","residueGraph","edgesToBreak","loopNodes","nodeid","loopNodeEdges","isIsolated","dfsLoop","toNode2","foundid","optimizedLoops","validatedFlow","edgeToBreak"],"mappings":"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","sourcesContent":["/**\n * Graph edge structure\n * @class Edge\n * @property {string} from From node id\n * @property {string} to To node id\n */\nexport function Edge(from, to) {\n  this.from = from;\n  this.to = to;\n}\n\n/**\n * This function finds [optimal collection of feedback edges](https://en.wikipedia.org/wiki/Feedback_arc_set) needed to be cut in \n * order to eliminate loops in family structure.\n * \n * @param {Family} family Family structure\n * @returns {Edge[]} Returns optimal collection of feedback loops \n */\nexport default function getFamilyLoops(family, debug) {\n  var loops = [], loop,\n    index, len,\n    index2, len2,\n    fromNode, toNode, edge;\n\n  var tempFamily = family.clone();\n\n  family.loopTopo(this, function (itemid) {\n    tempFamily.removeNode(itemid);\n  })\n  family.loopTopoReversed(this, function (itemid) {\n    tempFamily.removeNode(itemid);\n  })\n  var cleanFamily = tempFamily.clone();\n\n  cleanFamily.loop(this, function (itemid) {\n    if (tempFamily.node(itemid) != null) {\n      cleanFamily.loopParents(this, itemid, function (parentid) {\n        loops.push(new Edge(parentid, itemid));\n        tempFamily.removeChildRelation(parentid, itemid);\n        return cleanFamily.SKIP;\n      })\n      var itemsToRemove = [];\n      tempFamily.loopTopo(this, function (itemid) {\n        itemsToRemove.push(itemid);\n      });\n      tempFamily.loopTopoReversed(this, function (itemid) {\n        itemsToRemove.push(itemid);\n      });\n      for (var index = 0; index < itemsToRemove.length; index += 1) {\n        tempFamily.removeNode(itemsToRemove[index]);\n      }\n    }\n  });\n\n  /* Invert loops */\n  for (index = 0, len = loops.length; index < len; index += 1) {\n    loop = loops[index];\n    if (!cleanFamily.removeChildRelation(loop.from, loop.to)) {\n      throw \"Relation does not exists\";\n    }\n  }\n\n  if (debug && cleanFamily.hasLoops()) {\n    throw \"Failed to clean loops in family\";\n  }\n\n  var graph = cleanFamily.getGraph(this, function (from, to) {\n    return { from: from, to: to, capacity: 1, flow: 0 };\n  });\n\n  var from = \"__1000__\";\n  var to = \"__2000__\";\n  var defaultMinimalFlow = loops.length;\n  for (index = 0, len = loops.length; index < len; index += 1) {\n    loop = loops[index];\n    edge = graph.edge(loop.from, to);\n    if (edge == null) {\n      graph.addEdge(loop.from, to, { from: loop.from, to: to, capacity: 1, flow: 0, tos: [loop.to] });\n    } else {\n      edge.capacity += 1;\n      edge.tos.push(loop.to);\n    }\n    edge = graph.edge(from, loop.to);\n    if (edge == null) {\n      graph.addEdge(from, loop.to, { from: from, to: loop.to, capacity: 1, flow: 0, froms: [loop.from] });\n    } else {\n      edge.capacity += 1;\n      edge.froms.push(loop.from);\n    }\n  }\n\n  var totalFlow = 0;\n  var levelGraph = null;\n  while (true) {\n    levelGraph = graph.getLevelGraph(this, from, function (fromNode, toNode, edge) {\n      if (fromNode == edge.from) {\n        return edge.capacity > edge.flow;\n      } else {\n        return edge.flow > 0;\n      }\n    });\n\n    if (!levelGraph.hasNode(to)) {\n      break;\n    }\n\n    while (true) {\n      var connectionPath = graph.dfsPath(this, from, to, function (fromNode, toNode, edge) {\n        if (fromNode == edge.from) {\n          return edge.capacity > edge.flow;\n        } else {\n          return edge.flow > 0;\n        }\n      });\n\n      if (connectionPath.length == 0) {\n        break;\n      }\n\n      // Find maximum flow for given path\n      var flow = Infinity;\n      for (index = 0, len = connectionPath.length; index < len - 1; index += 1) {\n        fromNode = connectionPath[index];\n        toNode = connectionPath[index + 1];\n        edge = graph.edge(fromNode, toNode);\n        var edgeFlow = 0;\n        if (edge.from == fromNode) {\n          edgeFlow = edge.capacity - edge.flow;\n        } else {\n          edgeFlow = edge.flow;\n        }\n        if (edgeFlow == 0) {\n          throw \"Broken flow path\";\n        }\n        flow = Math.min(flow, edgeFlow);\n      }\n\n      // Update graph\n      for (index = 0, len = connectionPath.length; index < len - 1; index += 1) {\n        fromNode = connectionPath[index];\n        toNode = connectionPath[index + 1];\n        edge = graph.edge(fromNode, toNode);\n        if (edge.from == fromNode) {\n          edge.flow += flow;\n        } else {\n          edge.flow -= flow;\n        }\n      }\n      totalFlow += flow;\n    }\n  }\n\n  if (totalFlow < defaultMinimalFlow) {\n    var residueGraph = graph.getLevelGraph(this, from, function (fromNode, toNode, edge) {\n      if (fromNode == edge.from) {\n        return edge.capacity > edge.flow;\n      }\n      return false;\n    });\n\n    // graph.loopNodes(this, from, function (nodeid) {\n    //   console.log(\"Nodeid: \" + nodeid);\n    //   graph.loopNodeEdges(this, nodeid, function (neighbour, edge) {\n    //     if (edge.to == neighbour) {\n    //       console.log(\"neighbour: \" + neighbour + \", edge=\" + JSON.stringify(edge));\n    //     }\n    //   })\n    // });\n\n    // var resedueNodes = [];\n    // residueGraph.loopNodes(this, from, function (nodeid) {\n    //   resedueNodes.push(nodeid);\n    // });\n    // console.log(\"Residue graph: \" + resedueNodes.join(\", \"));\n\n    var edgesToBreak = [];\n    residueGraph.loopNodes(this, from, function (nodeid) {\n      graph.loopNodeEdges(this, nodeid, function (toNode, edge) {\n        if (edge.to == toNode) {\n          if (!residueGraph.hasNode(toNode)) {\n            // console.log(\"Edge to test: from: \" + nodeid + \", to \" + toNode);\n            var isIsolated = true;\n            graph.dfsLoop(this, toNode, function (fromNode, toNode2, edge) {\n              if (edge.from == fromNode) {\n                return edge.capacity > 0;\n              }\n              return false;\n            }, function (foundid) {\n              if (residueGraph.hasNode(foundid)) {\n                // console.log(\"Non-isolated: \" + toNode + \", hits residue node\" + foundid);\n                isIsolated = false;\n                return true;\n              }\n              return false;\n            });\n            if (isIsolated) {\n              edgesToBreak.push(new Edge(nodeid, toNode));\n            }\n          }\n        }\n      });\n    });\n\n    // collect loops to break\n    var optimizedLoops = [];\n    var validatedFlow = 0;\n    for (index = 0, len = edgesToBreak.length; index < len; index += 1) {\n      var edgeToBreak = edgesToBreak[index];\n\n      if (edgeToBreak.from == from) {\n        edge = graph.edge(edgeToBreak.from, edgeToBreak.to);\n        for (index2 = 0, len2 = edge.froms.length; index2 < len2; index2 += 1) {\n          optimizedLoops.push(new Edge(edge.froms[index2], edgeToBreak.to));\n          validatedFlow += 1;\n        }\n      } else if (edgeToBreak.to == to) {\n        edge = graph.edge(edgeToBreak.from, edgeToBreak.to);\n        for (index2 = 0, len2 = edge.tos.length; index2 < len2; index2 += 1) {\n          optimizedLoops.push(new Edge(edgeToBreak.from, edge.tos[index2]));\n          validatedFlow += 1;\n        }\n      } else {\n        optimizedLoops.push(edgeToBreak);\n        validatedFlow += 1;\n      }\n    }\n    if (validatedFlow != totalFlow) {\n      throw \"Failed to properly collect edges cutting maximum flow\";\n    }\n    loops = optimizedLoops;\n  }\n  return loops;\n};"]},"metadata":{},"sourceType":"module"}