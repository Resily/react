{"ast":null,"code":"import Tree from './Tree';\nimport FibonacciHeap from './FibonacciHeap';\n/**\n * Creates graph structure\n * @class Graph\n * \n * @returns {Graph} Returns graph object\n */\n\nexport default function Graph() {\n  var _edges = {},\n      MAXIMUMTOTALWEIGHT = 1,\n      MINIMUMWEIGHT = 2;\n  /**\n   * Adds edge to the graph\n   * @param {string} from The id of the start node \n   * @param {string} to The id of the end node\n   * @param {object} edge The edge contextual object\n   */\n\n  function addEdge(from, to, edge) {\n    if ((_edges[from] == null || _edges[from][to] == null) && edge != null) {\n      if (_edges[from] == null) {\n        _edges[from] = {};\n      }\n\n      _edges[from][to] = edge;\n\n      if (_edges[to] == null) {\n        _edges[to] = {};\n      }\n\n      _edges[to][from] = edge;\n    }\n  }\n  /**\n   * Returns edge context object\n   * \n   * @param {string} from The edge's from node id\n   * @param {string} to The edge's to node id\n   * @returns {object} The edge's context object\n   */\n\n\n  function edge(from, to) {\n    var result = null;\n\n    if (_edges[from] != null && _edges[from][to]) {\n      result = _edges[from][to];\n    }\n\n    return result;\n  }\n  /**\n   * Returns true if node exists in the graph\n   * \n   * @param {string} from The node id\n   * @returns {boolean} Returns true if node exists\n   */\n\n\n  function hasNode(from) {\n    return _edges.hasOwnProperty(from);\n  }\n  /**\n   * Callback for iterating edges of the graph's node\n   * \n   * @callback onEdgeCallback\n   * @param {string} to The neighboring node id\n   * @param {Object} edge The edge's context object\n   */\n\n  /**\n   * Loop edges of the node\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} itemid The node id\n   * @param {onEdgeCallback} onEdge A callback function to call for every edge of the node\n   */\n\n\n  function loopNodeEdges(thisArg, itemid, onEdge) {\n    var neighbours, neighbourKey;\n\n    if (onEdge != null) {\n      neighbours = _edges[itemid];\n\n      if (neighbours != null) {\n        for (neighbourKey in neighbours) {\n          if (neighbours.hasOwnProperty(neighbourKey)) {\n            onEdge.call(thisArg, neighbourKey, neighbours[neighbourKey]);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Callback function for iterating graphs nodes\n   * \n   * @callback onNodeCallback\n   * @param {string} to The next neighboring node id\n   * @returns {boolean} Returns true to break loop\n   */\n\n  /**\n   * Loop nodes of the graph\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} [itemid=undefined] The optional start node id. If start node is undefined, \n   * function loops graphs node starting from first available node\n   * @param {onNodeCallback} onItem A callback function to be called for every neighboring node\n   */\n\n\n  function loopNodes(thisArg, startNode, onItem) {\n    var processed = {};\n\n    if (startNode == null) {\n      for (startNode in _edges) {\n        if (_edges.hasOwnProperty(startNode)) {\n          if (!processed.hasOwnProperty[startNode]) {\n            _loopNodes(thisArg, startNode, processed, onItem);\n          }\n        }\n      }\n    } else {\n      _loopNodes(thisArg, startNode, processed, onItem);\n    }\n  }\n\n  function _loopNodes(thisArg, startNode, processed, onItem) {\n    var margin = [],\n        marginKey,\n        newMargin,\n        index,\n        len,\n        neighbours,\n        neighbourKey;\n    margin.push(startNode);\n    processed[startNode] = true;\n\n    if (onItem != null) {\n      while (margin.length > 0) {\n        newMargin = [];\n        /* iterate neighbours of every node on margin */\n\n        for (index = 0, len = margin.length; index < len; index += 1) {\n          marginKey = margin[index];\n\n          if (onItem.call(thisArg, marginKey)) {\n            return;\n          }\n\n          neighbours = _edges[marginKey];\n\n          for (neighbourKey in neighbours) {\n            if (neighbours.hasOwnProperty(neighbourKey) && !processed.hasOwnProperty(neighbourKey)) {\n              processed[neighbourKey] = true;\n              newMargin.push(neighbourKey);\n            }\n          }\n        }\n\n        margin = newMargin;\n      }\n    }\n  }\n  /**\n   * Callback for finding edge weight\n   * \n   * @callback getGraphEdgeWeightCallback\n   * @param {object} edge The edge context object\n   * @param {string} fromItem The edge's start node id\n   * @param {string} toItem The edge's end node id\n   * @returns {number} Returns weight of the edge\n   */\n\n  /**\n   * Get maximum spanning tree. Graph may have disconnected sub graphs, so start node is necessary.\n   * \n   * @param {string} startNode The node to start searching for maximum spanning tree. Graph is not necessary connected\n   * @param {getGraphEdgeWeightCallback} getWeightFunc Callback function to get weight of an edge.\n   * @returns {tree} Returns tree structure containing maximum spanning tree of the graph\n   */\n\n\n  function getSpanningTree(startNode, getWeightFunc) {\n    var result = Tree(),\n        margin = FibonacciHeap(true),\n        marginNode,\n        parents = {},\n\n    /* if parent for item is set then it was laready visited */\n    neighbours,\n        neighbourKey,\n        neighbourWeight,\n        currentWeight;\n    /* add start node to margin */\n\n    margin.add(startNode, 0, null\n    /*parent of root node is null*/\n    );\n    parents[startNode] = null;\n    /* search graph */\n\n    while ((marginNode = margin.extractRoot()) != null) {\n      /* iterate neighbours of every node on margin */\n      neighbours = _edges[marginNode.key];\n\n      for (neighbourKey in neighbours) {\n        if (neighbours.hasOwnProperty(neighbourKey) && !result.node(neighbourKey)) {\n          neighbourWeight = getWeightFunc != null ? getWeightFunc(neighbours[neighbourKey]) : neighbours[neighbourKey];\n          currentWeight = margin.getPriority(neighbourKey);\n\n          if (currentWeight == null) {\n            margin.add(neighbourKey, neighbourWeight, null);\n            parents[neighbourKey] = marginNode.key.toString();\n          } else {\n            if (currentWeight <= neighbourWeight) {\n              /* improve node distance */\n              margin.setPriority(neighbourKey, neighbourWeight);\n              parents[neighbourKey] = marginNode.key.toString();\n            }\n          }\n        }\n      }\n      /* add next margin item to resul tree */\n\n\n      result.add(parents[marginNode.key], marginNode.key.toString(), {});\n    }\n\n    return result;\n  }\n\n  function _findStartNode(thisArg, onEdgeWeight) {\n    var result = null,\n        fromItem,\n        toItems,\n        toItem,\n        weight = 0,\n        maxWeight = null;\n\n    for (fromItem in _edges) {\n      if (_edges.hasOwnProperty(fromItem)) {\n        toItems = _edges[fromItem];\n        weight = 0;\n\n        for (toItem in toItems) {\n          if (toItems.hasOwnProperty(toItem)) {\n            weight += onEdgeWeight.call(thisArg, toItems[toItem], fromItem, toItem);\n          }\n        }\n\n        if (weight > maxWeight || maxWeight == null) {\n          result = fromItem;\n          maxWeight = weight;\n        }\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Get graph growth sequence. The sequence of graph traversing order.\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {getGraphEdgeWeightCallback} getWeightFunc Callback function to get weight of an edge. \n   * @param {onNodeCallback} onItem A callback function to be called for every node of the growth sequence \n   */\n\n\n  function getTotalWeightGrowthSequence(thisArg, onEdgeWeight, onItem) {\n    var startNode = _findStartNode(thisArg, onEdgeWeight);\n\n    _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, MAXIMUMTOTALWEIGHT);\n  }\n  /**\n   * Get minimum weight graph growth sequence. The sequence of the traversing order of the graph nodes.\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} [startNode=undefined] The optional start node id \n   * @param {getGraphEdgeWeightCallback} onEdgeWeight Callback function to get weight of an edge. \n   * @param {onNodeCallback} onItem A callback function to be called for every node of the growth sequence\n   */\n\n\n  function getMinimumWeightGrowthSequence(thisArg, startNode, onEdgeWeight, onItem) {\n    _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, MINIMUMWEIGHT);\n  }\n\n  function _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, growsMode) {\n    var margin = {},\n        marginKey,\n        itemsToRemove = [],\n\n    /* if margin item has no neighbours to expand we remove it from margin*/\n    hasNeighbours,\n        processed = {},\n\n    /* if item is set then it was already visited */\n    marginLength = 0,\n\n    /* curent margin length */\n    nextMarginKey,\n        nextMarginWeight,\n        bestWeight,\n        neighbours,\n        neighbourKey,\n        neighbourWeight,\n        index,\n        len;\n\n    if (onEdgeWeight != null && onItem != null) {\n      if (startNode == null) {\n        startNode = _findStartNode(thisArg, onEdgeWeight);\n      }\n\n      if (startNode != null) {\n        onItem.call(thisArg, startNode);\n        /* add start node to margin */\n\n        margin[startNode] = true;\n        marginLength += 1;\n        /* add startNode to result tree */\n\n        processed[startNode] = null;\n        /* search graph */\n\n        while (marginLength > 0) {\n          itemsToRemove = [];\n          nextMarginKey = null;\n          nextMarginWeight = null;\n          bestWeight = {};\n          /* iterate neighbours of every node on margin */\n\n          for (marginKey in margin) {\n            if (margin.hasOwnProperty(marginKey)) {\n              neighbours = _edges[marginKey];\n              hasNeighbours = false;\n\n              for (neighbourKey in neighbours) {\n                if (neighbours.hasOwnProperty(neighbourKey) && !processed.hasOwnProperty(neighbourKey)) {\n                  neighbourWeight = onEdgeWeight.call(thisArg, neighbours[neighbourKey], marginKey, neighbourKey);\n                  hasNeighbours = true;\n\n                  switch (growsMode) {\n                    case MAXIMUMTOTALWEIGHT:\n                      if (bestWeight[neighbourKey] == null) {\n                        bestWeight[neighbourKey] = 0;\n                      }\n\n                      bestWeight[neighbourKey] += neighbourWeight;\n\n                      if (!nextMarginWeight || bestWeight[neighbourKey] > nextMarginWeight) {\n                        nextMarginKey = neighbourKey;\n                        nextMarginWeight = bestWeight[neighbourKey];\n                      }\n\n                      break;\n\n                    case MINIMUMWEIGHT:\n                      if (bestWeight[neighbourKey] == null) {\n                        bestWeight[neighbourKey] = neighbourWeight;\n                      } else {\n                        bestWeight[neighbourKey] = Math.min(bestWeight[neighbourKey], neighbourWeight);\n                      }\n\n                      if (!nextMarginWeight || bestWeight[neighbourKey] < nextMarginWeight) {\n                        nextMarginKey = neighbourKey;\n                        nextMarginWeight = bestWeight[neighbourKey];\n                      }\n\n                      break;\n                  }\n                }\n              }\n\n              if (!hasNeighbours) {\n                itemsToRemove.push(marginKey);\n              }\n            }\n          }\n\n          if (nextMarginKey == null) {\n            /* no items to expand to exit*/\n            break;\n          } else {\n            margin[nextMarginKey] = true;\n            marginLength += 1;\n            processed[nextMarginKey] = true;\n            /* add next margin item to result sequence */\n\n            onItem.call(thisArg, nextMarginKey);\n          }\n\n          for (index = 0, len = itemsToRemove.length; index < len; index += 1) {\n            /* delete visited node from margin */\n            delete margin[itemsToRemove[index]];\n            marginLength -= 1;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Callback for returning optimal connection path for every end node.\n   * \n   * @callback onPathFoundCallback\n   * @param {string[]} path An array of connection path node ids.\n   * @param {string} to The end node id, the connection path is found for.\n   */\n\n  /**\n   * Get shortest path between two nodes in graph. The start and the end nodes are supposed to have connection path.\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} startNode The start node id \n   * @param {string[]} endNodes The array of end node ids.\n   * @param {getGraphEdgeWeightCallback} getWeightFunc Callback function to get weight of an edge. \n   * @param {onPathFoundCallback} onPathFound A callback function to be called for every end node \n   * with the optimal connection path\n   */\n\n\n  function getShortestPath(thisArg, startNode, endNodes, getWeightFunc, onPathFound) {\n    var margin = FibonacciHeap(false),\n        distance = {},\n        breadcramps = {},\n        bestNodeOnMargin,\n        key,\n        children,\n        newDistance,\n        weight,\n        path,\n        currentNode,\n        endNodesHash = {},\n        index,\n        len,\n        endsCount = 0,\n        endsFound = 0;\n    /* create hash table of end nodes to find */\n\n    for (index = 0, len = endNodes.length; index < len; index += 1) {\n      key = endNodes[index];\n\n      if (!endNodesHash.hasOwnProperty(key)) {\n        endsCount += 1;\n        endNodesHash[key] = true;\n      }\n    }\n    /* add start node to margin */\n\n\n    margin.add(startNode, 0, null);\n    breadcramps[startNode] = null;\n    /* search graph */\n\n    while ((bestNodeOnMargin = margin.extractRoot()) != null) {\n      /* iterate neighbours of selected node on margin */\n      children = _edges[bestNodeOnMargin.key];\n\n      for (key in children) {\n        if (children.hasOwnProperty(key)) {\n          weight = 1;\n\n          if (getWeightFunc != null) {\n            weight = getWeightFunc.call(thisArg, children[key], bestNodeOnMargin, key);\n            newDistance = bestNodeOnMargin.priority + weight;\n          } else {\n            newDistance = bestNodeOnMargin.priority + 1;\n          }\n\n          if (weight >= 0) {\n            distance = margin.getPriority(key);\n\n            if (distance != null) {\n              if (distance > newDistance) {\n                margin.setPriority(key, newDistance);\n                breadcramps[key] = bestNodeOnMargin.key;\n              }\n            } else {\n              if (!breadcramps.hasOwnProperty(key)) {\n                margin.add(key, newDistance, null);\n                breadcramps[key] = bestNodeOnMargin.key;\n              }\n            }\n          }\n        }\n      }\n\n      if (endNodesHash.hasOwnProperty(bestNodeOnMargin.key)) {\n        /* trace path */\n        path = [];\n        currentNode = bestNodeOnMargin.key;\n\n        while (currentNode != null) {\n          path.push(currentNode);\n          currentNode = breadcramps[currentNode];\n        }\n\n        onPathFound.call(thisArg, path, bestNodeOnMargin.key);\n        endsFound += 1;\n\n        if (endsFound >= endsCount) {\n          break;\n        }\n      }\n    }\n  }\n  /**\n   * Callback for iterating path edges\n   * \n   * @callback onPathEdgeCallback\n   * @param {string} from The from node id\n   * @param {string} to The to node id\n   * @param {Object} edge The edge's context object\n   * @returns {boolean} Returns true if edge is usable\n   */\n\n  /**\n   * Search any path from node to node using depth first search\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} startNode The start node id \n   * @param {string} endNode The end node id.\n   * @param {onPathEdgeCallback} onEdge A callback function to call for every edge of the node\n   */\n\n\n  function dfsPath(thisArg, startNode, endNode, onEdge) {\n    var margin = [],\n        backtrace = {};\n    margin.push(startNode);\n    backtrace[startNode] = null;\n\n    if (startNode != endNode) {\n      /* search graph */\n      while (margin.length > 0 && !backtrace.hasOwnProperty(endNode)) {\n        // Remove last node out of margin\n        var currentNode = margin[margin.length - 1];\n        margin.length -= 1; // search its neighbours and add them to margin\n\n        var neighbours = _edges[currentNode];\n\n        for (var neighbour in neighbours) {\n          if (neighbours.hasOwnProperty(neighbour)) {\n            if (!backtrace.hasOwnProperty(neighbour)) {\n              // node is not passed yet, check edge capacity and add new neighbour to the margin\n              if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {\n                margin.push(neighbour);\n                backtrace[neighbour] = currentNode;\n\n                if (neighbour == endNode) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    currentNode = endNode;\n    var path = [];\n\n    while (backtrace.hasOwnProperty(currentNode)) {\n      path.push(currentNode);\n      currentNode = backtrace[currentNode];\n    }\n\n    var result = [];\n\n    if (path.length > 0) {\n      for (var index = path.length - 1; index >= 0; index -= 1) {\n        result.push(path[index]);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Get Level Graph starting with `startNode`\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} startNode The start node id \n   * @param {onPathEdgeCallback} onEdge A callback function to call for every edge of the graph\n   */\n\n\n  function getLevelGraph(thisArg, startNode, onEdge) {\n    var level = {},\n        margin = [],\n        currentNode,\n        currentLevel,\n        neighbours;\n    margin.push(startNode);\n    level[startNode] = 1;\n    /* search graph level by level */\n\n    while (margin.length > 0) {\n      var newMargin = [];\n\n      for (var index = 0, len = margin.length; index < len; index += 1) {\n        currentNode = margin[index];\n        currentLevel = level[currentNode];\n        neighbours = _edges[currentNode];\n\n        for (var neighbour in neighbours) {\n          if (neighbours.hasOwnProperty(neighbour)) {\n            if (!level.hasOwnProperty(neighbour)) {\n              if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {\n                newMargin.push(neighbour);\n                level[neighbour] = currentLevel + 1;\n              }\n            }\n          }\n        }\n      }\n\n      margin = newMargin;\n    } // Create level graph, copy existing edges to the new graph\n\n\n    var levelGraph = Graph();\n\n    for (currentNode in _edges) {\n      if (level.hasOwnProperty(currentNode)) {\n        currentLevel = level[currentNode];\n        neighbours = _edges[currentNode];\n\n        for (neighbour in neighbours) {\n          if (level.hasOwnProperty(neighbour)) {\n            var neighbourLevel = level[neighbour];\n\n            if (currentLevel + 1 == neighbourLevel) {\n              levelGraph.addEdge(currentNode, neighbour, neighbours[neighbour]);\n            }\n          }\n        }\n      }\n    }\n\n    return levelGraph;\n  }\n  /**\n   * Depth first search loop\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} startNode The start node id \n   * @param {onPathEdgeCallback} onEdge A callback function to call for every edge of the graph\n   * @param {onNodeCallback} onNode A callback function to be called for every neighboring node\n   */\n\n\n  function dfsLoop(thisArg, startNode, onEdge, onNode) {\n    var margin = [],\n        visited = {},\n        currentNode;\n    margin.push(startNode);\n    visited[startNode] = true;\n    /* search graph */\n\n    while (margin.length > 0) {\n      // Remove last node out of margin\n      currentNode = margin[margin.length - 1];\n      margin.length -= 1; // search its neighbours and add them to margin\n\n      var neighbours = _edges[currentNode];\n\n      for (var neighbour in neighbours) {\n        if (neighbours.hasOwnProperty(neighbour)) {\n          if (!visited.hasOwnProperty(neighbour)) {\n            // node is not passed yet, check edge capacity and add new neighbour to the margin\n            if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {\n              margin.push(neighbour);\n              visited[neighbour] = true;\n\n              if (onNode.call(thisArg, neighbour)) {\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    addEdge: addEdge,\n    edge: edge,\n    hasNode: hasNode,\n    loopNodes: loopNodes,\n    loopNodeEdges: loopNodeEdges,\n    getSpanningTree: getSpanningTree,\n    getTotalWeightGrowthSequence: getTotalWeightGrowthSequence,\n    getMinimumWeightGrowthSequence: getMinimumWeightGrowthSequence,\n    getShortestPath: getShortestPath,\n    dfsPath: dfsPath,\n    getLevelGraph: getLevelGraph,\n    dfsLoop: dfsLoop\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/Graph.js"],"names":["Tree","FibonacciHeap","Graph","_edges","MAXIMUMTOTALWEIGHT","MINIMUMWEIGHT","addEdge","from","to","edge","result","hasNode","hasOwnProperty","loopNodeEdges","thisArg","itemid","onEdge","neighbours","neighbourKey","call","loopNodes","startNode","onItem","processed","_loopNodes","margin","marginKey","newMargin","index","len","push","length","getSpanningTree","getWeightFunc","marginNode","parents","neighbourWeight","currentWeight","add","extractRoot","key","node","getPriority","toString","setPriority","_findStartNode","onEdgeWeight","fromItem","toItems","toItem","weight","maxWeight","getTotalWeightGrowthSequence","_getGrowthSequence","getMinimumWeightGrowthSequence","growsMode","itemsToRemove","hasNeighbours","marginLength","nextMarginKey","nextMarginWeight","bestWeight","Math","min","getShortestPath","endNodes","onPathFound","distance","breadcramps","bestNodeOnMargin","children","newDistance","path","currentNode","endNodesHash","endsCount","endsFound","priority","dfsPath","endNode","backtrace","neighbour","getLevelGraph","level","currentLevel","levelGraph","neighbourLevel","dfsLoop","onNode","visited"],"mappings":"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","sourcesContent":["import Tree from './Tree';\nimport FibonacciHeap from './FibonacciHeap';\n/**\n * Creates graph structure\n * @class Graph\n * \n * @returns {Graph} Returns graph object\n */\nexport default function Graph() {\n  var _edges = {},\n    MAXIMUMTOTALWEIGHT = 1,\n    MINIMUMWEIGHT = 2;\n\n  /**\n   * Adds edge to the graph\n   * @param {string} from The id of the start node \n   * @param {string} to The id of the end node\n   * @param {object} edge The edge contextual object\n   */\n  function addEdge(from, to, edge) {\n    if ((_edges[from] == null || _edges[from][to] == null) && edge != null) {\n\n      if (_edges[from] == null) {\n        _edges[from] = {};\n      }\n      _edges[from][to] = edge;\n\n      if (_edges[to] == null) {\n        _edges[to] = {};\n      }\n      _edges[to][from] = edge;\n    }\n  }\n\n  /**\n   * Returns edge context object\n   * \n   * @param {string} from The edge's from node id\n   * @param {string} to The edge's to node id\n   * @returns {object} The edge's context object\n   */\n  function edge(from, to) {\n    var result = null;\n    if (_edges[from] != null && _edges[from][to]) {\n      result = _edges[from][to];\n    }\n    return result;\n  }\n\n  /**\n   * Returns true if node exists in the graph\n   * \n   * @param {string} from The node id\n   * @returns {boolean} Returns true if node exists\n   */\n  function hasNode(from) {\n    return _edges.hasOwnProperty(from);\n  }\n\n  /**\n   * Callback for iterating edges of the graph's node\n   * \n   * @callback onEdgeCallback\n   * @param {string} to The neighboring node id\n   * @param {Object} edge The edge's context object\n   */\n\n  /**\n   * Loop edges of the node\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} itemid The node id\n   * @param {onEdgeCallback} onEdge A callback function to call for every edge of the node\n   */\n  function loopNodeEdges(thisArg, itemid, onEdge) {\n    var neighbours, neighbourKey;\n    if (onEdge != null) {\n      neighbours = _edges[itemid];\n      if (neighbours != null) {\n        for (neighbourKey in neighbours) {\n          if (neighbours.hasOwnProperty(neighbourKey)) {\n            onEdge.call(thisArg, neighbourKey, neighbours[neighbourKey]);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Callback function for iterating graphs nodes\n   * \n   * @callback onNodeCallback\n   * @param {string} to The next neighboring node id\n   * @returns {boolean} Returns true to break loop\n   */\n\n  /**\n   * Loop nodes of the graph\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} [itemid=undefined] The optional start node id. If start node is undefined, \n   * function loops graphs node starting from first available node\n   * @param {onNodeCallback} onItem A callback function to be called for every neighboring node\n   */\n  function loopNodes(thisArg, startNode, onItem) {\n    var processed = {};\n    if (startNode == null) {\n      for (startNode in _edges) {\n        if (_edges.hasOwnProperty(startNode)) {\n          if (!processed.hasOwnProperty[startNode]) {\n            _loopNodes(thisArg, startNode, processed, onItem);\n          }\n        }\n      }\n    } else {\n      _loopNodes(thisArg, startNode, processed, onItem);\n    }\n  }\n\n  function _loopNodes(thisArg, startNode, processed, onItem) {\n    var margin = [],\n      marginKey,\n      newMargin,\n      index, len,\n      neighbours, neighbourKey;\n\n    margin.push(startNode);\n    processed[startNode] = true;\n    if (onItem != null) {\n      while (margin.length > 0) {\n        newMargin = [];\n\n        /* iterate neighbours of every node on margin */\n        for (index = 0, len = margin.length; index < len; index += 1) {\n          marginKey = margin[index];\n\n          if (onItem.call(thisArg, marginKey)) {\n            return;\n          }\n\n          neighbours = _edges[marginKey];\n          for (neighbourKey in neighbours) {\n            if (neighbours.hasOwnProperty(neighbourKey) && !processed.hasOwnProperty(neighbourKey)) {\n              processed[neighbourKey] = true;\n              newMargin.push(neighbourKey);\n            }\n          }\n        }\n        margin = newMargin;\n      }\n    }\n  }\n\n  /**\n   * Callback for finding edge weight\n   * \n   * @callback getGraphEdgeWeightCallback\n   * @param {object} edge The edge context object\n   * @param {string} fromItem The edge's start node id\n   * @param {string} toItem The edge's end node id\n   * @returns {number} Returns weight of the edge\n   */\n\n  /**\n   * Get maximum spanning tree. Graph may have disconnected sub graphs, so start node is necessary.\n   * \n   * @param {string} startNode The node to start searching for maximum spanning tree. Graph is not necessary connected\n   * @param {getGraphEdgeWeightCallback} getWeightFunc Callback function to get weight of an edge.\n   * @returns {tree} Returns tree structure containing maximum spanning tree of the graph\n   */\n  function getSpanningTree(startNode, getWeightFunc) {\n    var result = Tree(),\n      margin = FibonacciHeap(true),\n      marginNode,\n      parents = {}, /* if parent for item is set then it was laready visited */\n      neighbours, neighbourKey, neighbourWeight, currentWeight;\n\n    /* add start node to margin */\n    margin.add(startNode, 0, null /*parent of root node is null*/);\n    parents[startNode] = null;\n\n    /* search graph */\n    while ((marginNode = margin.extractRoot()) != null) {\n\n      /* iterate neighbours of every node on margin */\n      neighbours = _edges[marginNode.key];\n\n      for (neighbourKey in neighbours) {\n        if (neighbours.hasOwnProperty(neighbourKey) && !result.node(neighbourKey)) {\n          neighbourWeight = getWeightFunc != null ? getWeightFunc(neighbours[neighbourKey]) : neighbours[neighbourKey];\n\n          currentWeight = margin.getPriority(neighbourKey);\n          if (currentWeight == null) {\n            margin.add(neighbourKey, neighbourWeight, null);\n            parents[neighbourKey] = marginNode.key.toString();\n          } else {\n            if (currentWeight <= neighbourWeight) {\n              /* improve node distance */\n              margin.setPriority(neighbourKey, neighbourWeight);\n              parents[neighbourKey] = marginNode.key.toString();\n            }\n          }\n        }\n      }\n\n      /* add next margin item to resul tree */\n      result.add(parents[marginNode.key], marginNode.key.toString(), {});\n    }\n\n    return result;\n  }\n\n  function _findStartNode(thisArg, onEdgeWeight) {\n    var result = null,\n      fromItem, toItems, toItem,\n      weight = 0,\n      maxWeight = null;\n\n    for (fromItem in _edges) {\n      if (_edges.hasOwnProperty(fromItem)) {\n        toItems = _edges[fromItem];\n\n        weight = 0;\n        for (toItem in toItems) {\n          if (toItems.hasOwnProperty(toItem)) {\n            weight += onEdgeWeight.call(thisArg, toItems[toItem], fromItem, toItem);\n          }\n        }\n        if (weight > maxWeight || maxWeight == null) {\n          result = fromItem;\n          maxWeight = weight;\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Get graph growth sequence. The sequence of graph traversing order.\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {getGraphEdgeWeightCallback} getWeightFunc Callback function to get weight of an edge. \n   * @param {onNodeCallback} onItem A callback function to be called for every node of the growth sequence \n   */\n  function getTotalWeightGrowthSequence(thisArg, onEdgeWeight, onItem) {\n    var startNode = _findStartNode(thisArg, onEdgeWeight);\n\n    _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, MAXIMUMTOTALWEIGHT);\n  }\n\n  /**\n   * Get minimum weight graph growth sequence. The sequence of the traversing order of the graph nodes.\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} [startNode=undefined] The optional start node id \n   * @param {getGraphEdgeWeightCallback} onEdgeWeight Callback function to get weight of an edge. \n   * @param {onNodeCallback} onItem A callback function to be called for every node of the growth sequence\n   */\n  function getMinimumWeightGrowthSequence(thisArg, startNode, onEdgeWeight, onItem) {\n    _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, MINIMUMWEIGHT);\n  }\n\n  function _getGrowthSequence(thisArg, startNode, onEdgeWeight, onItem, growsMode) {\n    var margin = {}, marginKey,\n      itemsToRemove = [], /* if margin item has no neighbours to expand we remove it from margin*/\n      hasNeighbours,\n      processed = {}, /* if item is set then it was already visited */\n      marginLength = 0, /* curent margin length */\n      nextMarginKey,\n      nextMarginWeight,\n      bestWeight,\n      neighbours, neighbourKey, neighbourWeight,\n      index, len;\n\n    if (onEdgeWeight != null && onItem != null) {\n      if (startNode == null) {\n        startNode = _findStartNode(thisArg, onEdgeWeight);\n      }\n\n      if (startNode != null) {\n\n        onItem.call(thisArg, startNode);\n\n        /* add start node to margin */\n        margin[startNode] = true;\n        marginLength += 1;\n\n        /* add startNode to result tree */\n        processed[startNode] = null;\n\n        /* search graph */\n        while (marginLength > 0) {\n          itemsToRemove = [];\n          nextMarginKey = null;\n          nextMarginWeight = null;\n          bestWeight = {};\n          /* iterate neighbours of every node on margin */\n          for (marginKey in margin) {\n            if (margin.hasOwnProperty(marginKey)) {\n              neighbours = _edges[marginKey];\n              hasNeighbours = false;\n\n              for (neighbourKey in neighbours) {\n                if (neighbours.hasOwnProperty(neighbourKey) && !processed.hasOwnProperty(neighbourKey)) {\n                  neighbourWeight = onEdgeWeight.call(thisArg, neighbours[neighbourKey], marginKey, neighbourKey);\n                  hasNeighbours = true;\n\n                  switch (growsMode) {\n                    case MAXIMUMTOTALWEIGHT:\n                      if (bestWeight[neighbourKey] == null) {\n                        bestWeight[neighbourKey] = 0;\n                      }\n                      bestWeight[neighbourKey] += neighbourWeight;\n\n                      if (!nextMarginWeight || bestWeight[neighbourKey] > nextMarginWeight) {\n                        nextMarginKey = neighbourKey;\n                        nextMarginWeight = bestWeight[neighbourKey];\n                      }\n                      break;\n                    case MINIMUMWEIGHT:\n                      if (bestWeight[neighbourKey] == null) {\n                        bestWeight[neighbourKey] = neighbourWeight;\n                      } else {\n                        bestWeight[neighbourKey] = Math.min(bestWeight[neighbourKey], neighbourWeight);\n                      }\n\n                      if (!nextMarginWeight || bestWeight[neighbourKey] < nextMarginWeight) {\n                        nextMarginKey = neighbourKey;\n                        nextMarginWeight = bestWeight[neighbourKey];\n                      }\n                      break;\n                  }\n                }\n              }\n\n              if (!hasNeighbours) {\n                itemsToRemove.push(marginKey);\n              }\n            }\n          }\n\n          if (nextMarginKey == null) {\n            /* no items to expand to exit*/\n            break;\n          } else {\n            margin[nextMarginKey] = true;\n            marginLength += 1;\n            processed[nextMarginKey] = true;\n\n            /* add next margin item to result sequence */\n            onItem.call(thisArg, nextMarginKey);\n          }\n\n          for (index = 0, len = itemsToRemove.length; index < len; index += 1) {\n            /* delete visited node from margin */\n            delete margin[itemsToRemove[index]];\n            marginLength -= 1;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Callback for returning optimal connection path for every end node.\n   * \n   * @callback onPathFoundCallback\n   * @param {string[]} path An array of connection path node ids.\n   * @param {string} to The end node id, the connection path is found for.\n   */\n\n  /**\n   * Get shortest path between two nodes in graph. The start and the end nodes are supposed to have connection path.\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} startNode The start node id \n   * @param {string[]} endNodes The array of end node ids.\n   * @param {getGraphEdgeWeightCallback} getWeightFunc Callback function to get weight of an edge. \n   * @param {onPathFoundCallback} onPathFound A callback function to be called for every end node \n   * with the optimal connection path\n   */\n  function getShortestPath(thisArg, startNode, endNodes, getWeightFunc, onPathFound) {\n    var margin = FibonacciHeap(false),\n      distance = {},\n      breadcramps = {},\n      bestNodeOnMargin,\n      key,\n      children,\n      newDistance,\n      weight,\n      path,\n      currentNode,\n      endNodesHash = {},\n      index, len,\n      endsCount = 0, endsFound = 0;\n\n    /* create hash table of end nodes to find */\n    for (index = 0, len = endNodes.length; index < len; index += 1) {\n      key = endNodes[index];\n\n      if (!endNodesHash.hasOwnProperty(key)) {\n        endsCount += 1;\n        endNodesHash[key] = true;\n      }\n    }\n\n    /* add start node to margin */\n    margin.add(startNode, 0, null);\n    breadcramps[startNode] = null;\n\n    /* search graph */\n    while ((bestNodeOnMargin = margin.extractRoot()) != null) {\n      /* iterate neighbours of selected node on margin */\n      children = _edges[bestNodeOnMargin.key];\n      for (key in children) {\n        if (children.hasOwnProperty(key)) {\n          weight = 1;\n          if (getWeightFunc != null) {\n            weight = getWeightFunc.call(thisArg, children[key], bestNodeOnMargin, key);\n            newDistance = bestNodeOnMargin.priority + weight;\n          } else {\n            newDistance = bestNodeOnMargin.priority + 1;\n          }\n          if (weight >= 0) {\n            distance = margin.getPriority(key);\n            if (distance != null) {\n              if (distance > newDistance) {\n                margin.setPriority(key, newDistance);\n                breadcramps[key] = bestNodeOnMargin.key;\n              }\n            } else {\n              if (!breadcramps.hasOwnProperty(key)) {\n                margin.add(key, newDistance, null);\n                breadcramps[key] = bestNodeOnMargin.key;\n              }\n            }\n          }\n        }\n      }\n\n      if (endNodesHash.hasOwnProperty(bestNodeOnMargin.key)) {\n        /* trace path */\n        path = [];\n        currentNode = bestNodeOnMargin.key;\n        while (currentNode != null) {\n          path.push(currentNode);\n          currentNode = breadcramps[currentNode];\n        }\n        onPathFound.call(thisArg, path, bestNodeOnMargin.key);\n\n        endsFound += 1;\n        if (endsFound >= endsCount) {\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Callback for iterating path edges\n   * \n   * @callback onPathEdgeCallback\n   * @param {string} from The from node id\n   * @param {string} to The to node id\n   * @param {Object} edge The edge's context object\n   * @returns {boolean} Returns true if edge is usable\n   */\n\n  /**\n   * Search any path from node to node using depth first search\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} startNode The start node id \n   * @param {string} endNode The end node id.\n   * @param {onPathEdgeCallback} onEdge A callback function to call for every edge of the node\n   */\n  function dfsPath(thisArg, startNode, endNode, onEdge) {\n    var margin = [],\n      backtrace = {};\n\n    margin.push(startNode);\n    backtrace[startNode] = null;\n\n    if (startNode != endNode) {\n      /* search graph */\n      while (margin.length > 0 && !backtrace.hasOwnProperty(endNode)) {\n        // Remove last node out of margin\n        var currentNode = margin[margin.length - 1];\n        margin.length -= 1;\n\n        // search its neighbours and add them to margin\n        var neighbours = _edges[currentNode];\n        for (var neighbour in neighbours) {\n          if (neighbours.hasOwnProperty(neighbour)) {\n            if (!backtrace.hasOwnProperty(neighbour)) {\n              // node is not passed yet, check edge capacity and add new neighbour to the margin\n              if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {\n                margin.push(neighbour);\n                backtrace[neighbour] = currentNode;\n                if (neighbour == endNode) {\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    currentNode = endNode;\n    var path = [];\n    while (backtrace.hasOwnProperty(currentNode)) {\n      path.push(currentNode);\n      currentNode = backtrace[currentNode];\n    }\n    var result = [];\n    if (path.length > 0) {\n      for (var index = path.length - 1; index >= 0; index -= 1) {\n        result.push(path[index]);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Get Level Graph starting with `startNode`\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} startNode The start node id \n   * @param {onPathEdgeCallback} onEdge A callback function to call for every edge of the graph\n   */\n  function getLevelGraph(thisArg, startNode, onEdge) {\n    var level = {},\n      margin = [],\n      currentNode,\n      currentLevel,\n      neighbours;\n\n    margin.push(startNode);\n    level[startNode] = 1;\n\n    /* search graph level by level */\n    while (margin.length > 0) {\n      var newMargin = [];\n      for (var index = 0, len = margin.length; index < len; index += 1) {\n        currentNode = margin[index];\n        currentLevel = level[currentNode];\n        neighbours = _edges[currentNode];\n        for (var neighbour in neighbours) {\n          if (neighbours.hasOwnProperty(neighbour)) {\n            if (!level.hasOwnProperty(neighbour)) {\n              if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {\n                newMargin.push(neighbour);\n                level[neighbour] = currentLevel + 1;\n              }\n            }\n          }\n        }\n      }\n      margin = newMargin;\n    }\n\n    // Create level graph, copy existing edges to the new graph\n  var levelGraph = Graph();\n    for (currentNode in _edges) {\n      if (level.hasOwnProperty(currentNode)) {\n        currentLevel = level[currentNode];\n        neighbours = _edges[currentNode];\n        for (neighbour in neighbours) {\n          if (level.hasOwnProperty(neighbour)) {\n            var neighbourLevel = level[neighbour];\n            if (currentLevel + 1 == neighbourLevel) {\n              levelGraph.addEdge(currentNode, neighbour, neighbours[neighbour]);\n            }\n          }\n        }\n      }\n    }\n\n    return levelGraph;\n  }\n\n  /**\n   * Depth first search loop\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {string} startNode The start node id \n   * @param {onPathEdgeCallback} onEdge A callback function to call for every edge of the graph\n   * @param {onNodeCallback} onNode A callback function to be called for every neighboring node\n   */\n  function dfsLoop(thisArg, startNode, onEdge, onNode) {\n    var margin = [],\n      visited = {},\n      currentNode;\n\n    margin.push(startNode);\n    visited[startNode] = true;\n\n    /* search graph */\n    while (margin.length > 0) {\n      // Remove last node out of margin\n      currentNode = margin[margin.length - 1];\n      margin.length -= 1;\n\n      // search its neighbours and add them to margin\n      var neighbours = _edges[currentNode];\n      for (var neighbour in neighbours) {\n        if (neighbours.hasOwnProperty(neighbour)) {\n          if (!visited.hasOwnProperty(neighbour)) {\n            // node is not passed yet, check edge capacity and add new neighbour to the margin\n            if (onEdge.call(thisArg, currentNode, neighbour, neighbours[neighbour])) {\n              margin.push(neighbour);\n              visited[neighbour] = true;\n              if (onNode.call(thisArg, neighbour)) {\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    addEdge: addEdge,\n    edge: edge,\n    hasNode: hasNode,\n    loopNodes: loopNodes,\n    loopNodeEdges: loopNodeEdges,\n    getSpanningTree: getSpanningTree,\n    getTotalWeightGrowthSequence: getTotalWeightGrowthSequence,\n    getMinimumWeightGrowthSequence: getMinimumWeightGrowthSequence,\n    getShortestPath: getShortestPath,\n    dfsPath: dfsPath,\n    getLevelGraph: getLevelGraph,\n    dfsLoop: dfsLoop\n  };\n};\n"]},"metadata":{},"sourceType":"module"}