{"ast":null,"code":"import { LoopsLayoutMode } from '../../enums';\nimport getFamilyLoops from '../../algorithms/getFamilyLoops';\nimport FamilyItem from '../../models/FamilyItem';\nimport { GroupByType } from '../../enums';\nexport default function RemoveLoopsTask(itemsOptionTask, removeLoopsOptionTask, logicalFamilyTask) {\n  var _data = {\n    logicalFamily: null,\n    maximumId: null,\n    loops: [] // populate collection of pairs between fake parents and fake children\n\n  };\n\n  function process(debug) {\n    var logicalFamily = logicalFamilyTask.getLogicalFamily(),\n        maximumId = logicalFamilyTask.getMaximumId(),\n        items = itemsOptionTask.getItems(),\n        options = removeLoopsOptionTask.getOptions(),\n        loopsLayoutMode = options.loopsLayoutMode;\n    var result = removeLoops(loopsLayoutMode, items, logicalFamily, maximumId, debug);\n    _data.logicalFamily = result.logicalFamily;\n    _data.maximumId = result.maximumId;\n    _data.loops = result.loops;\n\n    if (debug && !logicalFamily.validate()) {\n      throw \"References are broken in family structure!\";\n    }\n\n    return true;\n  }\n\n  function removeLoops(loopsLayoutMode, items, logicalFamily, maximumId, debug) {\n    var fakeChild,\n        fakeParent,\n        index,\n        len,\n        index2,\n        len2,\n        edgesToReverse = getInOrderLoops(items, logicalFamily),\n        fakePairs = [];\n\n    if (edgesToReverse.length > 1 && loopsLayoutMode == LoopsLayoutMode.Optimized) {\n      edgesToReverse = getFamilyLoops(logicalFamily, debug);\n    } // group edges by child node\n\n\n    var loops = [];\n    var loopsHash = {};\n\n    for (index = 0, len = edgesToReverse.length; index < len; index += 1) {\n      var edge = edgesToReverse[index];\n\n      if (!loopsHash.hasOwnProperty(edge.to)) {\n        loopsHash[edge.to] = {\n          itemid: edge.to,\n          parents: [edge.from]\n        };\n        loops.push(loopsHash[edge.to]);\n      } else {\n        loopsHash[edge.to].parents.push(edge.from);\n      }\n    }\n\n    var fakeChildren = {}; // reuse fake children across removed edges\n\n    if (loops.length > 0) {\n      logicalFamily = logicalFamily.clone();\n\n      for (index = 0, len = loops.length; index < len; index += 1) {\n        var loop = loops[index];\n        var parents = loop.parents;\n        var itemParents = [];\n        logicalFamily.loopParents(this, loop.itemid, function (parentid, parent) {\n          itemParents.push(parentid);\n          return logicalFamily.SKIP;\n        });\n\n        for (index2 = 0, len2 = itemParents.length; index2 < len2; index2 += 1) {\n          /* remove relation in temp structure */\n          logicalFamily.removeChildRelation(itemParents[index2], loop.itemid);\n        }\n        /* create fake parent and child items to loop item to its parent */\n\n\n        maximumId += 1;\n        var isConnectionsVisible = itemParents.length <= parents.length;\n        /* add fake parent */\n\n        fakeParent = new FamilyItem({\n          id: maximumId,\n          isVisible: false,\n          isActive: false,\n          isLevelNeutral: true,\n          hideParentConnection: isConnectionsVisible,\n          hideChildrenConnection: isConnectionsVisible,\n          levelGravity: GroupByType.Children,\n          itemConfig: {\n            title: \"fake parent #\" + maximumId,\n            description: \"This is fake parent item was created by loops reversal.\"\n          }\n        });\n        logicalFamily.add([], fakeParent.id, fakeParent);\n        logicalFamily.adopt([fakeParent.id], loop.itemid);\n\n        for (index2 = 0, len2 = parents.length; index2 < len2; index2 += 1) {\n          var parentid = parents[index2];\n          fakeChild = fakeChildren[parentid];\n\n          if (fakeChild == null) {\n            /* add fake child */\n            maximumId += 1;\n            fakeChild = new FamilyItem({\n              id: maximumId,\n              isVisible: false,\n              isActive: false,\n              isLevelNeutral: true,\n              hideParentConnection: true,\n              hideChildrenConnection: true,\n              levelGravity: GroupByType.Parents,\n              itemConfig: {\n                title: \"fake child #\" + maximumId,\n                description: \"This is fake child item was created by loops reversal.\"\n              }\n            });\n            fakeChildren[parentid] = fakeChild;\n            logicalFamily.add([parentid], fakeChild.id, fakeChild);\n          }\n\n          logicalFamily.adopt([fakeParent.id], fakeChild.id);\n          fakePairs.push({\n            from: fakeParent.id,\n            to: fakeChild.id\n          });\n        } // assign remaining parents of our item to the fake parent\n\n\n        var parentsHash = {};\n\n        for (index2 = 0, len2 = parents.length; index2 < len2; index2 += 1) {\n          parentsHash[parents[index2]] = true;\n        }\n\n        for (index2 = 0, len2 = itemParents.length; index2 < len2; index2 += 1) {\n          if (!parentsHash.hasOwnProperty(itemParents[index2])) {\n            logicalFamily.adopt([itemParents[index2]], fakeParent.id);\n          }\n        }\n      }\n    }\n\n    return {\n      maximumId: maximumId,\n      logicalFamily: logicalFamily,\n      loops: fakePairs\n    };\n  }\n\n  function getInOrderLoops(items, logicalFamily) {\n    var tempFamily,\n        index,\n        len,\n        index2,\n        len2,\n        nodesToRemove,\n        parents,\n        userItem,\n        result = [];\n    tempFamily = logicalFamily.clone();\n    logicalFamily.loopTopo(this, function (itemid, item, levelIndex) {\n      tempFamily.removeNode(itemid);\n    });\n\n    if (tempFamily.hasNodes()) {\n      /* remove parents of the first remaining item in user order*/\n      for (index = 0, len = items.length; index < len; index += 1) {\n        userItem = items[index];\n\n        if (tempFamily.node(userItem.id) != null) {\n          parents = [];\n          tempFamily.loopParents(this, userItem.id, function (parentid, parent, level) {\n            parents.push(parentid);\n            result.push({\n              from: parentid,\n              to: userItem.id\n            });\n            return tempFamily.SKIP;\n          }); //ignore jslint\n\n          for (index2 = 0, len2 = parents.length; index2 < len2; index2 += 1) {\n            /* remove relation in temp structure */\n            tempFamily.removeRelation(parents[index2], userItem.id);\n          }\n          /* loop is broken, so continue items removal in topological order */\n\n\n          nodesToRemove = [];\n          tempFamily.loopTopo(this, function (itemid, item, levelIndex) {\n            nodesToRemove.push(itemid);\n          }); //ignore jslint\n\n          for (index2 = 0, len2 = nodesToRemove.length; index2 < len2; index2 += 1) {\n            tempFamily.removeNode(nodesToRemove[index2]);\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function getLogicalFamily() {\n    return _data.logicalFamily;\n  }\n\n  function getMaximumId() {\n    return _data.maximumId;\n  }\n\n  function getLoops() {\n    return _data.loops;\n  }\n\n  return {\n    process: process,\n    getLogicalFamily: getLogicalFamily,\n    getMaximumId: getMaximumId,\n    getLoops: getLoops\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/tasks/transformations/RemoveLoopsTask.js"],"names":["LoopsLayoutMode","getFamilyLoops","FamilyItem","GroupByType","RemoveLoopsTask","itemsOptionTask","removeLoopsOptionTask","logicalFamilyTask","_data","logicalFamily","maximumId","loops","process","debug","getLogicalFamily","getMaximumId","items","getItems","options","getOptions","loopsLayoutMode","result","removeLoops","validate","fakeChild","fakeParent","index","len","index2","len2","edgesToReverse","getInOrderLoops","fakePairs","length","Optimized","loopsHash","edge","hasOwnProperty","to","itemid","parents","from","push","fakeChildren","clone","loop","itemParents","loopParents","parentid","parent","SKIP","removeChildRelation","isConnectionsVisible","id","isVisible","isActive","isLevelNeutral","hideParentConnection","hideChildrenConnection","levelGravity","Children","itemConfig","title","description","add","adopt","Parents","parentsHash","tempFamily","nodesToRemove","userItem","loopTopo","item","levelIndex","removeNode","hasNodes","node","level","removeRelation","getLoops"],"mappings":"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","sourcesContent":["import { LoopsLayoutMode } from '../../enums';\nimport getFamilyLoops from '../../algorithms/getFamilyLoops';\nimport FamilyItem from '../../models/FamilyItem';\nimport { GroupByType } from '../../enums';\n\nexport default function RemoveLoopsTask(itemsOptionTask, removeLoopsOptionTask, logicalFamilyTask) {\n  var _data = {\n    logicalFamily: null,\n    maximumId: null,\n    loops: [] // populate collection of pairs between fake parents and fake children\n  };\n\n  function process(debug) {\n    var logicalFamily = logicalFamilyTask.getLogicalFamily(),\n      maximumId = logicalFamilyTask.getMaximumId(),\n      items = itemsOptionTask.getItems(),\n      options = removeLoopsOptionTask.getOptions(),\n      loopsLayoutMode = options.loopsLayoutMode;\n\n    var result = removeLoops(loopsLayoutMode, items, logicalFamily, maximumId, debug);\n\n    _data.logicalFamily = result.logicalFamily;\n    _data.maximumId = result.maximumId;\n    _data.loops = result.loops;\n\n    if (debug && !logicalFamily.validate()) {\n      throw \"References are broken in family structure!\";\n    }\n\n    return true;\n  }\n\n  function removeLoops(loopsLayoutMode, items, logicalFamily, maximumId, debug) {\n    var fakeChild, fakeParent,\n      index, len,\n      index2, len2,\n      edgesToReverse = getInOrderLoops(items, logicalFamily),\n      fakePairs = [];\n\n    if (edgesToReverse.length > 1 && loopsLayoutMode == LoopsLayoutMode.Optimized) {\n      edgesToReverse = getFamilyLoops(logicalFamily, debug);\n    }\n\n    // group edges by child node\n    var loops = [];\n    var loopsHash = {};\n    for (index = 0, len = edgesToReverse.length; index < len; index += 1) {\n      var edge = edgesToReverse[index];\n\n      if (!loopsHash.hasOwnProperty(edge.to)) {\n        loopsHash[edge.to] = { itemid: edge.to, parents: [edge.from] };\n        loops.push(loopsHash[edge.to]);\n      } else {\n        loopsHash[edge.to].parents.push(edge.from);\n      }\n    }\n\n    var fakeChildren = {}; // reuse fake children across removed edges\n    if (loops.length > 0) {\n      logicalFamily = logicalFamily.clone();\n      for (index = 0, len = loops.length; index < len; index += 1) {\n        var loop = loops[index];\n        var parents = loop.parents;\n\n        var itemParents = [];\n        logicalFamily.loopParents(this, loop.itemid, function (parentid, parent) {\n          itemParents.push(parentid);\n          return logicalFamily.SKIP;\n        });\n\n        for (index2 = 0, len2 = itemParents.length; index2 < len2; index2 += 1) {\n          /* remove relation in temp structure */\n          logicalFamily.removeChildRelation(itemParents[index2], loop.itemid);\n        }\n\n        /* create fake parent and child items to loop item to its parent */\n        maximumId += 1;\n\n        var isConnectionsVisible = (itemParents.length <= parents.length);\n        /* add fake parent */\n        fakeParent = new FamilyItem({\n          id: (maximumId),\n          isVisible: false,\n          isActive: false,\n          isLevelNeutral: true,\n          hideParentConnection: isConnectionsVisible,\n          hideChildrenConnection: isConnectionsVisible,\n          levelGravity: GroupByType.Children,\n          itemConfig: { title: \"fake parent #\" + maximumId, description: \"This is fake parent item was created by loops reversal.\" }\n        });\n\n        logicalFamily.add([], fakeParent.id, fakeParent);\n        logicalFamily.adopt([fakeParent.id], loop.itemid);\n\n        for (index2 = 0, len2 = parents.length; index2 < len2; index2 += 1) {\n          var parentid = parents[index2];\n\n          fakeChild = fakeChildren[parentid];\n\n          if (fakeChild == null) {\n            /* add fake child */\n            maximumId += 1;\n            fakeChild = new FamilyItem({\n              id: (maximumId),\n              isVisible: false,\n              isActive: false,\n              isLevelNeutral: true,\n              hideParentConnection: true,\n              hideChildrenConnection: true,\n              levelGravity: GroupByType.Parents,\n              itemConfig: { title: \"fake child #\" + maximumId, description: \"This is fake child item was created by loops reversal.\" }\n            });\n            fakeChildren[parentid] = fakeChild;\n\n            logicalFamily.add([parentid], fakeChild.id, fakeChild);\n          }\n\n          logicalFamily.adopt([fakeParent.id], fakeChild.id);\n          fakePairs.push({ from: fakeParent.id, to: fakeChild.id });\n\n        }\n\n        // assign remaining parents of our item to the fake parent\n        var parentsHash = {};\n        for (index2 = 0, len2 = parents.length; index2 < len2; index2 += 1) {\n          parentsHash[parents[index2]] = true;\n        }\n        for (index2 = 0, len2 = itemParents.length; index2 < len2; index2 += 1) {\n          if (!parentsHash.hasOwnProperty(itemParents[index2])) {\n            logicalFamily.adopt([itemParents[index2]], fakeParent.id);\n          }\n        }\n      }\n    }\n    return {\n      maximumId: maximumId,\n      logicalFamily: logicalFamily,\n      loops: fakePairs\n    }\n  }\n\n  function getInOrderLoops(items, logicalFamily) {\n    var tempFamily,\n      index, len,\n      index2, len2,\n      nodesToRemove,\n      parents,\n      userItem,\n      result = [];\n\n    tempFamily = logicalFamily.clone();\n    logicalFamily.loopTopo(this, function (itemid, item, levelIndex) {\n      tempFamily.removeNode(itemid);\n    });\n\n    if (tempFamily.hasNodes()) {\n      /* remove parents of the first remaining item in user order*/\n      for (index = 0, len = items.length; index < len; index += 1) {\n        userItem = items[index];\n\n        if (tempFamily.node(userItem.id) != null) {\n\n          parents = [];\n          tempFamily.loopParents(this, userItem.id, function (parentid, parent, level) {\n            parents.push(parentid);\n            result.push({ from: parentid, to: userItem.id });\n            return tempFamily.SKIP;\n          }); //ignore jslint\n\n          for (index2 = 0, len2 = parents.length; index2 < len2; index2 += 1) {\n            /* remove relation in temp structure */\n            tempFamily.removeRelation(parents[index2], userItem.id);\n          }\n\n          /* loop is broken, so continue items removal in topological order */\n          nodesToRemove = [];\n          tempFamily.loopTopo(this, function (itemid, item, levelIndex) {\n            nodesToRemove.push(itemid);\n          }); //ignore jslint\n          for (index2 = 0, len2 = nodesToRemove.length; index2 < len2; index2 += 1) {\n            tempFamily.removeNode(nodesToRemove[index2]);\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  function getLogicalFamily() {\n    return _data.logicalFamily;\n  }\n\n  function getMaximumId() {\n    return _data.maximumId;\n  }\n\n  function getLoops() {\n    return _data.loops;\n  }\n\n  return {\n    process: process,\n    getLogicalFamily: getLogicalFamily,\n    getMaximumId: getMaximumId,\n    getLoops: getLoops\n  };\n};"]},"metadata":{},"sourceType":"module"}