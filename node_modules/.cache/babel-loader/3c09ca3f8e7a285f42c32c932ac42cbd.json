{"ast":null,"code":"import { isObject, cloneObject, isEmptyObject } from '../common';\nimport Graph from './Graph';\nimport LinkedHashItems from './LinkedHashItems';\n/**\n * Creates a family object\n * \n * @class Family\n * \n * @param {Family} [source=undefined] Reference to optional family object to clone properties from\n * \n * @returns {Family} Returns new instance of family structure\n */\n\nexport default function Family(source) {\n  var _roots = {},\n      // children hash of orphant parent id\n  _rootsCount = {},\n      _children = {},\n      // children hash by node id\n  _childrenCount = {},\n      _parents = {},\n      // parents hash by node id\n  _parentsCount = {},\n      _nodes = {},\n      // nodes by node id\n\n  /** @constant\n    @type {number}\n    @default\n  */\n  BREAK = 1,\n\n  /** @constant\n    @type {number}\n    @default\n  */\n  SKIP = 2;\n\n  _init(source);\n\n  function _init(source) {\n    if (isObject(source)) {\n      _roots = cloneObject(source.roots, false);\n      _rootsCount = cloneObject(source.rootsCount, true);\n      _children = cloneObject(source.children, false);\n      _childrenCount = cloneObject(source.childrenCount, true);\n      _parents = cloneObject(source.parents, false);\n      _parentsCount = cloneObject(source.parentsCount, true);\n      _nodes = cloneObject(source.nodes, true);\n    }\n  }\n\n  function _loop(thisArg, collection, itemid, onItem) {\n    var item, items;\n\n    if (onItem != null) {\n      items = collection[itemid];\n\n      if (items != null) {\n        for (item in items) {\n          if (items.hasOwnProperty(item)) {\n            if (onItem.call(thisArg, item, items[item])) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Adds new family member\n   * @param {string[]} parents A collection of parents ids\n   * @param {string} nodeid An id of the new node\n   * @param {object} node A reference to the new node\n   */\n\n\n  function add(parents, nodeid, node) {\n    var index,\n        len,\n        parentid,\n        processed = {};\n\n    if (!parents || parents.length === 0) {\n      parents = [null];\n    }\n\n    if (_nodes[nodeid] == null && node != null) {\n      _nodes[nodeid] = node;\n\n      for (index = 0, len = parents.length; index < len; index += 1) {\n        parentid = parents[index];\n\n        if (processed[parentid] == null && parentid != nodeid) {\n          processed[parentid] = true;\n\n          if (_nodes[parentid] != null) {\n            if (_parents[nodeid] == null) {\n              _parents[nodeid] = {};\n              _parentsCount[nodeid] = 0;\n            }\n\n            if (!_parents[nodeid][parentid]) {\n              _parents[nodeid][parentid] = true;\n              _parentsCount[nodeid] += 1;\n            }\n\n            if (_children[parentid] == null) {\n              _children[parentid] = {};\n              _childrenCount[parentid] = 0;\n            }\n\n            if (!_children[parentid][nodeid]) {\n              _children[parentid][nodeid] = true;\n              _childrenCount[parentid] += 1;\n            }\n          } else {\n            if (_roots[parentid] == null) {\n              _roots[parentid] = {};\n              _rootsCount[parentid] = 0;\n            }\n\n            if (!_roots[parentid][nodeid]) {\n              _roots[parentid][nodeid] = true;\n              _rootsCount[parentid] += 1;\n            }\n          }\n        }\n      }\n\n      if (_roots[nodeid] != null) {\n        _children[nodeid] = _roots[nodeid];\n        _childrenCount[nodeid] = _rootsCount[nodeid];\n        delete _roots[nodeid];\n        delete _rootsCount[nodeid];\n\n        _loop(this, _children, nodeid, function (itemid) {\n          if (_parents[itemid] == null) {\n            _parents[itemid] = {};\n            _parentsCount[itemid] = 0;\n          }\n\n          if (!_parents[itemid][nodeid]) {\n            _parents[itemid][nodeid] = true;\n            _parentsCount[itemid] += 1;\n          }\n        });\n      }\n    }\n  }\n  /**\n   * Returns family node by id\n   * @param {string} nodeid The id of the node\n   * @returns {object|undefined} A reference to the node or undefined if id does not exists\n   */\n\n\n  function node(nodeid) {\n    return _nodes[nodeid];\n  }\n  /**\n   * Makes node to be a child of every parent in the collection of parents\n   * @param {string[]} parents A collection of parents ids\n   * @param {string} nodeid An id of the new node\n   */\n\n\n  function adopt(parents, nodeid) {\n    var index, len, parentid;\n\n    if (_nodes[nodeid] != null) {\n      for (index = 0, len = parents.length; index < len; index += 1) {\n        parentid = parents[index];\n\n        if (_parents[nodeid] == null) {\n          _parents[nodeid] = {};\n          _parentsCount[nodeid] = 0;\n        }\n\n        if (parentid != nodeid && _nodes[parentid] != null) {\n          if (!_parents[nodeid][parentid]) {\n            _parents[nodeid][parentid] = true;\n            _parentsCount[nodeid] += 1;\n          }\n\n          if (_children[parentid] == null) {\n            _children[parentid] = {};\n            _childrenCount[parentid] = 0;\n          }\n\n          if (!_children[parentid][nodeid]) {\n            _children[parentid][nodeid] = true;\n            _childrenCount[parentid] += 1;\n          }\n        } else {\n          throw \"Item cannot be parent of itself and parent should exist in the structure!\";\n        }\n      }\n    } else {\n      throw \"Child should be in hierarchy!\";\n    }\n  }\n  /**\n   * Removes node\n   * @param {string} nodeid The id of the node\n   */\n\n\n  function removeNode(nodeid) {\n    if (_nodes[nodeid] != null) {\n      _loop(this, _children, nodeid, function (itemid) {\n        delete _parents[itemid][nodeid];\n        _parentsCount[itemid] -= 1;\n\n        if (!_parentsCount[itemid]) {\n          delete _parents[itemid];\n          delete _parentsCount[itemid];\n\n          if (_roots[null] == null) {\n            _roots[null] = {};\n            _rootsCount[null] = 0;\n          }\n\n          if (!_roots[null][itemid]) {\n            _roots[null][itemid] = true;\n            _rootsCount[null] += 1;\n          }\n        }\n      });\n\n      _loop(this, _parents, nodeid, function (itemid) {\n        delete _children[itemid][nodeid];\n        _childrenCount[itemid] -= 1;\n\n        if (!_childrenCount[itemid]) {\n          delete _children[itemid];\n          delete _childrenCount[itemid];\n        }\n      });\n\n      if (_roots[null] != null && _roots[null][nodeid] != null) {\n        delete _roots[null][nodeid];\n        _rootsCount[null] -= 1;\n\n        if (!_rootsCount[null]) {\n          delete _roots[null];\n          delete _rootsCount[null];\n        }\n      }\n\n      delete _children[nodeid];\n      delete _childrenCount[nodeid];\n      delete _parents[nodeid];\n      delete _parentsCount[nodeid];\n      delete _nodes[nodeid];\n    }\n  }\n\n  function _removeChildReference(parentid, childid) {\n    var result = false;\n\n    if (_children[parentid] != null && _children[parentid][childid] != null) {\n      delete _children[parentid][childid];\n      _childrenCount[parentid] -= 1;\n      delete _parents[childid][parentid];\n      _parentsCount[childid] -= 1;\n\n      if (!_childrenCount[parentid]) {\n        delete _children[parentid];\n        delete _childrenCount[parentid];\n      }\n\n      if (!_parents[childid]) {\n        delete _parents[childid];\n        delete _parentsCount[childid];\n\n        if (_roots[null] == null) {\n          _roots[null] = {};\n          _rootsCount[null] = 0;\n        }\n\n        _roots[null][childid] = true;\n        _rootsCount[null] += 1;\n      }\n\n      result = true;\n    }\n\n    return result;\n  }\n  /**\n   * Removes first available parent child or child parent relation\n   * \n   * @param {string} fromid From node id\n   * @param {string} toid To node id\n   * @returns {true} If relation was broken\n   */\n\n\n  function removeRelation(fromid, toid) {\n    var result = false;\n\n    if (_nodes[fromid] != null && _nodes[toid] != null) {\n      result = _removeChildReference(fromid, toid) || _removeChildReference(toid, fromid);\n    }\n\n    return result;\n  }\n  /**\n   * Removes child relation\n   * \n   * @param {string} parentid The parent node id\n   * @param {string} childid The child node id\n   * @returns {true} If relation was broken\n   */\n\n\n  function removeChildRelation(parentid, childid) {\n    var result = false;\n\n    if (_nodes[parentid] != null && _nodes[childid] != null) {\n      result = _removeChildReference(parentid, childid);\n    }\n\n    return result;\n  }\n  /**\n   * Returns true if structure has nodes.\n   * \n   * @returns {boolean} Returns true if family structure has nodes\n   */\n\n\n  function hasNodes() {\n    return !isEmptyObject(_nodes);\n  }\n  /**\n   * Callback for iterating family nodes\n   * \n   * @callback onFamilyItemCallback\n   * @param {string} itemid The node id\n   * @param {object} item The node\n   * @returns {boolean} Returns true to break the loop\n   */\n\n  /**\n   * Loops through nodes of family structure\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {onFamilyItemCallback} onItem A callback function to call for every family node \n   */\n\n\n  function loop(thisArg, onItem) {\n    var item;\n\n    if (onItem != null) {\n      for (item in _nodes) {\n        if (_nodes.hasOwnProperty(item)) {\n          if (onItem.call(thisArg, item, _nodes[item])) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  function _loopItems(thisArg, collection, items, onItem) {\n    // onItem(itemid, item, levelIndex)\n    var newItems,\n        itemid,\n        processed = {},\n        levelIndex = 0,\n        hasItems = true;\n\n    while (hasItems) {\n      newItems = {};\n      hasItems = false;\n\n      for (itemid in items) {\n        if (items.hasOwnProperty(itemid)) {\n          if (!processed[itemid]) {\n            processed[itemid] = true;\n\n            switch (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex)) {\n              case 1\n              /*BREAK*/\n              :\n                newItems = {};\n                hasItems = false;\n                break;\n\n              case 2\n              /*SKIP*/\n              :\n                break;\n\n              default:\n                _loop(this, collection, itemid, function (newItemId) {\n                  if (!processed[newItemId]) {\n                    newItems[newItemId] = true;\n                    hasItems = true;\n                  }\n                }); //ignore jslint\n\n\n                break;\n            }\n          }\n        }\n      }\n\n      items = newItems;\n      levelIndex += 1;\n    }\n  }\n  /**\n   * Callback for iterating family nodes level by level\n   * \n   * @callback onFamilyItemWithLevelCallback\n   * @param {string} itemid The node id\n   * @param {object} item The node\n   * @param {number} levelIndex The node level index\n   * @returns {number} Returns BREAK to break the loop and exit. Returns SKIP to skip node's branch traversing.\n   */\n\n  /**\n   * Loops through child nodes of family structure level by level\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {string} nodeid The node id to start children traversing\n   * @param {onFamilyItemWithLevelCallback} onItem A callback function to call for every child node \n   */\n\n\n  function loopChildren(thisArg, nodeid, onItem) {\n    if (onItem != null) {\n      if (nodeid != null && _nodes[nodeid] != null && _children[nodeid] != null) {\n        _loopItems(thisArg, _children, _children[nodeid], onItem);\n      }\n    }\n  }\n  /**\n   * Loops through parent nodes of family structure level by level\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {string} nodeid The node id to start parents traversing\n   * @param {onFamilyItemWithLevelCallback} onItem A callback function to call for every parent node \n   */\n\n\n  function loopParents(thisArg, nodeid, onItem) {\n    if (onItem != null) {\n      if (nodeid != null && _nodes[nodeid] != null && _parents[nodeid] != null) {\n        _loopItems(thisArg, _parents, _parents[nodeid], onItem);\n      }\n    }\n  }\n\n  function _loopTopo(thisArg, backwardCol, backwardCount, forwardCol, forwardCount, onItem) {\n    // onItem(itemid, item, position)\n    var index, len, nodeid, references, queue, newQueue, position;\n\n    if (onItem != null) {\n      /* count parents for every node */\n      queue = [];\n      references = {};\n\n      for (nodeid in _nodes) {\n        if (_nodes.hasOwnProperty(nodeid)) {\n          references[nodeid] = backwardCount[nodeid] || 0;\n\n          if (!references[nodeid]) {\n            queue.push(nodeid);\n          }\n        }\n      }\n      /* iterate queue and reduce reference counts via children */\n\n\n      position = 0;\n\n      while (queue.length > 0) {\n        newQueue = [];\n\n        for (index = 0, len = queue.length; index < len; index += 1) {\n          nodeid = queue[index];\n\n          if (onItem.call(thisArg, nodeid, _nodes[nodeid], position)) {\n            newQueue = [];\n            break;\n          }\n\n          position += 1;\n\n          _loop(this, forwardCol, nodeid, function (itemid) {\n            references[itemid] -= 1;\n\n            if (references[itemid] === 0) {\n              newQueue.push(itemid);\n            }\n          }); //ignore jslint\n\n        }\n\n        queue = newQueue;\n      }\n    }\n  }\n  /**\n   * Callback for iterating family nodes in topological sort order\n   * \n   * @callback onFamilyTopoCallback\n   * @param {string} itemid The node id\n   * @param {object} item The node\n   * @param {number} position The node position in the sequence\n   * @returns {boolean} Returns true to break the loop and exit.\n   */\n\n  /**\n   * Loops through topologically sorted nodes of family structure\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {onFamilyTopoCallback} onItem A callback function to call for every node \n   */\n\n\n  function loopTopo(thisArg, onItem) {\n    _loopTopo(thisArg, _parents, _parentsCount, _children, _childrenCount, onItem);\n  }\n  /**\n   * Loops through reversed order topologically sorted nodes of family structure\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {onFamilyTopoCallback} onItem A callback function to call for every node \n   */\n\n\n  function loopTopoReversed(thisArg, onItem) {\n    _loopTopo(thisArg, _children, _childrenCount, _parents, _parentsCount, onItem);\n  }\n  /**\n   * Loops through nodes of family structure level by level. This function aligns nodes top or bottom.\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {boolean} parentAligned True if nodes should be placed at the next level after their parents level,\n   * otherwise nodes placed at levels close to their children.\n   * @param {onFamilyItemWithLevelCallback} onItem A callback function to call for every node \n   */\n\n\n  function loopLevels(thisArg, parentAligned, onItem) {\n    var topoSorted = [],\n        topoSortedPositions = {},\n        processed = {},\n        margin = [],\n\n    /* result items distribution by levels */\n    levels = {},\n        levelIndex,\n        groups = {},\n        hasGroups,\n        newGroups,\n        groupIndex,\n        group,\n        itemsAtLevel,\n        itemid,\n        minimumLevel = null,\n        loopFunc = parentAligned ? loopTopo : loopTopoReversed,\n        index,\n        len,\n        mIndex,\n        mLen,\n        mItem,\n        mLevel,\n        topoSortedItem,\n        bestPosition,\n        bestItem,\n        bestLevel,\n        bestIsParent,\n        newMargin,\n        hasNeighbours;\n\n    function Group() {\n      this.items = {};\n      this.minimumLevel = null;\n    }\n\n    Group.prototype.addItemToLevel = function (itemid, level) {\n      var items = this.items[level];\n\n      if (!items) {\n        items = [itemid];\n        this.items[level] = items;\n      } else {\n        items.push(itemid);\n      }\n\n      this.minimumLevel = this.minimumLevel == null ? level : Math.min(this.minimumLevel, level);\n    };\n\n    function addItemToLevel(itemid, index, level) {\n      var group = groups[index];\n\n      if (!group) {\n        group = new Group();\n        groups[index] = group;\n      }\n\n      group.addItemToLevel(itemid, level);\n      minimumLevel = minimumLevel == null ? level : Math.min(minimumLevel, level);\n      levels[itemid] = level;\n      processed[itemid] = true;\n    }\n\n    if (onItem != null) {\n      /* sort items topologically */\n      loopFunc(this, function (itemid, item, position) {\n        topoSorted.push(itemid);\n        topoSortedPositions[itemid] = position;\n      });\n      /* search for the first available non processed item in topological order */\n\n      for (index = 0, len = topoSorted.length; index < len; index += 1) {\n        topoSortedItem = topoSorted[index];\n\n        if (processed[topoSortedItem] == null) {\n          margin.push(topoSortedItem);\n          addItemToLevel(topoSortedItem, index, 0);\n          /* use regular graph breadth first search */\n\n          while (margin.length > 0) {\n            bestPosition = null;\n            bestItem = null;\n            bestLevel = null;\n            bestIsParent = !parentAligned;\n            newMargin = [];\n\n            for (mIndex = 0, mLen = margin.length; mIndex < mLen; mIndex += 1) {\n              mItem = margin[mIndex];\n              mLevel = levels[mItem];\n              hasNeighbours = false;\n\n              if (parentAligned) {\n                _loop(this, _parents, mItem, function (parentid) {\n                  var topoSortedPosition;\n\n                  if (!processed[parentid]) {\n                    hasNeighbours = true;\n                    topoSortedPosition = topoSortedPositions[parentid];\n\n                    if (bestPosition == null || !bestIsParent || bestPosition < topoSortedPosition || bestPosition == topoSortedPosition && bestLevel > mLevel - 1) {\n                      bestPosition = topoSortedPosition;\n                      bestItem = parentid;\n                      bestLevel = mLevel - 1;\n                      bestIsParent = true;\n                    }\n                  }\n                }); //ignore jslint\n\n\n                _loop(this, _children, mItem, function (childid) {\n                  var topoSortedPosition;\n\n                  if (!processed[childid]) {\n                    hasNeighbours = true;\n                    topoSortedPosition = topoSortedPositions[childid];\n\n                    if (bestPosition == null || !bestIsParent && (bestPosition > topoSortedPosition || bestPosition == topoSortedPosition && bestLevel < mLevel + 1)) {\n                      bestPosition = topoSortedPosition;\n                      bestItem = childid;\n                      bestLevel = mLevel + 1;\n                      bestIsParent = false;\n                    }\n                  }\n                }); //ignore jslint\n\n              } else {\n                _loop(this, _children, mItem, function (childid) {\n                  var topoSortedPosition;\n\n                  if (!processed[childid]) {\n                    hasNeighbours = true;\n                    topoSortedPosition = topoSortedPositions[childid];\n\n                    if (bestPosition == null || bestIsParent || bestPosition < topoSortedPosition || bestPosition == topoSortedPosition && bestLevel < mLevel + 1) {\n                      bestPosition = topoSortedPosition;\n                      bestItem = childid;\n                      bestLevel = mLevel + 1;\n                      bestIsParent = false;\n                    }\n                  }\n                }); //ignore jslint\n\n\n                _loop(this, _parents, mItem, function (parentid) {\n                  var topoSortedPosition;\n\n                  if (!processed[parentid]) {\n                    hasNeighbours = true;\n                    topoSortedPosition = topoSortedPositions[parentid];\n\n                    if (bestPosition == null || bestIsParent && (bestPosition > topoSortedPosition || bestPosition == topoSortedPosition && bestLevel > mLevel - 1)) {\n                      bestPosition = topoSortedPosition;\n                      bestItem = parentid;\n                      bestLevel = mLevel - 1;\n                      bestIsParent = true;\n                    }\n                  }\n                }); //ignore jslint\n\n              }\n\n              if (hasNeighbours) {\n                newMargin.push(mItem);\n              }\n            }\n\n            if (bestItem != null) {\n              newMargin.push(bestItem);\n              addItemToLevel(bestItem, index, bestLevel);\n            }\n\n            margin = newMargin;\n          }\n        }\n      }\n\n      hasGroups = true;\n      levelIndex = minimumLevel;\n\n      while (hasGroups) {\n        newGroups = {};\n        hasGroups = false;\n\n        for (groupIndex in groups) {\n          if (groups.hasOwnProperty(groupIndex)) {\n            group = groups[groupIndex];\n            itemsAtLevel = group.items[group.minimumLevel - minimumLevel + levelIndex];\n\n            if (itemsAtLevel != null) {\n              newGroups[groupIndex] = group;\n              hasGroups = true;\n\n              for (index = 0, len = itemsAtLevel.length; index < len; index += 1) {\n                itemid = itemsAtLevel[index];\n\n                if (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex - minimumLevel)) {\n                  hasGroups = false;\n                  return true;\n                }\n              }\n            }\n          }\n        }\n\n        groups = newGroups;\n        levelIndex += 1;\n      }\n    }\n  }\n  /**\n   * Loops root nodes of family structure. \n   * @param {Object} thisArg The callback function invocation context\n   * @param {onFamilyItemCallback} onItem A callback function to call for every family root node \n   */\n\n\n  function loopRoots(thisArg, onItem) {\n    var result = null,\n        minimum,\n        counter = 0,\n        famMembers = {},\n        famCount = {},\n        isRoot,\n        roots = {},\n        processed = {},\n        famItemId,\n        member,\n        members,\n        rootid,\n        membersRoots,\n        memberRoots,\n        memberRoot,\n        index,\n        len;\n    loopTopoReversed(this, function (famItemId, famItem, position) {\n      /* every node has at least itself in members */\n      if (!famMembers.hasOwnProperty(famItemId)) {\n        famMembers[famItemId] = {};\n        famCount[famItemId] = 0;\n      }\n\n      famMembers[famItemId][famItemId] = true;\n      famCount[famItemId] += 1;\n      isRoot = true;\n      loopParents(this, famItem.id, function (parentid, parent, levelIndex) {\n        var items, itemid;\n        isRoot = false;\n\n        if (!famMembers.hasOwnProperty(parentid)) {\n          famMembers[parentid] = {};\n          famCount[parentid] = 0;\n        }\n        /* push famItem members to parent members collection */\n\n\n        if (!famCount[parentid] && _parentsCount[famItemId] == 1) {\n          famMembers[parentid] = famMembers[famItemId];\n          famCount[parentid] = famCount[famItemId];\n        } else {\n          items = famMembers[famItemId];\n\n          for (itemid in items) {\n            if (items.hasOwnProperty(itemid)) {\n              if (!famMembers[parentid][itemid]) {\n                famMembers[parentid][itemid] = true;\n                famCount[parentid] += 1;\n              }\n            }\n          }\n        }\n\n        return SKIP;\n      });\n\n      if (isRoot) {\n        roots[famItemId] = true;\n        counter += 1;\n      }\n    });\n    /* create collection of roots per member */\n\n    membersRoots = {};\n\n    for (rootid in roots) {\n      if (roots.hasOwnProperty(rootid)) {\n        members = famMembers[rootid];\n\n        for (member in members) {\n          if (members.hasOwnProperty(member)) {\n            if (!membersRoots[member]) {\n              membersRoots[member] = [];\n            }\n\n            membersRoots[member].push(rootid.toString());\n          }\n        }\n      }\n    }\n    /* loop minimal sub tree roots */\n\n\n    while (counter > 0) {\n      minimum = null;\n\n      for (famItemId in roots) {\n        if (roots.hasOwnProperty(famItemId)) {\n          if (!minimum || famCount[famItemId] < minimum) {\n            minimum = famCount[famItemId];\n            result = famItemId;\n          }\n        }\n      }\n\n      if (result != null) {\n        if (onItem != null) {\n          onItem.call(thisArg, result, _nodes[result]);\n        }\n\n        members = famMembers[result];\n\n        for (member in members) {\n          if (members.hasOwnProperty(member)) {\n            if (!processed[member]) {\n              memberRoots = membersRoots[member];\n\n              for (index = 0, len = memberRoots.length; index < len; index += 1) {\n                memberRoot = memberRoots[index];\n                famCount[memberRoot] -= 1;\n              }\n\n              processed[member] = true;\n            }\n          }\n        }\n\n        delete roots[result];\n        counter -= 1;\n      }\n    }\n  }\n  /**\n   * Finds root node having largest number of nodes in its hierarchy\n   * \n   * @returns {string} Returns largest sub-hierarchy root node id.  \n   */\n\n\n  function findLargestRoot() {\n    var result = null,\n        maximum,\n        famMembers = {},\n        famCount = {},\n        isRoot;\n    maximum = null;\n    loopTopoReversed(this, function (famItemId, famItem, position) {\n      /* every node has at least itself in members */\n      if (!famMembers.hasOwnProperty(famItemId)) {\n        famMembers[famItemId] = {};\n        famCount[famItemId] = 0;\n      }\n\n      famMembers[famItemId][famItemId] = true;\n      famCount[famItemId] += 1;\n      isRoot = true;\n      loopParents(this, famItem.id, function (parentid, parent, levelIndex) {\n        var items, itemid;\n        isRoot = false;\n\n        if (!famMembers.hasOwnProperty(parentid)) {\n          famMembers[parentid] = {};\n          famCount[parentid] = 0;\n        }\n        /* push famItem members to parent members collection */\n\n\n        if (!famCount[parentid] && _parentsCount[famItemId] == 1) {\n          famMembers[parentid] = famMembers[famItemId];\n          famCount[parentid] = famCount[famItemId];\n        } else {\n          items = famMembers[famItemId];\n\n          for (itemid in items) {\n            if (items.hasOwnProperty(itemid)) {\n              famMembers[parentid][itemid] = true;\n              famCount[parentid] += 1;\n            }\n          }\n        }\n\n        return SKIP;\n      });\n\n      if (isRoot && (!maximum || famCount[famItemId] > maximum)) {\n        maximum = famCount[famItemId];\n        result = famItemId;\n      }\n    });\n    return result;\n  }\n  /**\n   * Checks whether parents share a child node. Common child should belong only to the given collection\n   * of parents, if child's parents don't match given collection of parents, \n   * it is not considered as common child. \n   * @param {string[]} parents Collection of parents\n   * @returns {boolean} Returns true if common child exist. \n   */\n\n\n  function hasCommonChild(parents) {\n    var result = false,\n        parentsHash,\n        childrenHash,\n        parentsCount,\n        pIndex,\n        pLen,\n        parent,\n        child;\n    /* convert parents collection to hash, remove duplicates and ignore non-existing items */\n\n    parentsHash = {};\n    parentsCount = 0;\n\n    for (pIndex = 0, pLen = parents.length; pIndex < pLen; pIndex += 1) {\n      parent = parents[pIndex];\n\n      if (_nodes[parent] != null && !parentsHash[parent]) {\n        parentsHash[parent] = true;\n        parentsCount += 1;\n      }\n    }\n    /* collect number of parents referencing each child */\n\n\n    childrenHash = {};\n\n    for (parent in parentsHash) {\n      if (parentsHash.hasOwnProperty(parent)) {\n        _loop(this, _children, parent, function (child) {\n          if (!childrenHash[child]) {\n            childrenHash[child] = 1;\n          } else {\n            childrenHash[child] += 1;\n          }\n        }); //ignore jslint\n\n      }\n    }\n    /* find common child having number of references equal to number of existing parents */\n\n\n    for (child in childrenHash) {\n      if (childrenHash.hasOwnProperty(child)) {\n        if (_parents[child] != null && (_parentsCount[child] || 0) == childrenHash[child] && childrenHash[child] == parentsCount) {\n          result = true;\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function _bundleNodes(fromItem, items, bundleItemId, bundleItem, backwardCol, backwardCount, forwardCol, forwardCount, checkChildren) {\n    var isValid = false,\n        index,\n        len,\n        child;\n\n    if (_nodes[fromItem] != null && forwardCol[fromItem] != null) {\n      /* validate target items */\n      isValid = true;\n\n      if (checkChildren) {\n        /* if we add new bundle all items should present */\n        for (index = 0, len = items.length; index < len; index += 1) {\n          child = items[index];\n\n          if (_nodes[child] == null || forwardCol[fromItem][child] == null) {\n            isValid = false;\n          }\n        }\n      }\n\n      if (isValid) {\n        if (bundleItem != null) {\n          /* add bundle node */\n          _nodes[bundleItemId] = bundleItem;\n        }\n\n        if (_nodes[bundleItemId] != null) {\n          /* update references */\n          if (!backwardCol[bundleItemId]) {\n            backwardCol[bundleItemId] = {};\n            backwardCount[bundleItemId] = 0;\n          }\n\n          if (!forwardCol[bundleItemId]) {\n            forwardCol[bundleItemId] = {};\n            forwardCount[bundleItemId] = 0;\n          }\n\n          if (!backwardCol[bundleItemId][fromItem]) {\n            backwardCol[bundleItemId][fromItem] = true;\n            backwardCount[bundleItemId] += 1;\n          }\n\n          if (!forwardCol[fromItem][bundleItemId]) {\n            forwardCol[fromItem][bundleItemId] = true;\n            forwardCount[fromItem] += 1;\n          }\n\n          for (index = 0, len = items.length; index < len; index += 1) {\n            child = items[index];\n\n            if (bundleItemId != child) {\n              if (forwardCol[fromItem][child] != null) {\n                delete forwardCol[fromItem][child];\n                forwardCount[fromItem] -= 1;\n              }\n\n              if (backwardCol[child][fromItem] != null) {\n                delete backwardCol[child][fromItem];\n                backwardCount[child] -= 1;\n              }\n\n              if (!backwardCol[child][bundleItemId]) {\n                backwardCol[child][bundleItemId] = true;\n                backwardCount[child] += 1;\n              }\n\n              if (!forwardCol[bundleItemId][child]) {\n                forwardCol[bundleItemId][child] = true;\n                forwardCount[bundleItemId] += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return isValid;\n  }\n  /**\n   * Adds extra bundle item in between parent and its children. The parent node becomes parent of the bundle node,\n   * and bundle becomes parent of the children. Existing parent child relations are removed.\n   * @param {string} parent The parent node id\n   * @param {string[]} children The collection of child nodes ids\n   * @param {string} bundleItemId The bundle node id\n   * @param {object} bundleItem The bundle item context object\n   * @returns {boolean} Returns true if nodes bundle is valid\n   */\n\n\n  function bundleChildren(parent, children, bundleItemId, bundleItem) {\n    return _bundleNodes(parent, children, bundleItemId, bundleItem, _parents, _parentsCount, _children, _childrenCount, true);\n  }\n  /**\n   * Adds extra bundle item in between child node and its parents. The child node becomes child of the bundle node,\n   * and bundle becomes child of the parents. Existing parent child relations are removed.\n   * @param {string} child The parent node id\n   * @param {string[]} parents The collection of child nodes ids\n   * @param {string} bundleItemId The bundle node id\n   * @param {object} bundleItem The bundle item context object\n   * @returns {boolean} Returns true if the bundle is valid\n   */\n\n\n  function bundleParents(child, parents, bundleItemId, bundleItem) {\n    return _bundleNodes(child, parents, bundleItemId, bundleItem, _children, _childrenCount, _parents, _parentsCount, true);\n  }\n\n  function ReferenceItem() {\n    this.id = \"\";\n    this.key = \"\";\n    this.children = [];\n    this.childrenHash = {};\n    this.processed = false;\n  }\n\n  function ReferencesEdge(arg0) {\n    this.items = [];\n    this.weight = 0;\n    this.difference = 0;\n\n    if (arguments.length > 0) {\n      this.difference = arg0;\n    }\n  }\n\n  function _getReferencesGraph(currentItems) {\n    var result = Graph(),\n        item,\n        parents,\n        index1,\n        index2,\n        len,\n        from,\n        to,\n        difference,\n        processed = {};\n\n    for (item in currentItems) {\n      if (currentItems.hasOwnProperty(item)) {\n        _loop(this, _children, item, function (child) {\n          if (!processed.hasOwnProperty(child)) {\n            processed[child] = true;\n            /* create array of parents from hash references */\n\n            parents = [];\n\n            _loop(this, _parents, child, function (parent) {\n              parents.push(parent);\n            });\n            /* create all possible combinations between items */\n\n\n            for (index1 = 0, len = parents.length; index1 < len - 1; index1 += 1) {\n              from = parents[index1];\n\n              if (currentItems.hasOwnProperty(from)) {\n                for (index2 = index1 + 1; index2 < len; index2 += 1) {\n                  to = parents[index2];\n\n                  if (currentItems.hasOwnProperty(to)) {\n                    difference = Math.abs(currentItems[from].children.length - currentItems[to].children.length);\n                    var edge = result.edge(from, to);\n\n                    if (edge == null) {\n                      edge = new ReferencesEdge(difference);\n                      result.addEdge(from, to, edge);\n                    }\n\n                    edge.items.push(child);\n                    edge.weight += 1;\n                  }\n                }\n              }\n            }\n          }\n        }); //ignore jslint\n\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Callback function for creation of new family nodes\n   * \n   * @callback onNewFamilyNodeCallback\n   * @returns {object} Returns new family node.\n   */\n\n  /**\n   * Optimizes references between family members.\n   * It creates bundles eliminating excessive intersections between nodes relations.\n   * \n   * @param {onNewFamilyNodeCallback} onNewBundleItem Callback function to create a new family node context object. \n   */\n\n\n  function optimizeReferences(onNewBundleItem) {\n    var sharedItemsByKey = {},\n        sharedItemsById = {},\n        currentItems = {},\n        nodeid,\n        newReferenceItem,\n        nextItems,\n        graph,\n        node,\n        maximumTree,\n        counter = 0,\n        power = 10,\n        processed;\n\n    if (onNewBundleItem != null) {\n      for (nodeid in _nodes) {\n        counter += 1;\n\n        if (_nodes.hasOwnProperty(nodeid)) {\n          newReferenceItem = new ReferenceItem();\n\n          _loop(this, _children, nodeid, function (child) {\n            newReferenceItem.children.push(child);\n            newReferenceItem.childrenHash[child] = true;\n          }); //ignore jslint\n\n\n          newReferenceItem.children.sort();\n          newReferenceItem.id = nodeid;\n          newReferenceItem.key = newReferenceItem.children.join(\",\");\n          currentItems[newReferenceItem.id] = newReferenceItem;\n        }\n      }\n\n      power = Math.pow(10, counter.toString().length);\n\n      while (!isEmptyObject(currentItems)) {\n        nextItems = {};\n        processed = {};\n        graph = _getReferencesGraph(currentItems);\n\n        for (nodeid in currentItems) {\n          if (currentItems.hasOwnProperty(nodeid)) {\n            node = currentItems[nodeid];\n\n            if (!node.processed) {\n              maximumTree = graph.getSpanningTree(nodeid, function (edge) {\n                return edge.weight * power + power - edge.difference;\n              }); //ignore jslint\n\n              maximumTree.loopLevels(this, function (treeKey, treeKeyNode, levelid) {\n                currentItems[treeKey].processed = true;\n                maximumTree.loopChildren(this, treeKey, function (child, childNode) {\n                  var relation = graph.edge(treeKey, child),\n                      nextBundleItem = null,\n                      newItem,\n                      key,\n                      index,\n                      len,\n                      childrenToBind,\n                      isSharedItem,\n                      relationItem;\n                  currentItems[child].processed = true;\n\n                  if (relation.weight > 1) {\n                    key = relation.items.join(',');\n\n                    if (!sharedItemsByKey.hasOwnProperty(key)) {\n                      newItem = onNewBundleItem();\n                      _nodes[newItem.id] = newItem;\n                      /* add new bundle node to the family */\n\n                      nextBundleItem = new ReferenceItem();\n                      nextBundleItem.id = newItem.id;\n                      nextBundleItem.key = key;\n\n                      for (index = 0, len = relation.items.length; index < len; index += 1) {\n                        relationItem = relation.items[index];\n                        nextBundleItem.children.push(relationItem);\n                        nextBundleItem.childrenHash[relationItem] = true;\n                        processed[relationItem] = true;\n                      }\n\n                      nextBundleItem.children.sort();\n                      sharedItemsByKey[nextBundleItem.key] = nextBundleItem;\n                      sharedItemsById[nextBundleItem.id] = nextBundleItem;\n                      nextItems[nextBundleItem.id] = nextBundleItem;\n                      processed[nextBundleItem.id] = nextBundleItem;\n                      childrenToBind = nextBundleItem.children.slice(0);\n                      loopChildren(this, treeKeyNode.replacementItem || treeKey, function (childid, child, level) {\n                        // if child item is bundle and it is not child of new bundle item\n                        if (!nextBundleItem.childrenHash[childid] && sharedItemsById[childid] != null) {\n                          isSharedItem = true; // if all children of that child are in the next bundle item we add it to that new bundle item as well\n\n                          loopChildren(this, childid, function (childid, child, level) {\n                            if (!nextBundleItem.childrenHash[childid]) {\n                              isSharedItem = false;\n                              return 1\n                              /*BREAK*/\n                              ;\n                            }\n\n                            if (!processed.hasOwnProperty(childid)) {\n                              return SKIP;\n                            }\n                          });\n\n                          if (isSharedItem) {\n                            childrenToBind.push(childid);\n                          }\n                        }\n\n                        return 2\n                        /*SKIP*/\n                        ;\n                      });\n\n                      _bundleNodes(treeKeyNode.replacementItem || treeKey, childrenToBind, nextBundleItem.id, newItem, _parents, _parentsCount, _children, _childrenCount, false);\n\n                      if ((_childrenCount[treeKey] || 0) <= 1 && treeKeyNode.replacementItem == null) {\n                        treeKeyNode.replacementItem = nextBundleItem.id;\n                      }\n                    } else {\n                      nextBundleItem = sharedItemsByKey[key];\n                    }\n                    /* don't add shared item to itself on next items loop*/\n\n\n                    if (nextBundleItem.id != child) {\n                      childrenToBind = nextBundleItem.children.slice(0);\n                      loopChildren(this, childNode.replacementItem || child, function (childid, child, level) {\n                        if (sharedItemsById[childid] != null && !nextBundleItem.childrenHash[childid]) {\n                          isSharedItem = true;\n                          loopChildren(this, childid, function (childid, child, level) {\n                            if (!nextBundleItem.childrenHash[childid]) {\n                              isSharedItem = false;\n                              return 1\n                              /*BREAK*/\n                              ;\n                            }\n\n                            if (!processed.hasOwnProperty(childid)) {\n                              return 2\n                              /*SKIP*/\n                              ;\n                            }\n\n                            return SKIP;\n                          });\n\n                          if (isSharedItem) {\n                            childrenToBind.push(childid);\n                          }\n                        }\n\n                        return 2\n                        /*SKIP*/\n                        ;\n                      });\n\n                      _bundleNodes(childNode.replacementItem || child, childrenToBind, nextBundleItem.id, null, _parents, _parentsCount, _children, _childrenCount, false);\n                      /* if all items bundled then use bundle item for following transformations of references instead of original item if references graph*/\n\n\n                      if ((_childrenCount[child] || 0) <= 1 && childNode.replacementItem == null) {\n                        childNode.replacementItem = nextBundleItem.id;\n                      }\n                    }\n                  }\n                });\n              }); //ignore jslint\n            }\n          }\n        }\n\n        currentItems = nextItems;\n      }\n    }\n  }\n  /**\n   * Eliminates many to many relations in family structure\n   * It is needed to simplify layout process of the diagram\n   * \n   * @param {onNewFamilyNodeCallback} onNewBundleItem Callback function for creation of new bundle node  \n   */\n\n\n  function eliminateManyToMany(onNewBundleItem) {\n    var parent, bundleNode;\n\n    for (parent in _children) {\n      if (_children.hasOwnProperty(parent)) {\n        if ((_childrenCount[parent] || 0) > 1) {\n          _loop(this, _children, parent, function (child) {\n            if ((_parentsCount[child] || 0) > 1) {\n              bundleNode = onNewBundleItem();\n              bundleChildren(parent, [child], bundleNode.id, bundleNode);\n            }\n          }); //ignore jslint\n\n        }\n      }\n    }\n  }\n\n  function FamilyEdge(parentid, childid) {\n    this.parentid = parentid;\n    this.childid = childid;\n    this.key = parentid + \",\" + childid;\n  }\n  /**\n   * Eliminates crossing parent child relations between nodes based of nodes order in treeLevels structure.\n   * @param {treeLevels} treeLevels Tree levels structure keeps orders of nodes level by level.\n   * @returns {family} Returns planar family structure. \n   */\n\n\n  function getPlanarFamily(treeLevels) {\n    var result = new Family(),\n        familyEdgeIndex,\n        familyEdgeLen,\n        familyEdgeKey;\n    treeLevels.loopLevels(this, function (levelIndex, treeLevel) {\n      var sequence = new LinkedHashItems(),\n          crossings = {},\n          familyEdges = {},\n          firstBucket = [];\n      treeLevels.loopLevelItems(this, levelIndex, function (parentid, parentItem, position) {\n        loopChildren(this, parentid, function (childid, childItem) {\n          var childPosition = treeLevels.getItemPosition(childid);\n          var familyEdge = new FamilyEdge(parentid, childid);\n          familyEdges[familyEdge.key] = familyEdge;\n          var crossEdges = [];\n\n          if (sequence.isEmpty()) {\n            sequence.add(childPosition, [familyEdge]);\n          } else {\n            sequence.iterateBack(function (sequenceItem, itemPosition) {\n              if (itemPosition < childPosition) {\n                // add new sequence after itemPosition and exit\n                sequence.insertAfter(itemPosition, childPosition, [familyEdge]);\n                return true;\n              } else if (itemPosition == childPosition) {\n                // add new link to existing sequenceItem and exit\n                sequenceItem.push(familyEdge);\n                return true;\n              } else {\n                // merge links into output\n                for (var crossEdgesIndex = 0, crossEdgesLen = sequenceItem.length; crossEdgesIndex < crossEdgesLen; crossEdgesIndex += 1) {\n                  var crossEdge = sequenceItem[crossEdgesIndex];\n\n                  if (crossEdge.parentid != parentid) {\n                    crossEdges.push(crossEdge);\n                  }\n                }\n              }\n            });\n\n            if (sequence.startKey() > childPosition) {\n              sequence.unshift(childPosition, [familyEdge]);\n            }\n          }\n\n          crossings[familyEdge.key] = crossEdges;\n\n          for (var crossEdgesIndex = 0, crossEdgesLen = crossEdges.length; crossEdgesIndex < crossEdgesLen; crossEdgesIndex += 1) {\n            crossings[crossEdges[crossEdgesIndex].key].push(familyEdge);\n          }\n\n          return SKIP;\n        });\n\n        if (countChildren(parentid) == 1) {\n          var childid = firstChild(parentid);\n\n          if (countParents(childid) == 1) {\n            var familyEdge = new FamilyEdge(parentid, childid);\n            firstBucket.push(familyEdge.key);\n          }\n        }\n      }); // distribute edges by number of crossings into buckets\n\n      var buckets = [],\n          crossEdges;\n\n      for (var familyEdgeKey in crossings) {\n        crossEdges = crossings[familyEdgeKey];\n        var len = crossEdges.length;\n\n        if (buckets[len] != null) {\n          buckets[len].push(familyEdgeKey);\n        } else {\n          buckets[len] = [familyEdgeKey];\n        }\n      }\n\n      var processed = {}; // leave single parent child relations\n\n      buckets.unshift(firstBucket); // break relations having \n\n      for (var bucketIndex = 0, bucketsLen = buckets.length; bucketIndex < bucketsLen; bucketIndex += 1) {\n        var bucket = buckets[bucketIndex];\n\n        if (bucket != null) {\n          for (familyEdgeIndex = 0, familyEdgeLen = bucket.length; familyEdgeIndex < familyEdgeLen; familyEdgeIndex += 1) {\n            familyEdgeKey = bucket[familyEdgeIndex];\n\n            if (!processed.hasOwnProperty(familyEdgeKey)) {\n              processed[familyEdgeKey] = true;\n              var familyEdge = familyEdges[familyEdgeKey];\n\n              if (result.node(familyEdge.parentid) == null) {\n                result.add(null, familyEdge.parentid, {});\n              }\n\n              if (result.node(familyEdge.childid) == null) {\n                result.add([familyEdge.parentid], familyEdge.childid, {});\n              } else {\n                result.adopt([familyEdge.parentid], familyEdge.childid);\n              }\n\n              crossEdges = crossings[familyEdgeKey];\n\n              for (var crossEdgesIndex = 0, crossEdgesLen = crossEdges.length; crossEdgesIndex < crossEdgesLen; crossEdgesIndex += 1) {\n                processed[crossEdges[crossEdgesIndex].key] = true;\n              }\n            }\n          }\n        }\n      }\n    });\n    return result;\n  }\n\n  function Link(from, to, distance) {\n    this.from = from;\n    this.to = to;\n    this.distance = 0;\n  }\n  /**\n   * Eliminates direct relations between grand parent nodes.\n   * \n   * @returns {family} Returns family structure without direct grand parent relations. \n   */\n\n\n  function getFamilyWithoutGrandParentsRelations() {\n    var result = new Family();\n    var hash = {};\n    var links = [];\n    var level = 0;\n\n    for (var from in _parents) {\n      if (_parents.hasOwnProperty(from)) {\n        _loop(this, _parents, from, function (to) {\n          var fromHash = hash[from];\n\n          if (fromHash == null) {\n            fromHash = {};\n            hash[from] = fromHash;\n          }\n\n          if (!fromHash.hasOwnProperty(to)) {\n            var link = new Link(from, to, level);\n            links.push(link);\n            hash[from][to] = link;\n          }\n        }); //ignore jslint\n\n      }\n    }\n\n    while (links.length > 0) {\n      var newLinks = [];\n      level += 1;\n\n      for (var index = 0, len = links.length; index < len; index += 1) {\n        var link = links[index];\n        from = link.to;\n\n        if (_parents.hasOwnProperty(from)) {\n          _loop(this, _parents, from, function (to) {\n            var fromHash = hash[link.from];\n\n            if (fromHash == null) {\n              fromHash = {};\n              hash[link.from] = fromHash;\n            }\n\n            if (fromHash.hasOwnProperty(to)) {\n              fromHash[to].distance = level;\n            } else {\n              var newLink = new Link(from, to, level);\n              newLinks.push(newLink);\n              fromHash[to] = newLink;\n            }\n          });\n        }\n      }\n\n      links = newLinks;\n    } // return only references to immidiate parents\n\n\n    loop(this, function (nodeid, node) {\n      var parents = [];\n\n      _loop(this, _parents, nodeid, function (to) {\n        if (hash[nodeid][to].distance === 0) {\n          parents.push(to);\n        }\n      });\n\n      result.add(parents, nodeid, node);\n    });\n    return result;\n  }\n  /**\n   * Returns number of children\n   * @param {string} parent The parent node id\n   * @returns {number} Number of children\n   */\n\n\n  function countChildren(parent) {\n    return _childrenCount[parent] || 0;\n  }\n  /**\n   * Returns number of parents\n   * @param {string} child The child node id\n   * @returns {number} Number of parents\n   */\n\n\n  function countParents(child) {\n    return _parentsCount[child] || 0;\n  }\n  /**\n   * First available child\n   * @param {string} parent The parent node id\n   * @returns {string} Returns first available child id or null.\n   */\n\n\n  function firstChild(parent) {\n    var result = null,\n        children = _children[parent] || {};\n\n    for (result in children) {\n      if (children.hasOwnProperty(result)) {\n        return result; //ignore jslint\n      }\n    }\n\n    return null;\n  }\n  /**\n   * First available parent\n   * @param {string} child The child node id\n   * @returns {string} Returns first available parent id or null.\n   */\n\n\n  function firstParent(child) {\n    var result = null,\n        parents = _parents[child] || {};\n\n    for (result in parents) {\n      if (parents.hasOwnProperty(result)) {\n        return result; //ignore jslint\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Callback for iterating family node neighbours level by level\n   * \n   * @callback onFamilyItemNeighbourCallback\n   * @param {string} itemid The node id\n   * @param {object} item The node\n   * @param {number} levelIndex The neigbour node distance from the start node\n   * @returns {number} Returns true to skip further neighbous traversing.\n   */\n\n  /**\n   * Loops through the node neighbours of the family structure level by level\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {string} itemid The node id to start traversing neighbour nodes\n   * @param {onFamilyItemNeighbourCallback} onItem A callback function to call for every neighbour node \n   */\n\n\n  function loopNeighbours(thisArg, itemid, onItem) {\n    var processed = {};\n\n    if (onItem != null) {\n      loopChildren(this, itemid, function (childid, child, childLevel) {\n        if (!processed.hasOwnProperty(childid)) {\n          processed[childid] = null;\n\n          if (onItem.call(thisArg, childid, child, 1)) {\n            processed[childid] = SKIP;\n          }\n\n          loopParents(this, childid, function (parentid, parent, parentLevel) {\n            if (!processed.hasOwnProperty(parentid)) {\n              processed[parentid] = null;\n\n              if (onItem.call(thisArg, parentid, parent, 2)) {\n                processed[parentid] = SKIP;\n              }\n            }\n\n            return processed[parentid];\n          });\n        }\n\n        return processed[childid];\n      });\n      loopParents(this, itemid, function (parentid, parent, parentLevel) {\n        if (!processed.hasOwnProperty(parentid)) {\n          processed[parentid] = null;\n\n          if (onItem.call(thisArg, parentid, parent, 1)) {\n            processed[parentid] = SKIP;\n          }\n\n          loopChildren(this, parentid, function (childid, child, childLevel) {\n            if (!processed.hasOwnProperty(childid)) {\n              processed[childid] = true;\n\n              if (onItem.call(thisArg, childid, child, 2)) {\n                processed[childid] = SKIP;\n              }\n            }\n\n            return processed[childid];\n          });\n        }\n\n        return processed[parentid];\n      });\n    }\n  }\n  /**\n   * Callback for getting default edge value\n   * \n   * @callback onFamilyEdgeCallback\n   * @param {string} from From node id\n   * @param {string} to The node\n   * @returns {object} Returns new edge object.\n   */\n\n  /**\n   * Creates graph structure out of the family structure.\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {onFamilyEdgeCallback} onEdge A callback function to call for every new edge added to the final graph\n   * @returns {graph} Returns graph structure of the family.\n   */\n\n\n  function getGraph(thisArg, onEdge) {\n    var result = Graph(),\n        from,\n        to;\n\n    for (from in _children) {\n      if (_children.hasOwnProperty(from)) {\n        _loop(this, _children, from, function (to) {\n          var edge = result.edge(from, to);\n\n          if (edge == null) {\n            if (onEdge == null) {\n              edge = new ReferencesEdge({});\n            } else {\n              edge = onEdge.call(thisArg, from, to);\n            }\n\n            result.addEdge(from, to, edge);\n          }\n        }); //ignore jslint\n\n      }\n    }\n\n    return result;\n  }\n\n  function GroupBy(parentid, childid) {\n    this.parentid = parentid;\n    this.childid = childid;\n    this.ids = [];\n    this.nodes = [];\n  }\n\n  function groupBy(thisArg, size, onGroup) {\n    //function onGroup(parent, child, nodes)\n    if (onGroup != null) {\n      var groups = {};\n\n      for (var nodeid in _nodes) {\n        var parentsCount = _parentsCount[nodeid] || 0;\n        var childrenCount = _childrenCount[nodeid] || 0;\n\n        if (parentsCount <= 1 && childrenCount <= 1) {\n          var parentid = firstParent(nodeid);\n          var childid = firstChild(nodeid);\n          var key = parentid + \" * \" + childid;\n\n          if (!groups.hasOwnProperty(key)) {\n            groups[key] = new GroupBy(parentid, childid);\n          }\n\n          groups[key].ids.push(nodeid);\n          groups[key].nodes.push(_nodes[nodeid]);\n        }\n      }\n\n      for (key in groups) {\n        if (groups.hasOwnProperty(key)) {\n          var group = groups[key];\n\n          if (group.ids.length >= size) {\n            if (onGroup.call(thisArg, group.parentid, group.childid, group.ids, group.nodes)) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Validates internal data structure consistency of the family.\n   * @param {object} info Optional validation object. \n   */\n\n\n  function validate(info) {\n    var parent, child;\n\n    function _count(items) {\n      var result = 0,\n          key;\n\n      if (items != null) {\n        for (key in items) {\n          if (items.hasOwnProperty(key)) {\n            result += 1;\n          }\n        }\n      }\n\n      return result;\n    }\n\n    loop(this, function (nodeId, node) {\n      _loop(this, _children, nodeId, function (child) {\n        if (!_parents.hasOwnProperty(child) || !_parents[child].hasOwnProperty(nodeId)) {\n          if (info != null) {\n            info.message = \"Child #\" + child + \" does not reference parent #\" + nodeId;\n          }\n\n          return false;\n        }\n      });\n\n      _loop(this, _parents, nodeId, function (parent) {\n        if (!_children.hasOwnProperty(parent) || !_children[parent].hasOwnProperty(nodeId)) {\n          if (info != null) {\n            info.message = \"Parent #\" + parent + \" does not reference child #\" + nodeId;\n          }\n\n          return false;\n        }\n      });\n    });\n\n    for (parent in _parents) {\n      if (_parents.hasOwnProperty(parent)) {\n        if ((_parentsCount[parent] || 0) != _count(_parents[parent])) {\n          if (info != null) {\n            info.message = \"Parents count for item #\" + parent + \" missmatch.\";\n          }\n\n          return false;\n        }\n\n        if (_parents.hasOwnProperty(parent) && !_nodes.hasOwnProperty(parent)) {\n          if (info != null) {\n            info.message = \"Orphant parents for item #\" + parent;\n          }\n\n          return false;\n        }\n      }\n    }\n\n    for (child in _children) {\n      if (_children.hasOwnProperty(child)) {\n        if ((_childrenCount[child] || 0) != _count(_children[child])) {\n          if (info != null) {\n            info.message = \"Children count for item \" + child + \" missmatch.\";\n          }\n\n          return false;\n        }\n\n        if (_children.hasOwnProperty(child) && !_nodes.hasOwnProperty(child)) {\n          if (info != null) {\n            info.message = \"Orphant children of item \" + child;\n          }\n\n          return false;\n        }\n      }\n    }\n\n    for (child in _roots) {\n      if (_roots.hasOwnProperty(child)) {\n        if ((_rootsCount[child] || 0) != _count(_roots[child])) {\n          if (info != null) {\n            info.message = \"Root children count for item @\" + child + \" missmatch.\";\n          }\n\n          return false;\n        }\n\n        _loop(this, _roots, child, function (nodeid) {\n          if (!_nodes.hasOwnProperty(nodeid)) {\n            if (info != null) {\n              info.message = \"Child #\" + nodeid + \"of root #\" + child + \" does not exists.\";\n            }\n\n            return false;\n          }\n        }); //ignore jslint\n\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Checks if family structure has loops in references. \n   * @returns {boolean} Returns true if family structure contains loops in references.\n   */\n\n\n  function hasLoops() {\n    var tempFamily = clone();\n    loopTopo(this, function (itemid, item, levelIndex) {\n      tempFamily.removeNode(itemid);\n    });\n    return tempFamily.hasNodes();\n  }\n  /**\n   * Clones family structure.\n   * \n   * @returns {family} Returns copy of the family structure.\n   */\n\n\n  function clone() {\n    return Family({\n      roots: _roots,\n      rootsCount: _rootsCount,\n      children: _children,\n      childrenCount: _childrenCount,\n      parents: _parents,\n      parentsCount: _parentsCount,\n      nodes: _nodes\n    });\n  }\n\n  return {\n    /* family structure modification */\n    add: add,\n    adopt: adopt,\n    bundleChildren: bundleChildren,\n    bundleParents: bundleParents,\n    optimizeReferences: optimizeReferences,\n    eliminateManyToMany: eliminateManyToMany,\n    groupBy: groupBy,\n    getPlanarFamily: getPlanarFamily,\n    getFamilyWithoutGrandParentsRelations: getFamilyWithoutGrandParentsRelations,\n    getGraph: getGraph,\n    removeNode: removeNode,\n    removeRelation: removeRelation,\n    removeChildRelation: removeChildRelation,\n\n    /* referencing and looping */\n    node: node,\n    loop: loop,\n    loopLevels: loopLevels,\n    loopTopo: loopTopo,\n    loopTopoReversed: loopTopoReversed,\n    loopChildren: loopChildren,\n    loopParents: loopParents,\n    findLargestRoot: findLargestRoot,\n    loopRoots: loopRoots,\n    hasNodes: hasNodes,\n    hasCommonChild: hasCommonChild,\n    loopNeighbours: loopNeighbours,\n    countChildren: countChildren,\n    countParents: countParents,\n    firstParent: firstParent,\n    firstChild: firstChild,\n\n    /* force validation */\n    validate: validate,\n    hasLoops: hasLoops,\n    clone: clone,\n    // callback return codes\n    BREAK: BREAK,\n    // break loop immidiatly\n    SKIP: SKIP // skip loop of current node children \n\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/Family.js"],"names":["isObject","cloneObject","isEmptyObject","Graph","LinkedHashItems","Family","source","_roots","_rootsCount","_children","_childrenCount","_parents","_parentsCount","_nodes","BREAK","SKIP","_init","roots","rootsCount","children","childrenCount","parents","parentsCount","nodes","_loop","thisArg","collection","itemid","onItem","item","items","hasOwnProperty","call","add","nodeid","node","index","len","parentid","processed","length","adopt","removeNode","_removeChildReference","childid","result","removeRelation","fromid","toid","removeChildRelation","hasNodes","loop","_loopItems","newItems","levelIndex","hasItems","newItemId","loopChildren","loopParents","_loopTopo","backwardCol","backwardCount","forwardCol","forwardCount","references","queue","newQueue","position","push","loopTopo","loopTopoReversed","loopLevels","parentAligned","topoSorted","topoSortedPositions","margin","levels","groups","hasGroups","newGroups","groupIndex","group","itemsAtLevel","minimumLevel","loopFunc","mIndex","mLen","mItem","mLevel","topoSortedItem","bestPosition","bestItem","bestLevel","bestIsParent","newMargin","hasNeighbours","Group","prototype","addItemToLevel","level","Math","min","topoSortedPosition","loopRoots","minimum","counter","famMembers","famCount","isRoot","famItemId","member","members","rootid","membersRoots","memberRoots","memberRoot","famItem","id","parent","toString","findLargestRoot","maximum","hasCommonChild","parentsHash","childrenHash","pIndex","pLen","child","_bundleNodes","fromItem","bundleItemId","bundleItem","checkChildren","isValid","bundleChildren","bundleParents","ReferenceItem","key","ReferencesEdge","arg0","weight","difference","arguments","_getReferencesGraph","currentItems","index1","index2","from","to","abs","edge","addEdge","optimizeReferences","onNewBundleItem","sharedItemsByKey","sharedItemsById","newReferenceItem","nextItems","graph","maximumTree","power","sort","join","pow","getSpanningTree","treeKey","treeKeyNode","levelid","childNode","relation","nextBundleItem","newItem","childrenToBind","isSharedItem","relationItem","slice","replacementItem","eliminateManyToMany","bundleNode","FamilyEdge","getPlanarFamily","treeLevels","familyEdgeIndex","familyEdgeLen","familyEdgeKey","treeLevel","sequence","crossings","familyEdges","firstBucket","loopLevelItems","parentItem","childItem","childPosition","getItemPosition","familyEdge","crossEdges","isEmpty","iterateBack","sequenceItem","itemPosition","insertAfter","crossEdgesIndex","crossEdgesLen","crossEdge","startKey","unshift","countChildren","firstChild","countParents","buckets","bucketIndex","bucketsLen","bucket","Link","distance","getFamilyWithoutGrandParentsRelations","hash","links","fromHash","link","newLinks","newLink","firstParent","loopNeighbours","childLevel","parentLevel","getGraph","onEdge","GroupBy","ids","groupBy","size","onGroup","validate","info","_count","nodeId","message","hasLoops","tempFamily","clone"],"mappings":"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","sourcesContent":["import { isObject, cloneObject, isEmptyObject } from '../common';\nimport Graph from './Graph';\nimport LinkedHashItems from './LinkedHashItems';\n/**\n * Creates a family object\n * \n * @class Family\n * \n * @param {Family} [source=undefined] Reference to optional family object to clone properties from\n * \n * @returns {Family} Returns new instance of family structure\n */\nexport default function Family(source) {\n  var _roots = {},     // children hash of orphant parent id\n    _rootsCount = {},\n    _children = {},  // children hash by node id\n    _childrenCount = {},\n    _parents = {},   // parents hash by node id\n    _parentsCount = {},\n    _nodes = {},     // nodes by node id\n    /** @constant\n      @type {number}\n      @default\n    */\n    BREAK = 1,\n    /** @constant\n      @type {number}\n      @default\n    */\n    SKIP = 2;\n\n  _init(source);\n\n  function _init(source) {\n    if (isObject(source)) {\n      _roots = cloneObject(source.roots, false);\n      _rootsCount = cloneObject(source.rootsCount, true);\n      _children = cloneObject(source.children, false);\n      _childrenCount = cloneObject(source.childrenCount, true);\n      _parents = cloneObject(source.parents, false);\n      _parentsCount = cloneObject(source.parentsCount, true);\n      _nodes = cloneObject(source.nodes, true);\n    }\n  }\n\n  function _loop(thisArg, collection, itemid, onItem) {\n    var item, items;\n    if (onItem != null) {\n      items = collection[itemid];\n      if (items != null) {\n        for (item in items) {\n          if (items.hasOwnProperty(item)) {\n            if (onItem.call(thisArg, item, items[item])) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Adds new family member\n   * @param {string[]} parents A collection of parents ids\n   * @param {string} nodeid An id of the new node\n   * @param {object} node A reference to the new node\n   */\n  function add(parents, nodeid, node) {\n    var index, len,\n      parentid,\n      processed = {};\n\n    if (!parents || parents.length === 0) {\n      parents = [null];\n    }\n\n    if (_nodes[nodeid] == null && node != null) {\n      _nodes[nodeid] = node;\n      for (index = 0, len = parents.length; index < len; index += 1) {\n        parentid = parents[index];\n\n\n        if (processed[parentid] == null && parentid != nodeid) {\n          processed[parentid] = true;\n          if (_nodes[parentid] != null) {\n            if (_parents[nodeid] == null) {\n              _parents[nodeid] = {};\n              _parentsCount[nodeid] = 0;\n            }\n            if (!_parents[nodeid][parentid]) {\n              _parents[nodeid][parentid] = true;\n              _parentsCount[nodeid] += 1;\n            }\n\n            if (_children[parentid] == null) {\n              _children[parentid] = {};\n              _childrenCount[parentid] = 0;\n            }\n            if (!_children[parentid][nodeid]) {\n              _children[parentid][nodeid] = true;\n              _childrenCount[parentid] += 1;\n            }\n          } else {\n            if (_roots[parentid] == null) {\n              _roots[parentid] = {};\n              _rootsCount[parentid] = 0;\n            }\n            if (!_roots[parentid][nodeid]) {\n              _roots[parentid][nodeid] = true;\n              _rootsCount[parentid] += 1;\n            }\n          }\n        }\n      }\n      if (_roots[nodeid] != null) {\n        _children[nodeid] = _roots[nodeid];\n        _childrenCount[nodeid] = _rootsCount[nodeid];\n        delete _roots[nodeid];\n        delete _rootsCount[nodeid];\n        _loop(this, _children, nodeid, function (itemid) {\n          if (_parents[itemid] == null) {\n            _parents[itemid] = {};\n            _parentsCount[itemid] = 0;\n          }\n          if (!_parents[itemid][nodeid]) {\n            _parents[itemid][nodeid] = true;\n            _parentsCount[itemid] += 1;\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Returns family node by id\n   * @param {string} nodeid The id of the node\n   * @returns {object|undefined} A reference to the node or undefined if id does not exists\n   */\n  function node(nodeid) {\n    return _nodes[nodeid];\n  }\n\n  /**\n   * Makes node to be a child of every parent in the collection of parents\n   * @param {string[]} parents A collection of parents ids\n   * @param {string} nodeid An id of the new node\n   */\n  function adopt(parents, nodeid) {\n    var index, len,\n      parentid;\n    if (_nodes[nodeid] != null) {\n      for (index = 0, len = parents.length; index < len; index += 1) {\n        parentid = parents[index];\n\n        if (_parents[nodeid] == null) {\n          _parents[nodeid] = {};\n          _parentsCount[nodeid] = 0;\n        }\n\n        if (parentid != nodeid && _nodes[parentid] != null) {\n          if (!_parents[nodeid][parentid]) {\n            _parents[nodeid][parentid] = true;\n            _parentsCount[nodeid] += 1;\n          }\n\n          if (_children[parentid] == null) {\n            _children[parentid] = {};\n            _childrenCount[parentid] = 0;\n          }\n          if (!_children[parentid][nodeid]) {\n            _children[parentid][nodeid] = true;\n            _childrenCount[parentid] += 1;\n          }\n        } else {\n          throw \"Item cannot be parent of itself and parent should exist in the structure!\";\n        }\n      }\n    } else {\n      throw \"Child should be in hierarchy!\";\n    }\n  }\n\n  /**\n   * Removes node\n   * @param {string} nodeid The id of the node\n   */\n  function removeNode(nodeid) {\n    if (_nodes[nodeid] != null) {\n      _loop(this, _children, nodeid, function (itemid) {\n        delete _parents[itemid][nodeid];\n        _parentsCount[itemid] -= 1;\n\n        if (!_parentsCount[itemid]) {\n          delete _parents[itemid];\n          delete _parentsCount[itemid];\n\n          if (_roots[null] == null) {\n            _roots[null] = {};\n            _rootsCount[null] = 0;\n          }\n          if (!_roots[null][itemid]) {\n            _roots[null][itemid] = true;\n            _rootsCount[null] += 1;\n          }\n        }\n      });\n      _loop(this, _parents, nodeid, function (itemid) {\n        delete _children[itemid][nodeid];\n        _childrenCount[itemid] -= 1;\n        if (!_childrenCount[itemid]) {\n          delete _children[itemid];\n          delete _childrenCount[itemid];\n        }\n      });\n      if (_roots[null] != null && _roots[null][nodeid] != null) {\n        delete _roots[null][nodeid];\n        _rootsCount[null] -= 1;\n\n        if (!_rootsCount[null]) {\n          delete _roots[null];\n          delete _rootsCount[null];\n        }\n      }\n      delete _children[nodeid];\n      delete _childrenCount[nodeid];\n      delete _parents[nodeid];\n      delete _parentsCount[nodeid];\n      delete _nodes[nodeid];\n    }\n  }\n\n  function _removeChildReference(parentid, childid) {\n    var result = false;\n    if (_children[parentid] != null && _children[parentid][childid] != null) {\n      delete _children[parentid][childid];\n      _childrenCount[parentid] -= 1;\n\n      delete _parents[childid][parentid];\n      _parentsCount[childid] -= 1;\n\n      if (!_childrenCount[parentid]) {\n        delete _children[parentid];\n        delete _childrenCount[parentid];\n      }\n\n      if (!_parents[childid]) {\n        delete _parents[childid];\n        delete _parentsCount[childid];\n\n        if (_roots[null] == null) {\n          _roots[null] = {};\n          _rootsCount[null] = 0;\n        }\n        _roots[null][childid] = true;\n        _rootsCount[null] += 1;\n      }\n      result = true;\n    }\n    return result;\n  }\n\n  /**\n   * Removes first available parent child or child parent relation\n   * \n   * @param {string} fromid From node id\n   * @param {string} toid To node id\n   * @returns {true} If relation was broken\n   */\n  function removeRelation(fromid, toid) {\n    var result = false;\n    if (_nodes[fromid] != null && _nodes[toid] != null) {\n      result = _removeChildReference(fromid, toid) || _removeChildReference(toid, fromid);\n    }\n    return result;\n  }\n\n  /**\n   * Removes child relation\n   * \n   * @param {string} parentid The parent node id\n   * @param {string} childid The child node id\n   * @returns {true} If relation was broken\n   */\n  function removeChildRelation(parentid, childid) {\n    var result = false;\n    if (_nodes[parentid] != null && _nodes[childid] != null) {\n      result = _removeChildReference(parentid, childid);\n    }\n    return result;\n  }\n\n\n  /**\n   * Returns true if structure has nodes.\n   * \n   * @returns {boolean} Returns true if family structure has nodes\n   */\n  function hasNodes() {\n    return !isEmptyObject(_nodes);\n  }\n\n  /**\n   * Callback for iterating family nodes\n   * \n   * @callback onFamilyItemCallback\n   * @param {string} itemid The node id\n   * @param {object} item The node\n   * @returns {boolean} Returns true to break the loop\n   */\n\n  /**\n   * Loops through nodes of family structure\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {onFamilyItemCallback} onItem A callback function to call for every family node \n   */\n  function loop(thisArg, onItem) {\n    var item;\n    if (onItem != null) {\n      for (item in _nodes) {\n        if (_nodes.hasOwnProperty(item)) {\n          if (onItem.call(thisArg, item, _nodes[item])) {\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  function _loopItems(thisArg, collection, items, onItem) { // onItem(itemid, item, levelIndex)\n    var newItems, itemid,\n      processed = {},\n      levelIndex = 0,\n      hasItems = true;\n\n\n    while (hasItems) {\n      newItems = {};\n      hasItems = false;\n\n      for (itemid in items) {\n        if (items.hasOwnProperty(itemid)) {\n          if (!processed[itemid]) {\n            processed[itemid] = true;\n\n            switch (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex)) {\n              case 1/*BREAK*/:\n                newItems = {};\n                hasItems = false;\n                break;\n              case 2/*SKIP*/:\n                break;\n              default:\n                _loop(this, collection, itemid, function (newItemId) {\n                  if (!processed[newItemId]) {\n                    newItems[newItemId] = true;\n                    hasItems = true;\n                  }\n                }); //ignore jslint\n                break;\n            }\n          }\n        }\n      }\n      items = newItems;\n      levelIndex += 1;\n    }\n  }\n\n  /**\n   * Callback for iterating family nodes level by level\n   * \n   * @callback onFamilyItemWithLevelCallback\n   * @param {string} itemid The node id\n   * @param {object} item The node\n   * @param {number} levelIndex The node level index\n   * @returns {number} Returns BREAK to break the loop and exit. Returns SKIP to skip node's branch traversing.\n   */\n\n  /**\n   * Loops through child nodes of family structure level by level\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {string} nodeid The node id to start children traversing\n   * @param {onFamilyItemWithLevelCallback} onItem A callback function to call for every child node \n   */\n  function loopChildren(thisArg, nodeid, onItem) {\n    if (onItem != null) {\n      if (nodeid != null && _nodes[nodeid] != null && _children[nodeid] != null) {\n        _loopItems(thisArg, _children, _children[nodeid], onItem);\n      }\n    }\n  }\n\n  /**\n   * Loops through parent nodes of family structure level by level\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {string} nodeid The node id to start parents traversing\n   * @param {onFamilyItemWithLevelCallback} onItem A callback function to call for every parent node \n   */\n  function loopParents(thisArg, nodeid, onItem) {\n    if (onItem != null) {\n      if (nodeid != null && _nodes[nodeid] != null && _parents[nodeid] != null) {\n        _loopItems(thisArg, _parents, _parents[nodeid], onItem);\n      }\n    }\n  }\n\n  function _loopTopo(thisArg, backwardCol, backwardCount, forwardCol, forwardCount, onItem) { // onItem(itemid, item, position)\n    var index, len, nodeid, references,\n      queue, newQueue, position;\n\n    if (onItem != null) {\n      /* count parents for every node */\n      queue = [];\n      references = {};\n      for (nodeid in _nodes) {\n        if (_nodes.hasOwnProperty(nodeid)) {\n          references[nodeid] = (backwardCount[nodeid] || 0);\n\n          if (!references[nodeid]) {\n            queue.push(nodeid);\n          }\n        }\n      }\n\n      /* iterate queue and reduce reference counts via children */\n      position = 0;\n      while (queue.length > 0) {\n        newQueue = [];\n\n        for (index = 0, len = queue.length; index < len; index += 1) {\n          nodeid = queue[index];\n\n          if (onItem.call(thisArg, nodeid, _nodes[nodeid], position)) {\n            newQueue = [];\n            break;\n          }\n\n          position += 1;\n\n          _loop(this, forwardCol, nodeid, function (itemid) {\n            references[itemid] -= 1;\n            if (references[itemid] === 0) {\n              newQueue.push(itemid);\n            }\n          }); //ignore jslint\n        }\n        queue = newQueue;\n      }\n    }\n  }\n\n  /**\n   * Callback for iterating family nodes in topological sort order\n   * \n   * @callback onFamilyTopoCallback\n   * @param {string} itemid The node id\n   * @param {object} item The node\n   * @param {number} position The node position in the sequence\n   * @returns {boolean} Returns true to break the loop and exit.\n   */\n\n  /**\n   * Loops through topologically sorted nodes of family structure\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {onFamilyTopoCallback} onItem A callback function to call for every node \n   */\n  function loopTopo(thisArg, onItem) {\n    _loopTopo(thisArg, _parents, _parentsCount, _children, _childrenCount, onItem);\n  }\n\n  /**\n   * Loops through reversed order topologically sorted nodes of family structure\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {onFamilyTopoCallback} onItem A callback function to call for every node \n   */\n  function loopTopoReversed(thisArg, onItem) {\n    _loopTopo(thisArg, _children, _childrenCount, _parents, _parentsCount, onItem);\n  }\n\n\n  /**\n   * Loops through nodes of family structure level by level. This function aligns nodes top or bottom.\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {boolean} parentAligned True if nodes should be placed at the next level after their parents level,\n   * otherwise nodes placed at levels close to their children.\n   * @param {onFamilyItemWithLevelCallback} onItem A callback function to call for every node \n   */\n  function loopLevels(thisArg, parentAligned, onItem) {\n    var topoSorted = [],\n      topoSortedPositions = {},\n      processed = {},\n      margin = [],\n      /* result items distribution by levels */\n      levels = {}, levelIndex,\n      groups = {}, hasGroups, newGroups, groupIndex, group,\n      itemsAtLevel, itemid,\n      minimumLevel = null,\n      loopFunc = parentAligned ? loopTopo : loopTopoReversed,\n      index, len,\n      mIndex, mLen, mItem, mLevel,\n      topoSortedItem,\n      bestPosition, bestItem, bestLevel, bestIsParent,\n      newMargin, hasNeighbours;\n\n    function Group() {\n      this.items = {};\n      this.minimumLevel = null;\n    }\n\n    Group.prototype.addItemToLevel = function (itemid, level) {\n      var items = this.items[level];\n      if (!items) {\n        items = [itemid];\n        this.items[level] = items;\n      } else {\n        items.push(itemid);\n      }\n      this.minimumLevel = this.minimumLevel == null ? level : Math.min(this.minimumLevel, level);\n    };\n\n    function addItemToLevel(itemid, index, level) {\n      var group = groups[index];\n      if (!group) {\n        group = new Group();\n        groups[index] = group;\n      }\n\n      group.addItemToLevel(itemid, level);\n\n      minimumLevel = minimumLevel == null ? level : Math.min(minimumLevel, level);\n\n      levels[itemid] = level;\n      processed[itemid] = true;\n    }\n\n\n    if (onItem != null) {\n      /* sort items topologically */\n      loopFunc(this, function (itemid, item, position) {\n        topoSorted.push(itemid);\n        topoSortedPositions[itemid] = position;\n      });\n\n      /* search for the first available non processed item in topological order */\n      for (index = 0, len = topoSorted.length; index < len; index += 1) {\n        topoSortedItem = topoSorted[index];\n        if (processed[topoSortedItem] == null) {\n          margin.push(topoSortedItem);\n\n          addItemToLevel(topoSortedItem, index, 0);\n\n          /* use regular graph breadth first search */\n          while (margin.length > 0) {\n            bestPosition = null;\n            bestItem = null;\n            bestLevel = null;\n            bestIsParent = !parentAligned;\n            newMargin = [];\n            for (mIndex = 0, mLen = margin.length; mIndex < mLen; mIndex += 1) {\n              mItem = margin[mIndex];\n              mLevel = levels[mItem];\n              hasNeighbours = false;\n\n              if (parentAligned) {\n                _loop(this, _parents, mItem, function (parentid) {\n                  var topoSortedPosition;\n                  if (!processed[parentid]) {\n                    hasNeighbours = true;\n                    topoSortedPosition = topoSortedPositions[parentid];\n                    if (bestPosition == null || !bestIsParent || bestPosition < topoSortedPosition || (bestPosition == topoSortedPosition && bestLevel > mLevel - 1)) {\n                      bestPosition = topoSortedPosition;\n                      bestItem = parentid;\n                      bestLevel = mLevel - 1;\n                      bestIsParent = true;\n                    }\n                  }\n                }); //ignore jslint\n                _loop(this, _children, mItem, function (childid) {\n                  var topoSortedPosition;\n                  if (!processed[childid]) {\n                    hasNeighbours = true;\n                    topoSortedPosition = topoSortedPositions[childid];\n                    if (bestPosition == null || (!bestIsParent && (bestPosition > topoSortedPosition || (bestPosition == topoSortedPosition && bestLevel < mLevel + 1)))) {\n                      bestPosition = topoSortedPosition;\n                      bestItem = childid;\n                      bestLevel = mLevel + 1;\n                      bestIsParent = false;\n                    }\n                  }\n                }); //ignore jslint\n              } else {\n                _loop(this, _children, mItem, function (childid) {\n                  var topoSortedPosition;\n                  if (!processed[childid]) {\n                    hasNeighbours = true;\n                    topoSortedPosition = topoSortedPositions[childid];\n                    if (bestPosition == null || bestIsParent || bestPosition < topoSortedPosition || (bestPosition == topoSortedPosition && bestLevel < mLevel + 1)) {\n                      bestPosition = topoSortedPosition;\n                      bestItem = childid;\n                      bestLevel = mLevel + 1;\n                      bestIsParent = false;\n                    }\n                  }\n                }); //ignore jslint\n                _loop(this, _parents, mItem, function (parentid) {\n                  var topoSortedPosition;\n                  if (!processed[parentid]) {\n                    hasNeighbours = true;\n                    topoSortedPosition = topoSortedPositions[parentid];\n                    if (bestPosition == null || (bestIsParent && (bestPosition > topoSortedPosition || (bestPosition == topoSortedPosition && bestLevel > mLevel - 1)))) {\n                      bestPosition = topoSortedPosition;\n                      bestItem = parentid;\n                      bestLevel = mLevel - 1;\n                      bestIsParent = true;\n                    }\n                  }\n                }); //ignore jslint\n              }\n              if (hasNeighbours) {\n                newMargin.push(mItem);\n              }\n            }\n            if (bestItem != null) {\n              newMargin.push(bestItem);\n\n              addItemToLevel(bestItem, index, bestLevel);\n            }\n            margin = newMargin;\n          }\n        }\n      }\n\n      hasGroups = true;\n      levelIndex = minimumLevel;\n      while (hasGroups) {\n        newGroups = {};\n        hasGroups = false;\n        for (groupIndex in groups) {\n          if (groups.hasOwnProperty(groupIndex)) {\n            group = groups[groupIndex];\n            itemsAtLevel = group.items[(group.minimumLevel - minimumLevel) + levelIndex];\n            if (itemsAtLevel != null) {\n              newGroups[groupIndex] = group;\n              hasGroups = true;\n\n              for (index = 0, len = itemsAtLevel.length; index < len; index += 1) {\n                itemid = itemsAtLevel[index];\n                if (onItem.call(thisArg, itemid, _nodes[itemid], levelIndex - minimumLevel)) {\n                  hasGroups = false;\n                  return true;\n                }\n              }\n            }\n          }\n        }\n        groups = newGroups;\n        levelIndex += 1;\n      }\n    }\n  }\n\n  /**\n   * Loops root nodes of family structure. \n   * @param {Object} thisArg The callback function invocation context\n   * @param {onFamilyItemCallback} onItem A callback function to call for every family root node \n   */\n  function loopRoots(thisArg, onItem) {\n    var result = null,\n      minimum, counter = 0,\n      famMembers = {},\n      famCount = {},\n      isRoot,\n      roots = {},\n      processed = {},\n      famItemId, member, members, rootid,\n      membersRoots, memberRoots, memberRoot,\n      index, len;\n\n    loopTopoReversed(this, function (famItemId, famItem, position) {\n      /* every node has at least itself in members */\n      if (!famMembers.hasOwnProperty(famItemId)) {\n        famMembers[famItemId] = {};\n        famCount[famItemId] = 0;\n      }\n      famMembers[famItemId][famItemId] = true;\n      famCount[famItemId] += 1;\n\n      isRoot = true;\n      loopParents(this, famItem.id, function (parentid, parent, levelIndex) {\n        var items, itemid;\n        isRoot = false;\n        if (!famMembers.hasOwnProperty(parentid)) {\n          famMembers[parentid] = {};\n          famCount[parentid] = 0;\n        }\n        /* push famItem members to parent members collection */\n        if (!famCount[parentid] && _parentsCount[famItemId] == 1) {\n          famMembers[parentid] = famMembers[famItemId];\n          famCount[parentid] = famCount[famItemId];\n        } else {\n          items = famMembers[famItemId];\n          for (itemid in items) {\n            if (items.hasOwnProperty(itemid)) {\n              if (!famMembers[parentid][itemid]) {\n                famMembers[parentid][itemid] = true;\n                famCount[parentid] += 1;\n              }\n            }\n          }\n        }\n        return SKIP;\n      });\n      if (isRoot) {\n        roots[famItemId] = true;\n        counter += 1;\n\n\n      }\n    });\n\n    /* create collection of roots per member */\n    membersRoots = {};\n    for (rootid in roots) {\n      if (roots.hasOwnProperty(rootid)) {\n        members = famMembers[rootid];\n\n        for (member in members) {\n          if (members.hasOwnProperty(member)) {\n\n            if (!membersRoots[member]) {\n              membersRoots[member] = [];\n            }\n            membersRoots[member].push(rootid.toString());\n          }\n        }\n      }\n    }\n\n    /* loop minimal sub tree roots */\n    while (counter > 0) {\n      minimum = null;\n      for (famItemId in roots) {\n        if (roots.hasOwnProperty(famItemId)) {\n          if (!minimum || famCount[famItemId] < minimum) {\n            minimum = famCount[famItemId];\n            result = famItemId;\n          }\n        }\n      }\n      if (result != null) {\n        if (onItem != null) {\n          onItem.call(thisArg, result, _nodes[result]);\n        }\n        members = famMembers[result];\n\n        for (member in members) {\n          if (members.hasOwnProperty(member)) {\n            if (!processed[member]) {\n              memberRoots = membersRoots[member];\n              for (index = 0, len = memberRoots.length; index < len; index += 1) {\n                memberRoot = memberRoots[index];\n                famCount[memberRoot] -= 1;\n              }\n              processed[member] = true;\n            }\n          }\n        }\n\n        delete roots[result];\n        counter -= 1;\n      }\n    }\n  }\n\n  /**\n   * Finds root node having largest number of nodes in its hierarchy\n   * \n   * @returns {string} Returns largest sub-hierarchy root node id.  \n   */\n  function findLargestRoot() {\n    var result = null,\n      maximum,\n      famMembers = {},\n      famCount = {},\n      isRoot;\n\n    maximum = null;\n\n    loopTopoReversed(this, function (famItemId, famItem, position) {\n      /* every node has at least itself in members */\n      if (!famMembers.hasOwnProperty(famItemId)) {\n        famMembers[famItemId] = {};\n        famCount[famItemId] = 0;\n      }\n      famMembers[famItemId][famItemId] = true;\n      famCount[famItemId] += 1;\n\n      isRoot = true;\n      loopParents(this, famItem.id, function (parentid, parent, levelIndex) {\n        var items, itemid;\n        isRoot = false;\n        if (!famMembers.hasOwnProperty(parentid)) {\n          famMembers[parentid] = {};\n          famCount[parentid] = 0;\n        }\n        /* push famItem members to parent members collection */\n        if (!famCount[parentid] && _parentsCount[famItemId] == 1) {\n          famMembers[parentid] = famMembers[famItemId];\n          famCount[parentid] = famCount[famItemId];\n        } else {\n          items = famMembers[famItemId];\n          for (itemid in items) {\n            if (items.hasOwnProperty(itemid)) {\n              famMembers[parentid][itemid] = true;\n              famCount[parentid] += 1;\n            }\n          }\n        }\n        return SKIP;\n      });\n      if (isRoot && (!maximum || famCount[famItemId] > maximum)) {\n        maximum = famCount[famItemId];\n        result = famItemId;\n      }\n\n    });\n\n    return result;\n  }\n\n  /**\n   * Checks whether parents share a child node. Common child should belong only to the given collection\n   * of parents, if child's parents don't match given collection of parents, \n   * it is not considered as common child. \n   * @param {string[]} parents Collection of parents\n   * @returns {boolean} Returns true if common child exist. \n   */\n  function hasCommonChild(parents) {\n    var result = false,\n      parentsHash, childrenHash,\n      parentsCount,\n      pIndex, pLen,\n      parent, child;\n\n    /* convert parents collection to hash, remove duplicates and ignore non-existing items */\n    parentsHash = {};\n    parentsCount = 0;\n    for (pIndex = 0, pLen = parents.length; pIndex < pLen; pIndex += 1) {\n      parent = parents[pIndex];\n      if (_nodes[parent] != null && !parentsHash[parent]) {\n        parentsHash[parent] = true;\n        parentsCount += 1;\n      }\n    }\n\n    /* collect number of parents referencing each child */\n    childrenHash = {};\n    for (parent in parentsHash) {\n      if (parentsHash.hasOwnProperty(parent)) {\n        _loop(this, _children, parent, function (child) {\n          if (!childrenHash[child]) {\n            childrenHash[child] = 1;\n          } else {\n            childrenHash[child] += 1;\n          }\n        }); //ignore jslint\n      }\n    }\n\n    /* find common child having number of references equal to number of existing parents */\n    for (child in childrenHash) {\n      if (childrenHash.hasOwnProperty(child)) {\n        if (_parents[child] != null && (_parentsCount[child] || 0) == childrenHash[child] && childrenHash[child] == parentsCount) {\n          result = true;\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function _bundleNodes(fromItem, items, bundleItemId, bundleItem, backwardCol, backwardCount, forwardCol, forwardCount, checkChildren) {\n    var isValid = false,\n      index, len,\n      child;\n\n    if (_nodes[fromItem] != null && forwardCol[fromItem] != null) {\n      /* validate target items */\n      isValid = true;\n      if (checkChildren) {\n        /* if we add new bundle all items should present */\n        for (index = 0, len = items.length; index < len; index += 1) {\n          child = items[index];\n          if (_nodes[child] == null || forwardCol[fromItem][child] == null) {\n            isValid = false;\n          }\n        }\n      }\n      if (isValid) {\n        if (bundleItem != null) {\n          /* add bundle node */\n          _nodes[bundleItemId] = bundleItem;\n        }\n\n        if (_nodes[bundleItemId] != null) {\n          /* update references */\n          if (!backwardCol[bundleItemId]) {\n            backwardCol[bundleItemId] = {};\n            backwardCount[bundleItemId] = 0;\n          }\n          if (!forwardCol[bundleItemId]) {\n            forwardCol[bundleItemId] = {};\n            forwardCount[bundleItemId] = 0;\n          }\n\n          if (!backwardCol[bundleItemId][fromItem]) {\n            backwardCol[bundleItemId][fromItem] = true;\n            backwardCount[bundleItemId] += 1;\n          }\n\n          if (!forwardCol[fromItem][bundleItemId]) {\n            forwardCol[fromItem][bundleItemId] = true;\n            forwardCount[fromItem] += 1;\n          }\n\n          for (index = 0, len = items.length; index < len; index += 1) {\n            child = items[index];\n\n            if (bundleItemId != child) {\n              if (forwardCol[fromItem][child] != null) {\n                delete forwardCol[fromItem][child];\n                forwardCount[fromItem] -= 1;\n              }\n\n              if (backwardCol[child][fromItem] != null) {\n                delete backwardCol[child][fromItem];\n                backwardCount[child] -= 1;\n              }\n\n              if (!backwardCol[child][bundleItemId]) {\n                backwardCol[child][bundleItemId] = true;\n                backwardCount[child] += 1;\n              }\n\n              if (!forwardCol[bundleItemId][child]) {\n                forwardCol[bundleItemId][child] = true;\n                forwardCount[bundleItemId] += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    return isValid;\n  }\n\n  /**\n   * Adds extra bundle item in between parent and its children. The parent node becomes parent of the bundle node,\n   * and bundle becomes parent of the children. Existing parent child relations are removed.\n   * @param {string} parent The parent node id\n   * @param {string[]} children The collection of child nodes ids\n   * @param {string} bundleItemId The bundle node id\n   * @param {object} bundleItem The bundle item context object\n   * @returns {boolean} Returns true if nodes bundle is valid\n   */\n  function bundleChildren(parent, children, bundleItemId, bundleItem) {\n    return _bundleNodes(parent, children, bundleItemId, bundleItem, _parents, _parentsCount, _children, _childrenCount, true);\n  }\n\n  /**\n   * Adds extra bundle item in between child node and its parents. The child node becomes child of the bundle node,\n   * and bundle becomes child of the parents. Existing parent child relations are removed.\n   * @param {string} child The parent node id\n   * @param {string[]} parents The collection of child nodes ids\n   * @param {string} bundleItemId The bundle node id\n   * @param {object} bundleItem The bundle item context object\n   * @returns {boolean} Returns true if the bundle is valid\n   */\n  function bundleParents(child, parents, bundleItemId, bundleItem) {\n    return _bundleNodes(child, parents, bundleItemId, bundleItem, _children, _childrenCount, _parents, _parentsCount, true);\n  }\n\n  function ReferenceItem() {\n    this.id = \"\";\n    this.key = \"\";\n    this.children = [];\n    this.childrenHash = {};\n    this.processed = false;\n  }\n\n  function ReferencesEdge(arg0) {\n    this.items = [];\n    this.weight = 0;\n    this.difference = 0;\n\n    if (arguments.length > 0) {\n      this.difference = arg0;\n    }\n  }\n\n  function _getReferencesGraph(currentItems) {\n    var result = Graph(),\n      item, parents,\n      index1, index2, len,\n      from, to, difference,\n      processed = {};\n\n    for (item in currentItems) {\n      if (currentItems.hasOwnProperty(item)) {\n\n        _loop(this, _children, item, function (child) {\n          if (!processed.hasOwnProperty(child)) {\n            processed[child] = true;\n            /* create array of parents from hash references */\n            parents = [];\n            _loop(this, _parents, child, function (parent) {\n              parents.push(parent);\n            });\n\n            /* create all possible combinations between items */\n            for (index1 = 0, len = parents.length; index1 < len - 1; index1 += 1) {\n              from = parents[index1];\n              if (currentItems.hasOwnProperty(from)) {\n\n                for (index2 = index1 + 1; index2 < len; index2 += 1) {\n                  to = parents[index2];\n                  if (currentItems.hasOwnProperty(to)) {\n                    difference = Math.abs(currentItems[from].children.length - currentItems[to].children.length);\n\n                    var edge = result.edge(from, to);\n                    if (edge == null) {\n                      edge = new ReferencesEdge(difference);\n                      result.addEdge(from, to, edge);\n                    }\n                    edge.items.push(child);\n                    edge.weight += 1;\n                  }\n                }\n              }\n            }\n          }\n        }); //ignore jslint\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Callback function for creation of new family nodes\n   * \n   * @callback onNewFamilyNodeCallback\n   * @returns {object} Returns new family node.\n   */\n\n  /**\n   * Optimizes references between family members.\n   * It creates bundles eliminating excessive intersections between nodes relations.\n   * \n   * @param {onNewFamilyNodeCallback} onNewBundleItem Callback function to create a new family node context object. \n   */\n  function optimizeReferences(onNewBundleItem) {\n    var sharedItemsByKey = {},\n      sharedItemsById = {},\n      currentItems = {},\n      nodeid, newReferenceItem,\n      nextItems, graph, node,\n      maximumTree,\n      counter = 0,\n      power = 10,\n      processed;\n\n    if (onNewBundleItem != null) {\n      for (nodeid in _nodes) {\n        counter += 1;\n        if (_nodes.hasOwnProperty(nodeid)) {\n          newReferenceItem = new ReferenceItem();\n\n          _loop(this, _children, nodeid, function (child) {\n            newReferenceItem.children.push(child);\n            newReferenceItem.childrenHash[child] = true;\n          }); //ignore jslint\n\n          newReferenceItem.children.sort();\n          newReferenceItem.id = nodeid;\n          newReferenceItem.key = newReferenceItem.children.join(\",\");\n\n          currentItems[newReferenceItem.id] = newReferenceItem;\n        }\n      }\n\n      power = Math.pow(10, (counter).toString().length);\n\n      while (!isEmptyObject(currentItems)) {\n        nextItems = {};\n        processed = {};\n\n        graph = _getReferencesGraph(currentItems);\n\n        for (nodeid in currentItems) {\n          if (currentItems.hasOwnProperty(nodeid)) {\n            node = currentItems[nodeid];\n\n            if (!node.processed) {\n\n              maximumTree = graph.getSpanningTree(nodeid, function (edge) {\n                return edge.weight * power + power - edge.difference;\n              }); //ignore jslint\n\n              maximumTree.loopLevels(this, function (treeKey, treeKeyNode, levelid) {\n                currentItems[treeKey].processed = true;\n\n                maximumTree.loopChildren(this, treeKey, function (child, childNode) {\n                  var relation = graph.edge(treeKey, child),\n                    nextBundleItem = null, newItem,\n                    key, index, len,\n                    childrenToBind, isSharedItem,\n                    relationItem;\n\n                  currentItems[child].processed = true;\n\n                  if (relation.weight > 1) {\n                    key = relation.items.join(',');\n\n                    if (!sharedItemsByKey.hasOwnProperty(key)) {\n                      newItem = onNewBundleItem();\n                      _nodes[newItem.id] = newItem; /* add new bundle node to the family */\n\n                      nextBundleItem = new ReferenceItem();\n                      nextBundleItem.id = newItem.id;\n                      nextBundleItem.key = key;\n                      for (index = 0, len = relation.items.length; index < len; index += 1) {\n                        relationItem = relation.items[index];\n                        nextBundleItem.children.push(relationItem);\n                        nextBundleItem.childrenHash[relationItem] = true;\n                        processed[relationItem] = true;\n                      }\n                      nextBundleItem.children.sort();\n\n                      sharedItemsByKey[nextBundleItem.key] = nextBundleItem;\n                      sharedItemsById[nextBundleItem.id] = nextBundleItem;\n                      nextItems[nextBundleItem.id] = nextBundleItem;\n                      processed[nextBundleItem.id] = nextBundleItem;\n\n                      childrenToBind = nextBundleItem.children.slice(0);\n                      loopChildren(this, treeKeyNode.replacementItem || treeKey, function (childid, child, level) {\n                        // if child item is bundle and it is not child of new bundle item\n                        if (!nextBundleItem.childrenHash[childid] && sharedItemsById[childid] != null) {\n                          isSharedItem = true;\n                          // if all children of that child are in the next bundle item we add it to that new bundle item as well\n                          loopChildren(this, childid, function (childid, child, level) {\n                            if (!nextBundleItem.childrenHash[childid]) {\n                              isSharedItem = false;\n                              return 1/*BREAK*/;\n                            }\n                            if (!processed.hasOwnProperty(childid)) {\n                              return SKIP;\n                            }\n                          });\n                          if (isSharedItem) {\n                            childrenToBind.push(childid);\n                          }\n                        }\n                        return 2/*SKIP*/;\n                      });\n\n                      _bundleNodes(treeKeyNode.replacementItem || treeKey, childrenToBind, nextBundleItem.id, newItem, _parents, _parentsCount, _children, _childrenCount, false);\n\n                      if ((_childrenCount[treeKey] || 0) <= 1 && treeKeyNode.replacementItem == null) {\n                        treeKeyNode.replacementItem = nextBundleItem.id;\n                      }\n                    } else {\n                      nextBundleItem = sharedItemsByKey[key];\n                    }\n\n                    /* don't add shared item to itself on next items loop*/\n                    if (nextBundleItem.id != child) {\n\n                      childrenToBind = nextBundleItem.children.slice(0);\n                      loopChildren(this, childNode.replacementItem || child, function (childid, child, level) {\n                        if (sharedItemsById[childid] != null && !nextBundleItem.childrenHash[childid]) {\n\n                          isSharedItem = true;\n                          loopChildren(this, childid, function (childid, child, level) {\n                            if (!nextBundleItem.childrenHash[childid]) {\n                              isSharedItem = false;\n                              return 1/*BREAK*/;\n                            }\n                            if (!processed.hasOwnProperty(childid)) {\n                              return 2/*SKIP*/;\n                            }\n                            return SKIP;\n                          });\n                          if (isSharedItem) {\n                            childrenToBind.push(childid);\n                          }\n                        }\n                        return 2/*SKIP*/;\n                      });\n\n\n                      _bundleNodes(childNode.replacementItem || child, childrenToBind, nextBundleItem.id, null, _parents, _parentsCount, _children, _childrenCount, false);\n\n                      /* if all items bundled then use bundle item for following transformations of references instead of original item if references graph*/\n                      if ((_childrenCount[child] || 0) <= 1 && childNode.replacementItem == null) {\n                        childNode.replacementItem = nextBundleItem.id;\n                      }\n                    }\n                  }\n                });\n              }); //ignore jslint\n            }\n          }\n        }\n        currentItems = nextItems;\n      }\n    }\n  }\n\n  /**\n   * Eliminates many to many relations in family structure\n   * It is needed to simplify layout process of the diagram\n   * \n   * @param {onNewFamilyNodeCallback} onNewBundleItem Callback function for creation of new bundle node  \n   */\n  function eliminateManyToMany(onNewBundleItem) {\n    var parent, bundleNode;\n\n    for (parent in _children) {\n      if (_children.hasOwnProperty(parent)) {\n\n        if ((_childrenCount[parent] || 0) > 1) {\n          _loop(this, _children, parent, function (child) {\n            if ((_parentsCount[child] || 0) > 1) {\n              bundleNode = onNewBundleItem();\n              bundleChildren(parent, [child], bundleNode.id, bundleNode);\n            }\n          }); //ignore jslint\n        }\n      }\n    }\n  }\n\n  function FamilyEdge(parentid, childid) {\n    this.parentid = parentid;\n    this.childid = childid;\n    this.key = parentid + \",\" + childid;\n  }\n\n  /**\n   * Eliminates crossing parent child relations between nodes based of nodes order in treeLevels structure.\n   * @param {treeLevels} treeLevels Tree levels structure keeps orders of nodes level by level.\n   * @returns {family} Returns planar family structure. \n   */\n  function getPlanarFamily(treeLevels) {\n    var result = new Family(),\n      familyEdgeIndex, familyEdgeLen,\n      familyEdgeKey;\n\n    treeLevels.loopLevels(this, function (levelIndex, treeLevel) {\n      var sequence = new LinkedHashItems(),\n        crossings = {},\n        familyEdges = {},\n        firstBucket = [];\n\n      treeLevels.loopLevelItems(this, levelIndex, function (parentid, parentItem, position) {\n        loopChildren(this, parentid, function (childid, childItem) {\n          var childPosition = treeLevels.getItemPosition(childid);\n          var familyEdge = new FamilyEdge(parentid, childid);\n\n          familyEdges[familyEdge.key] = familyEdge;\n\n          var crossEdges = [];\n          if (sequence.isEmpty()) {\n            sequence.add(childPosition, [familyEdge]);\n          } else {\n            sequence.iterateBack(function (sequenceItem, itemPosition) {\n              if (itemPosition < childPosition) {\n                // add new sequence after itemPosition and exit\n                sequence.insertAfter(itemPosition, childPosition, [familyEdge]);\n                return true;\n              } else if (itemPosition == childPosition) {\n                // add new link to existing sequenceItem and exit\n                sequenceItem.push(familyEdge);\n                return true;\n              } else {\n                // merge links into output\n                for (var crossEdgesIndex = 0, crossEdgesLen = sequenceItem.length; crossEdgesIndex < crossEdgesLen; crossEdgesIndex += 1) {\n                  var crossEdge = sequenceItem[crossEdgesIndex];\n                  if (crossEdge.parentid != parentid) {\n                    crossEdges.push(crossEdge);\n                  }\n                }\n              }\n            });\n            if (sequence.startKey() > childPosition) {\n              sequence.unshift(childPosition, [familyEdge]);\n            }\n          }\n\n          crossings[familyEdge.key] = crossEdges;\n          for (var crossEdgesIndex = 0, crossEdgesLen = crossEdges.length; crossEdgesIndex < crossEdgesLen; crossEdgesIndex += 1) {\n            crossings[crossEdges[crossEdgesIndex].key].push(familyEdge);\n          }\n\n          return SKIP;\n        });\n\n        if (countChildren(parentid) == 1) {\n          var childid = firstChild(parentid);\n          if (countParents(childid) == 1) {\n            var familyEdge = new FamilyEdge(parentid, childid);\n            firstBucket.push(familyEdge.key);\n          }\n        }\n      });\n\n      // distribute edges by number of crossings into buckets\n      var buckets = [],\n        crossEdges;\n      for (var familyEdgeKey in crossings) {\n        crossEdges = crossings[familyEdgeKey];\n        var len = crossEdges.length;\n        if (buckets[len] != null) {\n          buckets[len].push(familyEdgeKey);\n        } else {\n          buckets[len] = [familyEdgeKey];\n        }\n      }\n\n      var processed = {};\n\n      // leave single parent child relations\n      buckets.unshift(firstBucket);\n\n      // break relations having \n      for (var bucketIndex = 0, bucketsLen = buckets.length; bucketIndex < bucketsLen; bucketIndex += 1) {\n        var bucket = buckets[bucketIndex];\n        if (bucket != null) {\n          for (familyEdgeIndex = 0, familyEdgeLen = bucket.length; familyEdgeIndex < familyEdgeLen; familyEdgeIndex += 1) {\n            familyEdgeKey = bucket[familyEdgeIndex];\n            if (!processed.hasOwnProperty(familyEdgeKey)) {\n              processed[familyEdgeKey] = true;\n\n              var familyEdge = familyEdges[familyEdgeKey];\n\n              if (result.node(familyEdge.parentid) == null) {\n                result.add(null, familyEdge.parentid, {});\n              }\n              if (result.node(familyEdge.childid) == null) {\n                result.add([familyEdge.parentid], familyEdge.childid, {});\n              } else {\n                result.adopt([familyEdge.parentid], familyEdge.childid);\n              }\n\n              crossEdges = crossings[familyEdgeKey];\n              for (var crossEdgesIndex = 0, crossEdgesLen = crossEdges.length; crossEdgesIndex < crossEdgesLen; crossEdgesIndex += 1) {\n                processed[crossEdges[crossEdgesIndex].key] = true;\n              }\n            }\n          }\n        }\n      }\n    });\n\n    return result;\n  }\n\n  function Link(from, to, distance) {\n    this.from = from;\n    this.to = to;\n    this.distance = 0;\n  }\n\n  /**\n   * Eliminates direct relations between grand parent nodes.\n   * \n   * @returns {family} Returns family structure without direct grand parent relations. \n   */\n  function getFamilyWithoutGrandParentsRelations() {\n    var result = new Family();\n\n    var hash = {};\n    var links = [];\n    var level = 0;\n    for (var from in _parents) {\n      if (_parents.hasOwnProperty(from)) {\n        _loop(this, _parents, from, function (to) {\n          var fromHash = hash[from];\n          if (fromHash == null) {\n            fromHash = {};\n            hash[from] = fromHash;\n          }\n          if (!fromHash.hasOwnProperty(to)) {\n            var link = new Link(from, to, level);\n            links.push(link);\n            hash[from][to] = link;\n          }\n        }); //ignore jslint\n      }\n    }\n\n    while (links.length > 0) {\n      var newLinks = [];\n      level += 1;\n      for (var index = 0, len = links.length; index < len; index += 1) {\n        var link = links[index];\n        from = link.to;\n        if (_parents.hasOwnProperty(from)) {\n          _loop(this, _parents, from, function (to) {\n            var fromHash = hash[link.from];\n            if (fromHash == null) {\n              fromHash = {};\n              hash[link.from] = fromHash;\n            }\n            if (fromHash.hasOwnProperty(to)) {\n              fromHash[to].distance = level;\n            } else {\n              var newLink = new Link(from, to, level);\n              newLinks.push(newLink);\n              fromHash[to] = newLink;\n            }\n          });\n        }\n      }\n      links = newLinks;\n    }\n\n    // return only references to immidiate parents\n    loop(this, function (nodeid, node) {\n      var parents = [];\n      _loop(this, _parents, nodeid, function (to) {\n        if (hash[nodeid][to].distance === 0) {\n          parents.push(to);\n        }\n      });\n      result.add(parents, nodeid, node);\n    });\n\n    return result;\n  }\n\n  /**\n   * Returns number of children\n   * @param {string} parent The parent node id\n   * @returns {number} Number of children\n   */\n  function countChildren(parent) {\n    return _childrenCount[parent] || 0;\n  }\n\n  /**\n   * Returns number of parents\n   * @param {string} child The child node id\n   * @returns {number} Number of parents\n   */\n  function countParents(child) {\n    return _parentsCount[child] || 0;\n  }\n\n  /**\n   * First available child\n   * @param {string} parent The parent node id\n   * @returns {string} Returns first available child id or null.\n   */\n  function firstChild(parent) {\n    var result = null,\n      children = _children[parent] || {};\n    for (result in children) {\n      if (children.hasOwnProperty(result)) {\n        return result; //ignore jslint\n      }\n    }\n    return null;\n  }\n\n  /**\n   * First available parent\n   * @param {string} child The child node id\n   * @returns {string} Returns first available parent id or null.\n   */\n  function firstParent(child) {\n    var result = null,\n      parents = _parents[child] || {};\n    for (result in parents) {\n      if (parents.hasOwnProperty(result)) {\n        return result; //ignore jslint\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Callback for iterating family node neighbours level by level\n   * \n   * @callback onFamilyItemNeighbourCallback\n   * @param {string} itemid The node id\n   * @param {object} item The node\n   * @param {number} levelIndex The neigbour node distance from the start node\n   * @returns {number} Returns true to skip further neighbous traversing.\n   */\n\n  /**\n   * Loops through the node neighbours of the family structure level by level\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {string} itemid The node id to start traversing neighbour nodes\n   * @param {onFamilyItemNeighbourCallback} onItem A callback function to call for every neighbour node \n   */\n  function loopNeighbours(thisArg, itemid, onItem) {\n    var processed = {};\n\n    if (onItem != null) {\n      loopChildren(this, itemid, function (childid, child, childLevel) {\n        if (!processed.hasOwnProperty(childid)) {\n          processed[childid] = null;\n\n          if (onItem.call(thisArg, childid, child, 1)) {\n            processed[childid] = SKIP;\n          }\n\n          loopParents(this, childid, function (parentid, parent, parentLevel) {\n            if (!processed.hasOwnProperty(parentid)) {\n              processed[parentid] = null;\n\n              if (onItem.call(thisArg, parentid, parent, 2)) {\n                processed[parentid] = SKIP;\n              }\n            }\n            return processed[parentid];\n          });\n        }\n        return processed[childid];\n      });\n\n      loopParents(this, itemid, function (parentid, parent, parentLevel) {\n        if (!processed.hasOwnProperty(parentid)) {\n          processed[parentid] = null;\n\n          if (onItem.call(thisArg, parentid, parent, 1)) {\n            processed[parentid] = SKIP;\n          }\n\n          loopChildren(this, parentid, function (childid, child, childLevel) {\n            if (!processed.hasOwnProperty(childid)) {\n              processed[childid] = true;\n\n              if (onItem.call(thisArg, childid, child, 2)) {\n                processed[childid] = SKIP;\n              }\n            }\n            return processed[childid];\n          });\n\n        }\n        return processed[parentid];\n      });\n    }\n  }\n  /**\n   * Callback for getting default edge value\n   * \n   * @callback onFamilyEdgeCallback\n   * @param {string} from From node id\n   * @param {string} to The node\n   * @returns {object} Returns new edge object.\n   */\n\n  /**\n   * Creates graph structure out of the family structure.\n   * \n   * @param {Object} thisArg The callback function invocation context\n   * @param {onFamilyEdgeCallback} onEdge A callback function to call for every new edge added to the final graph\n   * @returns {graph} Returns graph structure of the family.\n   */\n  function getGraph(thisArg, onEdge) {\n    var result = Graph(),\n      from, to;\n\n    for (from in _children) {\n      if (_children.hasOwnProperty(from)) {\n        _loop(this, _children, from, function (to) {\n          var edge = result.edge(from, to);\n          if (edge == null) {\n            if (onEdge == null) {\n              edge = new ReferencesEdge({});\n            } else {\n              edge = onEdge.call(thisArg, from, to);\n            }\n            result.addEdge(from, to, edge);\n          }\n        }); //ignore jslint\n      }\n    }\n\n    return result;\n  }\n\n  function GroupBy(parentid, childid) {\n    this.parentid = parentid;\n    this.childid = childid;\n    this.ids = [];\n    this.nodes = [];\n  }\n\n\n  function groupBy(thisArg, size, onGroup) { //function onGroup(parent, child, nodes)\n    if (onGroup != null) {\n      var groups = {};\n      for (var nodeid in _nodes) {\n        var parentsCount = _parentsCount[nodeid] || 0;\n        var childrenCount = _childrenCount[nodeid] || 0;\n        if (parentsCount <= 1 && childrenCount <= 1) {\n          var parentid = firstParent(nodeid);\n          var childid = firstChild(nodeid);\n          var key = parentid + \" * \" + childid;\n          if (!groups.hasOwnProperty(key)) {\n            groups[key] = new GroupBy(parentid, childid);\n          }\n          groups[key].ids.push(nodeid);\n          groups[key].nodes.push(_nodes[nodeid]);\n        }\n      }\n\n      for (key in groups) {\n        if (groups.hasOwnProperty(key)) {\n          var group = groups[key];\n          if (group.ids.length >= size) {\n            if (onGroup.call(thisArg, group.parentid, group.childid, group.ids, group.nodes)) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Validates internal data structure consistency of the family.\n   * @param {object} info Optional validation object. \n   */\n  function validate(info) {\n    var parent, child;\n\n    function _count(items) {\n      var result = 0, key;\n      if (items != null) {\n        for (key in items) {\n          if (items.hasOwnProperty(key)) {\n            result += 1;\n          }\n        }\n      }\n      return result;\n    }\n\n    loop(this, function (nodeId, node) {\n      _loop(this, _children, nodeId, function (child) {\n        if (!_parents.hasOwnProperty(child) || !_parents[child].hasOwnProperty(nodeId)) {\n          if (info != null) {\n            info.message = \"Child #\" + child + \" does not reference parent #\" + nodeId;\n          }\n          return false;\n        }\n      });\n      _loop(this, _parents, nodeId, function (parent) {\n        if (!_children.hasOwnProperty(parent) || !_children[parent].hasOwnProperty(nodeId)) {\n          if (info != null) {\n            info.message = \"Parent #\" + parent + \" does not reference child #\" + nodeId;\n          }\n          return false;\n        }\n      });\n    });\n\n    for (parent in _parents) {\n      if (_parents.hasOwnProperty(parent)) {\n        if ((_parentsCount[parent] || 0) != _count(_parents[parent])) {\n          if (info != null) {\n            info.message = \"Parents count for item #\" + parent + \" missmatch.\";\n          }\n          return false;\n        }\n        if (_parents.hasOwnProperty(parent) && !_nodes.hasOwnProperty(parent)) {\n          if (info != null) {\n            info.message = \"Orphant parents for item #\" + parent;\n          }\n          return false;\n        }\n      }\n    }\n\n    for (child in _children) {\n      if (_children.hasOwnProperty(child)) {\n        if ((_childrenCount[child] || 0) != _count(_children[child])) {\n          if (info != null) {\n            info.message = \"Children count for item \" + child + \" missmatch.\";\n          }\n          return false;\n        }\n        if (_children.hasOwnProperty(child) && !_nodes.hasOwnProperty(child)) {\n          if (info != null) {\n            info.message = \"Orphant children of item \" + child;\n          }\n          return false;\n        }\n      }\n    }\n\n    for (child in _roots) {\n      if (_roots.hasOwnProperty(child)) {\n        if ((_rootsCount[child] || 0) != _count(_roots[child])) {\n          if (info != null) {\n            info.message = \"Root children count for item @\" + child + \" missmatch.\";\n          }\n          return false;\n        }\n        _loop(this, _roots, child, function (nodeid) {\n          if (!_nodes.hasOwnProperty(nodeid)) {\n            if (info != null) {\n              info.message = \"Child #\" + nodeid + \"of root #\" + child + \" does not exists.\";\n            }\n            return false;\n          }\n        }); //ignore jslint\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Checks if family structure has loops in references. \n   * @returns {boolean} Returns true if family structure contains loops in references.\n   */\n  function hasLoops() {\n    var tempFamily = clone();\n    loopTopo(this, function (itemid, item, levelIndex) {\n      tempFamily.removeNode(itemid);\n    });\n\n    return tempFamily.hasNodes();\n  }\n\n  /**\n   * Clones family structure.\n   * \n   * @returns {family} Returns copy of the family structure.\n   */\n  function clone() {\n    return Family({\n      roots: _roots,\n      rootsCount: _rootsCount,\n      children: _children,\n      childrenCount: _childrenCount,\n      parents: _parents,\n      parentsCount: _parentsCount,\n      nodes: _nodes\n    });\n  }\n\n  return {\n    /* family structure modification */\n    add: add,\n    adopt: adopt,\n    bundleChildren: bundleChildren,\n    bundleParents: bundleParents,\n    optimizeReferences: optimizeReferences,\n    eliminateManyToMany: eliminateManyToMany,\n    groupBy: groupBy,\n    getPlanarFamily: getPlanarFamily,\n    getFamilyWithoutGrandParentsRelations: getFamilyWithoutGrandParentsRelations,\n    getGraph: getGraph,\n\n    removeNode: removeNode,\n    removeRelation: removeRelation,\n    removeChildRelation: removeChildRelation,\n\n    /* referencing and looping */\n    node: node,\n    loop: loop,\n    loopLevels: loopLevels,\n    loopTopo: loopTopo,\n    loopTopoReversed: loopTopoReversed,\n    loopChildren: loopChildren,\n    loopParents: loopParents,\n    findLargestRoot: findLargestRoot,\n    loopRoots: loopRoots,\n    hasNodes: hasNodes,\n    hasCommonChild: hasCommonChild,\n    loopNeighbours: loopNeighbours,\n    countChildren: countChildren,\n    countParents: countParents,\n    firstParent: firstParent,\n    firstChild: firstChild,\n\n    /* force validation */\n    validate: validate,\n    hasLoops: hasLoops,\n    clone: clone,\n\n    // callback return codes\n    BREAK: BREAK, // break loop immidiatly\n    SKIP: SKIP // skip loop of current node children \n  };\n};"]},"metadata":{},"sourceType":"module"}