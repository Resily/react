{"ast":null,"code":"import Family from '../../algorithms/Family';\nimport Tree from '../../algorithms/Tree';\nimport { SideFlag, Visibility, HorizontalAlignmentType, AdviserPlacementType, Enabled, ChildrenPlacementType, ItemType } from '../../enums';\nimport TreeItem from '../../models/TreeItem';\n/* method uses structures created in orgTreeTask to create visual tree used to render chart\n  It populates visualTree structure with TreeItem objects.\n  \n  1. Create invisble visual root item, so all orphants added to it, but since it is invisible, no connections are going to be drawn betwen them\n  2. Loop orgTree nodes and populate visual tree hierarchy: visualTree\n*/\n\nexport default function VisualTreeTask(orgTreeTask, activeItemsTask, visualTreeOptionTask, isFamilyChartMode) {\n  var _data = {\n    visualTree: null,\n\n    /* Tree(); key: TreeItem.id value: TreeItem */\n    leftMargins: {},\n    rightMargins: {},\n    navigationFamily: null\n    /* Family structure where key: TreeItem.id and value: TreeItem */\n\n  },\n      _treeItemCounter,\n      _activeItems;\n\n  function process() {\n    var orgTree = orgTreeTask.getOrgTree(),\n        options = visualTreeOptionTask.getOptions();\n    _activeItems = activeItemsTask != null ? activeItemsTask.getActiveItems() : {};\n    _data.visualTree = Tree();\n    _data.navigationFamily = Family();\n    _treeItemCounter = orgTreeTask.getMaximumId();\n\n    if (orgTree.hasNodes()) {\n      createVisualTreeItems(orgTree, options, _data.visualTree);\n    }\n\n    _data.leftMargins = {}, _data.rightMargins = {};\n    updateVisualTreeMargins(_data.visualTree, _data.leftMargins, _data.rightMargins);\n    return true;\n  }\n\n  function createVisualTreeItems(orgTree, options, visualTree) {\n    var treeItem,\n        visualParent,\n        visualAggregator,\n        leftSiblingIndex,\n        rightSiblingIndex,\n        index,\n        len,\n        item,\n        childIndex,\n        childrenLen,\n        depth,\n        rowDepths,\n        rowDepth,\n        rowAggregators = {},\n        rowAggregator,\n        rowChildren = {},\n        children,\n        leftSiblingOffset,\n        rightSiblingOffset,\n        partners = {},\n        tempPartners;\n    /* org tree item has visible children */\n\n    orgTree.loopPostOrder(this, function (nodeid, node, parentid, parent) {\n      node.hasVisibleChildren = node.isVisible || node.hasVisibleChildren;\n\n      if (parent != null) {\n        parent.hasVisibleChildren = parent.hasVisibleChildren || node.hasVisibleChildren;\n      }\n    });\n    orgTree.loopLevels(this, function (parentOrgItemId, parentOrgItem, levelid) {\n      var logicalParentItem, regularChildrenLevels, shiftParent;\n\n      if (!isFamilyChartMode && !parentOrgItem.hasVisibleChildren) {\n        return orgTree.SKIP;\n      }\n\n      logicalParentItem = visualTree.node(parentOrgItemId);\n\n      if (!logicalParentItem) {\n        logicalParentItem = getNewTreeItem({\n          visibility: Visibility.Invisible,\n          connectorPlacement: 0,\n          parentId: null,\n          actualItemType: ItemType.Regular\n        }, parentOrgItem);\n        visualTree.add(null, parentOrgItemId, logicalParentItem);\n      }\n      /* find left and right siblings margins of logical parent item\n        they are needed to properly place GeneralPartner & LimitedPartner nodes. */\n\n\n      leftSiblingOffset = 0;\n      rightSiblingOffset = 0;\n\n      if ((index = visualTree.indexOf(parentOrgItemId)) != null) {\n        leftSiblingOffset = index;\n        rightSiblingOffset = visualTree.countSiblings(parentOrgItemId) - index - 1;\n      }\n      /* populate children */\n\n\n      regularChildrenLevels = [];\n      /* children added after all other custom item types */\n\n      orgTree.loopChildren(this, parentOrgItemId, function (orgItemId, orgItem, index) {\n        if (isFamilyChartMode || orgItem.hasVisibleChildren) {\n          treeItem = getNewTreeItem({\n            parentId: parentOrgItemId,\n            actualItemType: orgItem.itemType\n          }, orgItem);\n\n          switch (logicalParentItem.actualItemType) {\n            case ItemType.LimitedPartner:\n            case ItemType.AdviserPartner:\n            case ItemType.GeneralPartner:\n              switch (treeItem.actualItemType) {\n                case ItemType.LimitedPartner:\n                case ItemType.AdviserPartner:\n                case ItemType.GeneralPartner:\n                  /* Don't support partner of partner */\n                  treeItem.actualItemType = ItemType.Adviser;\n                  break;\n\n                case ItemType.Regular:\n                  /* Don't support regular children of partner */\n                  treeItem.actualItemType = ItemType.Assistant;\n                  break;\n              }\n\n              break;\n          }\n\n          switch (treeItem.actualItemType) {\n            case ItemType.SubAdviser:\n              defineNavigationParent(logicalParentItem, treeItem);\n              treeItem.connectorPlacement = SideFlag.Top | SideFlag.Bottom;\n              shiftParent = getNewTreeItem({\n                visibility: Visibility.Invisible\n              });\n              visualTree.add(shiftParent.id, treeItem.id, treeItem);\n              treeItem = shiftParent;\n            //ignore jslint\n\n            case ItemType.AdviserPartner: //ignore jslint\n\n            case ItemType.Adviser:\n              //ignore jslint\n              visualParent = visualTree.parent(parentOrgItemId);\n\n              if (logicalParentItem.connectorPlacement & SideFlag.Right) {\n                leftSiblingIndex = findLeftSiblingIndex(visualTree, _data.navigationFamily, logicalParentItem);\n                visualTree.add(visualParent.id, treeItem.id, treeItem, leftSiblingIndex + 1);\n                treeItem.connectorPlacement = SideFlag.Right | SideFlag.Bottom;\n                treeItem.gravity = HorizontalAlignmentType.Right;\n              } else if (logicalParentItem.connectorPlacement & SideFlag.Left) {\n                rightSiblingIndex = findRightSiblingIndex(visualTree, _data.navigationFamily, logicalParentItem);\n                visualTree.add(visualParent.id, treeItem.id, treeItem, rightSiblingIndex);\n                treeItem.connectorPlacement = SideFlag.Left | SideFlag.Bottom;\n                treeItem.gravity = HorizontalAlignmentType.Left;\n              } else {\n                switch (orgItem.adviserPlacementType) {\n                  case AdviserPlacementType.Left:\n                    leftSiblingIndex = findLeftSiblingIndex(visualTree, _data.navigationFamily, logicalParentItem);\n                    visualTree.add(visualParent.id, treeItem.id, treeItem, leftSiblingIndex + 1);\n                    treeItem.connectorPlacement = SideFlag.Right | SideFlag.Bottom;\n                    treeItem.gravity = HorizontalAlignmentType.Right;\n                    break;\n\n                  default:\n                    rightSiblingIndex = findRightSiblingIndex(visualTree, _data.navigationFamily, logicalParentItem);\n                    visualTree.add(visualParent.id, treeItem.id, treeItem, rightSiblingIndex);\n                    treeItem.connectorPlacement = SideFlag.Left | SideFlag.Bottom;\n                    treeItem.gravity = HorizontalAlignmentType.Left;\n                    break;\n                }\n              }\n\n              switch (treeItem.actualItemType) {\n                case ItemType.SubAdviser:\n                  break;\n\n                case ItemType.AdviserPartner:\n                  if (logicalParentItem.parentId != null) {\n                    defineNavigationParent(visualTree.node(logicalParentItem.parentId), treeItem);\n                  } else {\n                    defineNavigationParent(logicalParentItem, treeItem, true);\n                  }\n\n                  break;\n\n                case ItemType.Adviser:\n                  defineNavigationParent(logicalParentItem, treeItem);\n                  break;\n              }\n\n              break;\n\n            case ItemType.SubAssistant:\n              defineNavigationParent(logicalParentItem, treeItem);\n              treeItem.connectorPlacement = SideFlag.Top | SideFlag.Bottom;\n              shiftParent = getNewTreeItem({\n                visibility: Visibility.Invisible\n              });\n              visualTree.add(shiftParent.id, treeItem.id, treeItem);\n              treeItem = shiftParent;\n            //ignore jslint\n\n            case ItemType.Assistant:\n              //ignore jslint\n              var parent = createNewVisualAggregatorWithGivenDepth(visualTree, logicalParentItem, false, false, orgItem.levelOffset || 0);\n\n              switch (orgItem.adviserPlacementType) {\n                case AdviserPlacementType.Left:\n                  visualTree.add(parent.id, treeItem.id, treeItem, 0);\n                  treeItem.connectorPlacement = SideFlag.Right | SideFlag.Bottom;\n                  treeItem.gravity = HorizontalAlignmentType.Right;\n                  break;\n\n                default:\n                  visualTree.add(parent.id, treeItem.id, treeItem);\n                  treeItem.connectorPlacement = SideFlag.Left | SideFlag.Bottom;\n                  treeItem.gravity = HorizontalAlignmentType.Left;\n                  break;\n              }\n\n              if (treeItem.actualItemType == ItemType.Assistant) {\n                defineNavigationParent(logicalParentItem, treeItem);\n              }\n\n              break;\n\n            case ItemType.Regular:\n              var levelOffset = orgItem.levelOffset || 0;\n\n              if (regularChildrenLevels[levelOffset] == null) {\n                regularChildrenLevels[levelOffset] = [treeItem];\n              } else {\n                regularChildrenLevels[levelOffset].push(treeItem);\n              }\n\n              defineNavigationParent(logicalParentItem, treeItem);\n              break;\n\n            case ItemType.LimitedPartner:\n            case ItemType.GeneralPartner:\n              visualParent = visualTree.parent(parentOrgItemId);\n\n              if (logicalParentItem.connectorPlacement & SideFlag.Right) {\n                visualTree.add(visualParent.id, treeItem.id, treeItem, leftSiblingOffset);\n                treeItem.connectorPlacement = SideFlag.Right | SideFlag.Bottom;\n                treeItem.gravity = HorizontalAlignmentType.Right;\n              } else if (logicalParentItem.connectorPlacement & SideFlag.Left) {\n                visualTree.add(visualParent.id, treeItem.id, treeItem, visualTree.countChildren(visualParent.id) - rightSiblingOffset);\n                treeItem.connectorPlacement = SideFlag.Left | SideFlag.Bottom;\n                treeItem.gravity = HorizontalAlignmentType.Left;\n              } else {\n                switch (orgItem.adviserPlacementType) {\n                  case AdviserPlacementType.Left:\n                    visualTree.add(visualParent.id, treeItem.id, treeItem, leftSiblingOffset);\n                    treeItem.gravity = HorizontalAlignmentType.Right;\n                    break;\n\n                  default:\n                    visualTree.add(visualParent.id, treeItem.id, treeItem, visualTree.countChildren(visualParent.id) - rightSiblingOffset);\n                    treeItem.gravity = HorizontalAlignmentType.Left;\n                    break;\n                }\n\n                switch (treeItem.actualItemType) {\n                  case ItemType.GeneralPartner:\n                    treeItem.connectorPlacement = SideFlag.Top | SideFlag.Bottom;\n                    break;\n\n                  case ItemType.LimitedPartner:\n                    treeItem.connectorPlacement = SideFlag.Bottom;\n                    break;\n                }\n              }\n\n              if (logicalParentItem.parentId != null) {\n                defineNavigationParent(visualTree.node(logicalParentItem.parentId), treeItem);\n              } else {\n                defineNavigationParent(logicalParentItem, treeItem, true);\n              }\n\n              break;\n          }\n        }\n      });\n      /* collect partners, add logicalParentItem into partners collection */\n\n      switch (logicalParentItem.actualItemType) {\n        case ItemType.LimitedPartner:\n        case ItemType.AdviserPartner:\n        case ItemType.GeneralPartner:\n          break;\n\n        default:\n          tempPartners = [];\n\n          if ((visualParent = visualTree.parent(parentOrgItemId)) != null) {\n            visualTree.loopChildrenRange(this, visualParent.id, leftSiblingOffset, visualTree.countChildren(visualParent.id) - rightSiblingOffset, function (childItemId, childItem, index) {\n              if (childItem.id == parentOrgItemId) {\n                tempPartners.push(childItem);\n              } else {\n                switch (childItem.actualItemType) {\n                  case ItemType.LimitedPartner:\n                  case ItemType.AdviserPartner:\n                  case ItemType.GeneralPartner:\n                    if (orgTree.parentid(childItem.id) == parentOrgItemId) {\n                      tempPartners.push(childItem);\n                    }\n\n                    break;\n                }\n              }\n            });\n          }\n\n          if (tempPartners.length > 1) {\n            partners[parentOrgItemId] = tempPartners;\n          }\n\n          break;\n      }\n\n      rowAggregators[parentOrgItemId] = [];\n      rowChildren[parentOrgItemId] = [];\n      var aggregators = [];\n\n      if (regularChildrenLevels.length > 0) {\n        visualParent = getLastVisualAggregator(visualTree, logicalParentItem);\n\n        for (var indexLevel = 0; indexLevel < regularChildrenLevels.length - 1; indexLevel += 1) {\n          var regularChildrenLevel = regularChildrenLevels[indexLevel] || [];\n\n          if (regularChildrenLevel != null) {\n            var hideChildConnector = logicalParentItem.visibility == Visibility.Invisible && logicalParentItem.connectorPlacement === 0;\n            var nextVisualParent = createNewVisualAggregator(visualTree, visualParent, hideChildConnector);\n            aggregators.push([nextVisualParent]);\n            var medianIndex = 0;\n\n            switch (options.horizontalAlignment) {\n              case HorizontalAlignmentType.Center:\n                medianIndex = Math.ceil(regularChildrenLevel.length / 2) - 1;\n                break;\n\n              case HorizontalAlignmentType.Left:\n                medianIndex = -1;\n                break;\n\n              case HorizontalAlignmentType.Right:\n                medianIndex = regularChildrenLevel.length - 1;\n                break;\n            }\n\n            for (index = medianIndex; index >= 0; index -= 1) {\n              item = regularChildrenLevel[index];\n              visualTree.add(visualParent.id, item.id, item, 0);\n              item.connectorPlacement = SideFlag.Top | SideFlag.Bottom;\n              item.gravity = HorizontalAlignmentType.Right;\n            }\n\n            for (index = medianIndex + 1; index < regularChildrenLevel.length; index += 1) {\n              item = regularChildrenLevel[index];\n              visualTree.add(visualParent.id, item.id, item);\n              item.connectorPlacement = SideFlag.Top | SideFlag.Bottom;\n              item.gravity = HorizontalAlignmentType.Left;\n            }\n\n            visualParent = nextVisualParent;\n          }\n        }\n        /* add children */\n\n\n        var regularChildren = regularChildrenLevels[regularChildrenLevels.length - 1];\n        layoutChildren(orgTree, visualTree, options, logicalParentItem, regularChildren, parentOrgItem.childrenPlacementType, rowAggregators[parentOrgItemId], rowChildren[parentOrgItemId]);\n        rowAggregators[parentOrgItemId] = rowAggregators[parentOrgItemId].concat(aggregators);\n        rowChildren[parentOrgItemId] = rowChildren[parentOrgItemId].concat(regularChildrenLevels.slice(0, regularChildrenLevels.length - 1));\n      }\n    });\n    /* transform tree to place children sub branches inside of hierarchy */\n\n    orgTree.loopPostOrder(this, function (nodeid, node, parentid, parent) {\n      var logicalParentItem = visualTree.node(nodeid),\n          itemRowChildren,\n          itemRowAggregators,\n          hasChildren,\n          hasPartners = partners[parentid] != null,\n          extendChildren;\n\n      if (logicalParentItem != null) {\n        itemRowChildren = rowChildren[nodeid];\n        itemRowAggregators = rowAggregators[nodeid];\n        /* Move assistants children inside */\n\n        if (parent != null) {\n          extendChildren = hasPartners;\n\n          switch (parent.placeAssistantsAboveChildren) {\n            case Enabled.Auto:\n              if (options.placeAssistantsAboveChildren) {\n                extendChildren = true;\n              }\n\n              break;\n\n            case Enabled.True:\n              extendChildren = true;\n              break;\n          }\n\n          if (extendChildren) {\n            depth = getAssistantsDepth(visualTree, logicalParentItem);\n\n            if (depth > 0) {\n              logicalParentItem.visualDepth = depth + 1;\n\n              if (logicalParentItem.visualAggregatorId !== null) {\n                visualAggregator = visualTree.node(logicalParentItem.visualAggregatorId);\n                hasChildren = visualTree.hasChildren(visualAggregator.id);\n\n                for (index = 0; index < depth - 1; index += 1) {\n                  visualAggregator = createNewVisualAggregator(visualTree, visualAggregator, !hasChildren);\n                }\n              }\n            }\n          }\n        }\n        /* Move advisers children inside */\n\n\n        if (parent != null) {\n          extendChildren = hasPartners;\n\n          switch (parent.placeAdvisersAboveChildren) {\n            case Enabled.Auto:\n              if (options.placeAdvisersAboveChildren) {\n                extendChildren = true;\n              }\n\n              break;\n\n            case Enabled.True:\n              extendChildren = true;\n              break;\n          }\n\n          if (extendChildren) {\n            depth = getAdvisersDepth(visualTree, logicalParentItem);\n\n            if (depth > 1) {\n              logicalParentItem.visualDepth += depth - 1;\n              hasChildren = visualTree.hasChildren(nodeid);\n              visualAggregator = logicalParentItem;\n\n              for (index = 0; index < depth - 1; index += 1) {\n                visualAggregator = createNewVisualAggregator(visualTree, visualAggregator, !hasChildren);\n              }\n            }\n          }\n        }\n        /* Move children of children inside */\n\n\n        rowDepths = [];\n\n        for (index = 0, len = itemRowChildren.length; index < len; index += 1) {\n          children = itemRowChildren[index];\n          rowDepths[index] = 0;\n\n          if (children != null) {\n            for (childIndex = 0, childrenLen = children.length; childIndex < childrenLen; childIndex += 1) {\n              rowDepths[index] = Math.max(rowDepths[index], getItemDepth(visualTree, children[childIndex]));\n            }\n          }\n        }\n\n        for (index = 0, len = rowDepths.length; index < len; index += 1) {\n          rowDepth = rowDepths[index];\n\n          if (rowDepth > 1) {\n            for (childIndex = 0, childrenLen = itemRowAggregators[index].length; childIndex < childrenLen; childIndex += 1) {\n              rowAggregator = itemRowAggregators[index][childIndex];\n\n              if (visualTree.hasChildren(rowAggregator.id)) {\n                depth = rowDepth;\n\n                while (depth > 1) {\n                  rowAggregator = createNewVisualAggregator(visualTree, rowAggregator, false);\n                  depth -= 1;\n                }\n              }\n            }\n          }\n        }\n        /* Align heights of partner branches in order to draw connector lines between them and logical parent children */\n\n\n        if (partners[nodeid] != null) {\n          /* partners collection includes treeItem so we should have at least 2 items */\n          layoutPartners(visualTree, logicalParentItem, partners[nodeid]);\n        }\n      }\n    });\n  }\n\n  function layoutPartners(visualTree, treeItem, partners) {\n    var partner,\n        index,\n        len,\n        depth,\n        maxDepth = 0,\n        visualPartners = [],\n        visualPartner,\n        visualParent,\n        visualAggregator,\n        leftSiblingIndex,\n        gravity;\n    /* Find maximum depth required to enclose partners branches */\n\n    for (index = 0, len = partners.length; index < len; index += 1) {\n      partner = partners[index];\n      maxDepth = Math.max(maxDepth, partner.visualDepth);\n    }\n    /* Extend visual aggregators lines and ensure that connector lines are visible */\n\n\n    for (index = 0, len = partners.length; index < len; index += 1) {\n      partner = partners[index];\n      visualPartner = getLastVisualAggregator(visualTree, partner);\n      depth = 1;\n      visualAggregator = partner;\n\n      while (visualAggregator.visualAggregatorId != null) {\n        visualAggregator = visualTree.node(visualAggregator.visualAggregatorId);\n        visualAggregator.connectorPlacement = SideFlag.Top | SideFlag.Bottom;\n        depth += 1;\n      }\n\n      while (depth < maxDepth) {\n        visualPartner = createNewVisualAggregator(visualTree, visualPartner, false);\n        depth += 1;\n      }\n\n      visualPartners.push(getLastVisualAggregator(visualTree, visualPartner).id);\n    }\n\n    visualAggregator = getLastVisualAggregator(visualTree, treeItem);\n\n    if (visualTree.hasChildren(visualAggregator.id)) {\n      /* Select middle partner */\n      visualPartner = partners[Math.floor(partners.length / 2)];\n\n      if (partners.length > 1 && partners.length % 2 === 0) {\n        /* insert invisble partner for alignemnt */\n        visualParent = visualTree.parent(visualPartner.id);\n        leftSiblingIndex = findLeftSiblingIndex(visualTree, _data.navigationFamily, visualPartner);\n        gravity = visualTree.getChild(visualParent.id, leftSiblingIndex).gravity || visualTree.getChild(visualParent.id, leftSiblingIndex + 1).gravity; // visualParent.id,\n\n        visualPartner = getNewTreeItem({\n          visibility: Visibility.Invisible,\n          connectorPlacement: visualPartner.connectorPlacement & (SideFlag.Left | SideFlag.Right),\n          gravity: gravity\n        });\n        visualTree.add(visualParent.id, visualPartner.id, visualPartner, leftSiblingIndex + 1);\n        depth = 1;\n\n        while (depth < maxDepth) {\n          visualPartner = createNewVisualAggregator(visualTree, visualPartner, false);\n          visualPartner.connectorPlacement = 0;\n          depth += 1;\n        }\n      }\n      /* every child logically belongs to every partner */\n\n\n      for (index = 0, len = partners.length; index < len; index += 1) {\n        partner = partners[index];\n        /* select all parents up to the root */\n\n        _data.navigationFamily.loopChildren(this, treeItem.id, function (childItemId, childItem, level) {\n          switch (childItem.actualItemType) {\n            case ItemType.SubAdviser:\n            case ItemType.Adviser:\n            case ItemType.SubAssistant:\n            case ItemType.Assistant:\n              break;\n\n            default:\n              /* partners share only regular items */\n              if (treeItem.id != partner.id) {\n                defineNavigationParent(partner, childItem);\n              }\n\n              break;\n          }\n\n          return _data.navigationFamily.SKIP;\n        }); //ignore jslint\n\n      }\n      /* Move children to new visual partner node */\n\n\n      visualPartner = getLastVisualAggregator(visualTree, visualPartner);\n      visualTree.moveChildren(visualAggregator.id, visualPartner.id);\n    }\n    /* Store collection of visual partners to draw connector lines*/\n\n\n    visualPartner.partners = visualPartners;\n  }\n\n  function getLastVisualAggregator(visualTree, treeItem) {\n    var result = treeItem;\n\n    while (result.visualAggregatorId != null) {\n      result = visualTree.node(result.visualAggregatorId);\n    }\n\n    return result;\n  }\n\n  function getAdvisersDepth(visualTree, treeItem) {\n    var result = 0,\n        parentItem = visualTree.parent(treeItem.id),\n        treeItemIndex,\n        position,\n        childItem;\n\n    if (parentItem !== null) {\n      treeItemIndex = visualTree.indexOf(treeItem.id);\n      position = 1;\n\n      while ((childItem = visualTree.getChild(parentItem.id, treeItemIndex + position)) != null) {\n        if (childItem.connectorPlacement & SideFlag.Left) {\n          result = Math.max(result, getItemDepth(visualTree, childItem));\n          position += 1;\n        } else {\n          break;\n        }\n      }\n\n      position = 1;\n\n      while ((childItem = visualTree.getChild(parentItem.id, treeItemIndex - position)) != null) {\n        if (childItem.connectorPlacement & SideFlag.Right) {\n          result = Math.max(result, getItemDepth(visualTree, childItem));\n          position += 1;\n        } else {\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function getAssistantsDepth(visualTree, treeItem) {\n    var result = 0;\n\n    if (treeItem.visualAggregatorId != null) {\n      visualTree.loopLevels(this, treeItem.id, function (childItemId, childItem, level) {\n        if (treeItem.visualAggregatorId == childItemId) {\n          return visualTree.SKIP;\n        }\n\n        result = level + 1;\n      });\n    }\n\n    return result;\n  }\n\n  function getItemDepth(visualTree, treeItem) {\n    var result = 0;\n    visualTree.loopLevels(this, treeItem.id, function (childid, child, level) {\n      result = level + 1;\n    });\n    return result + 1;\n  }\n\n  function layoutChildren(orgTree, visualTree, options, treeItem, regularChildren, childrenPlacementType, rowAggregators, rowChildren) {\n    var visualParent,\n        currentVisualParent,\n        leftChildItem,\n        rightChildItem,\n        newAggregatorItem,\n        childItem,\n        orgChildItem,\n        width,\n        height,\n        twinColumns,\n        column,\n        row,\n        index,\n        len,\n        singleItemPlacement,\n        hideParentConnector = treeItem.visibility == Visibility.Invisible && treeItem.connectorPlacement === 0;\n\n    switch (options.horizontalAlignment) {\n      case HorizontalAlignmentType.Center:\n      case HorizontalAlignmentType.Left:\n        singleItemPlacement = AdviserPlacementType.Right;\n        break;\n\n      case HorizontalAlignmentType.Right:\n        singleItemPlacement = AdviserPlacementType.Left;\n        break;\n    }\n\n    if (childrenPlacementType === ChildrenPlacementType.Auto) {\n      if (hasRegularLeavesOnly(orgTree, treeItem)) {\n        childrenPlacementType = options.leavesPlacementType === ChildrenPlacementType.Auto ? ChildrenPlacementType.Matrix : options.leavesPlacementType;\n      } else {\n        childrenPlacementType = options.childrenPlacementType === ChildrenPlacementType.Auto ? ChildrenPlacementType.Horizontal : options.childrenPlacementType;\n      }\n    }\n\n    visualParent = getLastVisualAggregator(visualTree, treeItem);\n\n    if (childrenPlacementType == ChildrenPlacementType.Matrix && regularChildren.length < 3) {\n      childrenPlacementType = ChildrenPlacementType.Horizontal;\n    }\n\n    switch (childrenPlacementType) {\n      case ChildrenPlacementType.Horizontal:\n        for (index = 0, len = regularChildren.length; index < len; index += 1) {\n          childItem = regularChildren[index];\n          orgChildItem = orgTree.node(childItem.id);\n          visualTree.add(visualParent.id, childItem.id, childItem);\n          childItem.connectorPlacement = (orgChildItem.hideParentConnection ? 0 : SideFlag.Top) | (orgChildItem.hideChildrenConnection ? 0 : SideFlag.Bottom);\n\n          if (index === 0) {\n            childItem.relationDegree = 1;\n          }\n        }\n\n        break;\n\n      case ChildrenPlacementType.Matrix:\n        width = Math.min(options.maximumColumnsInMatrix, Math.ceil(Math.sqrt(regularChildren.length)));\n        height = Math.ceil(regularChildren.length / width);\n        twinColumns = Math.ceil(width / 2.0);\n\n        for (column = 0; column < twinColumns; column += 1) {\n          currentVisualParent = visualParent;\n\n          for (row = 0; row < height; row += 1) {\n            leftChildItem = getMatrixItem(regularChildren, column * 2, row, width);\n            rightChildItem = getMatrixItem(regularChildren, column * 2 + 1, row, width);\n\n            if (rowAggregators[row] === undefined) {\n              rowAggregators[row] = [];\n              rowChildren[row] = [];\n            }\n\n            if (leftChildItem !== null) {\n              if (column === 0) {\n                leftChildItem.relationDegree = 1;\n              }\n\n              visualTree.add(currentVisualParent.id, leftChildItem.id, leftChildItem);\n              leftChildItem.connectorPlacement = (hideParentConnector ? 0 : SideFlag.Right) | SideFlag.Bottom;\n              leftChildItem.gravity = HorizontalAlignmentType.Right;\n              rowChildren[row].push(leftChildItem);\n            }\n\n            if (leftChildItem !== null || rightChildItem !== null) {\n              // currentVisualParent.id,\n              newAggregatorItem = getNewTreeItem({\n                visibility: Visibility.Invisible,\n                connectorPlacement: hideParentConnector ? 0 : SideFlag.Top | SideFlag.Bottom\n              });\n              visualTree.add(currentVisualParent.id, newAggregatorItem.id, newAggregatorItem);\n              rowAggregators[row].push(newAggregatorItem);\n            }\n\n            if (rightChildItem !== null) {\n              visualTree.add(currentVisualParent.id, rightChildItem.id, rightChildItem);\n              rightChildItem.connectorPlacement = (hideParentConnector ? 0 : SideFlag.Left) | SideFlag.Bottom;\n              rightChildItem.gravity = HorizontalAlignmentType.Left;\n              rowChildren[row].push(rightChildItem);\n            }\n\n            currentVisualParent = newAggregatorItem;\n          }\n        }\n\n        if (width > 2) {\n          // No center alignment to aggregator required\n          visualParent.visualAggregatorId = null;\n        }\n\n        break;\n\n      case ChildrenPlacementType.Vertical:\n        for (index = 0, len = regularChildren.length; index < len; index += 1) {\n          childItem = regularChildren[index]; // visualParent.id,\n\n          newAggregatorItem = getNewTreeItem({\n            visibility: Visibility.Invisible,\n            connectorPlacement: hideParentConnector ? 0 : SideFlag.Top | SideFlag.Bottom\n          });\n\n          switch (singleItemPlacement) {\n            case AdviserPlacementType.Left:\n              visualTree.add(visualParent.id, childItem.id, childItem);\n              visualTree.add(visualParent.id, newAggregatorItem.id, newAggregatorItem);\n              childItem.connectorPlacement = (hideParentConnector ? 0 : SideFlag.Right) | SideFlag.Bottom;\n              childItem.gravity = HorizontalAlignmentType.Right;\n              break;\n\n            case AdviserPlacementType.Right:\n              visualTree.add(visualParent.id, newAggregatorItem.id, newAggregatorItem);\n              visualTree.add(visualParent.id, childItem.id, childItem);\n              childItem.connectorPlacement = (hideParentConnector ? 0 : SideFlag.Left) | SideFlag.Bottom;\n              childItem.gravity = HorizontalAlignmentType.Left;\n              break;\n          }\n\n          rowAggregators[index] = [newAggregatorItem];\n          rowChildren[index] = [childItem];\n          visualParent = newAggregatorItem;\n        }\n\n        break;\n\n      default:\n        throw \"Children placement is undefined!\";\n    }\n  }\n\n  function getMatrixItem(items, x, y, width) {\n    var result,\n        isOdd = width % 2 > 0,\n        index;\n\n    if (isOdd) {\n      if (x === width - 1) {\n        x = items.length;\n      } else if (x === width) {\n        x = width - 1;\n      }\n    }\n\n    index = y * width + x;\n    result = index > items.length - 1 ? null : items[index];\n    return result;\n  }\n\n  function hasRegularLeavesOnly(orgTree, treeItem) {\n    var hasChildren = false,\n        hasLeavesOnly = true;\n    orgTree.loopChildren(this, treeItem.id, function (nodeid, node, index) {\n      hasChildren = true;\n\n      if (node.itemType === ItemType.Regular && orgTree.hasChildren(nodeid)) {\n        hasLeavesOnly = false;\n        return true; // break\n      }\n    });\n    return hasChildren && hasLeavesOnly;\n  }\n  /* Sibling is the first item which does not belongs to items logical hierarchy */\n\n\n  function findLeftSiblingIndex(visualTree, navigationFamily, treeItem) {\n    var result = null,\n        ignore = {},\n        visualParent = visualTree.parent(treeItem.id);\n    visualTree.loopChildrenReversed(this, visualParent.id, function (childItemId, childItem, index) {\n      if (result === null) {\n        if (childItemId == treeItem.id) {\n          result = -1;\n          ignore[treeItem.id] = true;\n          navigationFamily.loopChildren(this, treeItem.id, function (childid, child, level) {\n            if (level > 0) {\n              return navigationFamily.BREAK;\n            }\n\n            ignore[childid] = true;\n          });\n        }\n      } else {\n        if (!ignore.hasOwnProperty(childItemId)) {\n          result = index;\n          return true; //ignore jslint\n        } else {\n          navigationFamily.loopChildren(this, childItem.id, function (childid, child, level) {\n            if (level > 0) {\n              return navigationFamily.BREAK;\n            }\n\n            ignore[childid] = true;\n          });\n        }\n      }\n    });\n    return result;\n  }\n  /* Sibling is the first item which does not belongs to items logical hierarchy */\n\n\n  function findRightSiblingIndex(visualTree, navigationFamily, treeItem) {\n    var result = null,\n        ignore = {},\n        visualParent = visualTree.parent(treeItem.id);\n    visualTree.loopChildren(this, visualParent.id, function (childItemId, childItem, index, lastIndex) {\n      if (result === null) {\n        if (childItemId == treeItem.id) {\n          result = lastIndex + 1;\n          ignore[treeItem.id] = true;\n          navigationFamily.loopChildren(this, treeItem.id, function (childid, child, level) {\n            if (level > 0) {\n              return navigationFamily.BREAK;\n            }\n\n            ignore[childid] = true;\n          });\n        }\n      } else {\n        if (!ignore.hasOwnProperty(childItemId)) {\n          result = index;\n          return true; //ignore jslint\n        } else {\n          navigationFamily.loopChildren(this, childItemId, function (childid, child, level) {\n            if (level > 0) {\n              return navigationFamily.BREAK;\n            }\n\n            ignore[childid] = true;\n          });\n        }\n      }\n    });\n    return result;\n  }\n\n  function createNewVisualAggregatorWithGivenDepth(visualTree, treeItem, hideParentConnector, hideChildrenConnector, depth) {\n    var result = null,\n        newAggregatorItem;\n    hideParentConnector = hideParentConnector || hideChildrenConnector;\n    var index = 0;\n\n    while (index <= depth) {\n      if (result == null) {\n        result = treeItem;\n      } else {\n        result = visualTree.node(result.visualAggregatorId);\n      }\n\n      if (result.visualAggregatorId == null) {\n        newAggregatorItem = getNewTreeItem({\n          visibility: Visibility.Invisible,\n          visualAggregatorId: null,\n          connectorPlacement: hideParentConnector ? 0 : SideFlag.Top | SideFlag.Bottom\n        });\n        visualTree.insert(result.id, newAggregatorItem.id, newAggregatorItem);\n        result.visualAggregatorId = newAggregatorItem.id;\n      }\n\n      index += 1;\n    }\n\n    return result;\n  }\n\n  function createNewVisualAggregator(visualTree, treeItem, hideChildrenConnector) {\n    var newAggregatorItem,\n        hideParentConnector = treeItem.visibility == Visibility.Invisible && treeItem.connectorPlacement === 0 || hideChildrenConnector;\n    newAggregatorItem = getNewTreeItem({\n      visibility: Visibility.Invisible,\n      visualAggregatorId: treeItem.visualAggregatorId,\n      connectorPlacement: hideParentConnector ? 0 : SideFlag.Top | SideFlag.Bottom\n    });\n    visualTree.insert(treeItem.id, newAggregatorItem.id, newAggregatorItem);\n    treeItem.visualAggregatorId = newAggregatorItem.id;\n    return newAggregatorItem;\n  }\n\n  function getNewTreeItem(properties, orgItem) {\n    var result = new TreeItem(),\n        optionKey;\n\n    for (optionKey in properties) {\n      if (properties.hasOwnProperty(optionKey)) {\n        result[optionKey] = properties[optionKey];\n      }\n    }\n\n    if (orgItem != null) {\n      result.id = orgItem.id;\n      result.visibility = orgItem.isVisible ? Visibility.Auto : Visibility.Invisible;\n    } else {\n      _treeItemCounter += 1;\n      result.id = _treeItemCounter;\n    }\n\n    return result;\n  }\n\n  function defineNavigationParent(parentItem, treeItem, skipFirstParent) {\n    var parents = [];\n    /* take logicalParentItem when it is visible or collect all visible immidiate parents of logicalParentItem */\n\n    if (skipFirstParent || parentItem.visibility == Visibility.Invisible || !_activeItems.hasOwnProperty(parentItem.id)) {\n      if (!skipFirstParent) {\n        parents.push(parentItem.id);\n      }\n\n      _data.navigationFamily.loopParents(this, parentItem.id, function (parentid, parent, level) {\n        if (parent.visibility != Visibility.Invisible) {\n          parents.push(parentid);\n\n          if (_activeItems.hasOwnProperty(parentid)) {\n            return _data.navigationFamily.SKIP;\n          }\n        }\n      });\n    } else {\n      parents.push(parentItem.id);\n    }\n\n    if (_data.navigationFamily.node(treeItem.id) != null) {\n      _data.navigationFamily.adopt(parents, treeItem.id);\n    } else {\n      _data.navigationFamily.add(parents, treeItem.id, treeItem);\n    }\n  }\n\n  function updateVisualTreeMargins(visualTree, leftMargins, rightMargins) {\n    visualTree.loop(this, function (nodeid, node) {\n      leftMargins[nodeid] = [];\n      rightMargins[nodeid] = [];\n    });\n    visualTree.loopPostOrder(this, function (nodeid, node, parentid, parent) {\n      var parentLeftMargins = leftMargins[parentid],\n          parentRightMargins = rightMargins[parentid],\n          nodeLeftMargins = leftMargins[nodeid],\n          nodeRightMargins = rightMargins[nodeid],\n          index,\n          len;\n\n      if (parentid != null) {\n        /* update parent left margins */\n        if (!parentLeftMargins[0]) {\n          parentLeftMargins[0] = nodeid;\n        }\n\n        for (index = 0, len = nodeLeftMargins.length; index < len; index += 1) {\n          if (!parentLeftMargins[index + 1]) {\n            parentLeftMargins[index + 1] = nodeLeftMargins[index];\n          }\n        }\n        /* update parent rights margins */\n\n\n        parentRightMargins[0] = nodeid;\n\n        for (index = 0, len = nodeRightMargins.length; index < len; index += 1) {\n          parentRightMargins[index + 1] = nodeRightMargins[index];\n        }\n      }\n    });\n  }\n\n  function getVisualTree() {\n    return _data.visualTree;\n  }\n\n  function getLogicalFamily() {\n    return _data.navigationFamily;\n  }\n\n  function getConnectionsFamily() {\n    return _data.connectionsFamily;\n  }\n\n  function getLeftMargins() {\n    return _data.leftMargins;\n  }\n\n  function getRightMargins() {\n    return _data.rightMargins;\n  }\n\n  return {\n    process: process,\n    getVisualTree: getVisualTree,\n    getLogicalFamily: getLogicalFamily,\n    getConnectionsFamily: getConnectionsFamily,\n    getLeftMargins: getLeftMargins,\n    getRightMargins: getRightMargins\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/tasks/transformations/VisualTreeTask.js"],"names":["Family","Tree","SideFlag","Visibility","HorizontalAlignmentType","AdviserPlacementType","Enabled","ChildrenPlacementType","ItemType","TreeItem","VisualTreeTask","orgTreeTask","activeItemsTask","visualTreeOptionTask","isFamilyChartMode","_data","visualTree","leftMargins","rightMargins","navigationFamily","_treeItemCounter","_activeItems","process","orgTree","getOrgTree","options","getOptions","getActiveItems","getMaximumId","hasNodes","createVisualTreeItems","updateVisualTreeMargins","treeItem","visualParent","visualAggregator","leftSiblingIndex","rightSiblingIndex","index","len","item","childIndex","childrenLen","depth","rowDepths","rowDepth","rowAggregators","rowAggregator","rowChildren","children","leftSiblingOffset","rightSiblingOffset","partners","tempPartners","loopPostOrder","nodeid","node","parentid","parent","hasVisibleChildren","isVisible","loopLevels","parentOrgItemId","parentOrgItem","levelid","logicalParentItem","regularChildrenLevels","shiftParent","SKIP","getNewTreeItem","visibility","Invisible","connectorPlacement","parentId","actualItemType","Regular","add","indexOf","countSiblings","loopChildren","orgItemId","orgItem","itemType","LimitedPartner","AdviserPartner","GeneralPartner","Adviser","Assistant","SubAdviser","defineNavigationParent","Top","Bottom","id","Right","findLeftSiblingIndex","gravity","Left","findRightSiblingIndex","adviserPlacementType","SubAssistant","createNewVisualAggregatorWithGivenDepth","levelOffset","push","countChildren","loopChildrenRange","childItemId","childItem","length","aggregators","getLastVisualAggregator","indexLevel","regularChildrenLevel","hideChildConnector","nextVisualParent","createNewVisualAggregator","medianIndex","horizontalAlignment","Center","Math","ceil","regularChildren","layoutChildren","childrenPlacementType","concat","slice","itemRowChildren","itemRowAggregators","hasChildren","hasPartners","extendChildren","placeAssistantsAboveChildren","Auto","True","getAssistantsDepth","visualDepth","visualAggregatorId","placeAdvisersAboveChildren","getAdvisersDepth","max","getItemDepth","layoutPartners","partner","maxDepth","visualPartners","visualPartner","floor","getChild","level","moveChildren","result","parentItem","treeItemIndex","position","childid","child","currentVisualParent","leftChildItem","rightChildItem","newAggregatorItem","orgChildItem","width","height","twinColumns","column","row","singleItemPlacement","hideParentConnector","hasRegularLeavesOnly","leavesPlacementType","Matrix","Horizontal","hideParentConnection","hideChildrenConnection","relationDegree","min","maximumColumnsInMatrix","sqrt","getMatrixItem","undefined","Vertical","items","x","y","isOdd","hasLeavesOnly","ignore","loopChildrenReversed","BREAK","hasOwnProperty","lastIndex","hideChildrenConnector","insert","properties","optionKey","skipFirstParent","parents","loopParents","adopt","loop","parentLeftMargins","parentRightMargins","nodeLeftMargins","nodeRightMargins","getVisualTree","getLogicalFamily","getConnectionsFamily","connectionsFamily","getLeftMargins","getRightMargins"],"mappings":"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","sourcesContent":["import Family from '../../algorithms/Family';\nimport Tree from '../../algorithms/Tree';\nimport { SideFlag, Visibility, HorizontalAlignmentType, AdviserPlacementType, \n  Enabled, ChildrenPlacementType, ItemType } from '../../enums';\nimport TreeItem from '../../models/TreeItem';\n\n/* method uses structures created in orgTreeTask to create visual tree used to render chart\n  It populates visualTree structure with TreeItem objects.\n  \n  1. Create invisble visual root item, so all orphants added to it, but since it is invisible, no connections are going to be drawn betwen them\n  2. Loop orgTree nodes and populate visual tree hierarchy: visualTree\n*/\nexport default function VisualTreeTask(orgTreeTask, activeItemsTask, visualTreeOptionTask, isFamilyChartMode) {\n  var _data = {\n    visualTree: null, /* Tree(); key: TreeItem.id value: TreeItem */\n    leftMargins: {},\n    rightMargins: {},\n    navigationFamily: null /* Family structure where key: TreeItem.id and value: TreeItem */\n  },\n    _treeItemCounter,\n    _activeItems;\n\n  function process() {\n    var orgTree = orgTreeTask.getOrgTree(),\n      options = visualTreeOptionTask.getOptions();\n\n    _activeItems = activeItemsTask != null ? activeItemsTask.getActiveItems() : {};\n\n    _data.visualTree = Tree();\n    _data.navigationFamily = Family();\n\n    _treeItemCounter = orgTreeTask.getMaximumId();\n\n    if (orgTree.hasNodes()) {\n      createVisualTreeItems(orgTree, options, _data.visualTree);\n    }\n\n\n    _data.leftMargins = {},\n      _data.rightMargins = {};\n    updateVisualTreeMargins(_data.visualTree, _data.leftMargins, _data.rightMargins);\n\n    return true;\n  }\n\n  function createVisualTreeItems(orgTree, options, visualTree) {\n    var treeItem,\n      visualParent,\n      visualAggregator,\n      leftSiblingIndex,\n      rightSiblingIndex,\n      index, len,\n      item,\n      childIndex,\n      childrenLen,\n      depth,\n      rowDepths,\n      rowDepth,\n      rowAggregators = {},\n      rowAggregator,\n      rowChildren = {},\n      children,\n      leftSiblingOffset,\n      rightSiblingOffset,\n      partners = {}, tempPartners;\n\n\n    /* org tree item has visible children */\n    orgTree.loopPostOrder(this, function (nodeid, node, parentid, parent) {\n      node.hasVisibleChildren = node.isVisible || node.hasVisibleChildren;\n      if (parent != null) {\n        parent.hasVisibleChildren = parent.hasVisibleChildren || node.hasVisibleChildren;\n      }\n    });\n\n    orgTree.loopLevels(this, function (parentOrgItemId, parentOrgItem, levelid) {\n      var logicalParentItem,\n        regularChildrenLevels,\n        shiftParent;\n      if (!isFamilyChartMode && !parentOrgItem.hasVisibleChildren) {\n        return orgTree.SKIP;\n      }\n\n      logicalParentItem = visualTree.node(parentOrgItemId);\n      if (!logicalParentItem) {\n        logicalParentItem = getNewTreeItem({\n          visibility: Visibility.Invisible,\n          connectorPlacement: 0,\n          parentId: null,\n          actualItemType: ItemType.Regular\n        }, parentOrgItem);\n        visualTree.add(null, parentOrgItemId, logicalParentItem);\n      }\n\n      /* find left and right siblings margins of logical parent item\n        they are needed to properly place GeneralPartner & LimitedPartner nodes. */\n      leftSiblingOffset = 0;\n      rightSiblingOffset = 0;\n      if ((index = visualTree.indexOf(parentOrgItemId)) != null) {\n        leftSiblingOffset = index;\n        rightSiblingOffset = visualTree.countSiblings(parentOrgItemId) - index - 1;\n      }\n\n      /* populate children */\n      regularChildrenLevels = []; /* children added after all other custom item types */\n      orgTree.loopChildren(this, parentOrgItemId, function (orgItemId, orgItem, index) {\n        if (isFamilyChartMode || orgItem.hasVisibleChildren) {\n          treeItem = getNewTreeItem({\n            parentId: parentOrgItemId,\n            actualItemType: orgItem.itemType\n          }, orgItem);\n\n          switch (logicalParentItem.actualItemType) {\n            case ItemType.LimitedPartner:\n            case ItemType.AdviserPartner:\n            case ItemType.GeneralPartner:\n              switch (treeItem.actualItemType) {\n                case ItemType.LimitedPartner:\n                case ItemType.AdviserPartner:\n                case ItemType.GeneralPartner:\n                  /* Don't support partner of partner */\n                  treeItem.actualItemType = ItemType.Adviser;\n                  break;\n                case ItemType.Regular:\n                  /* Don't support regular children of partner */\n                  treeItem.actualItemType = ItemType.Assistant;\n                  break;\n              }\n              break;\n          }\n\n          switch (treeItem.actualItemType) {\n            case ItemType.SubAdviser:\n              defineNavigationParent(logicalParentItem, treeItem);\n              treeItem.connectorPlacement = SideFlag.Top | SideFlag.Bottom;\n              shiftParent = getNewTreeItem({ visibility: Visibility.Invisible });\n              visualTree.add(shiftParent.id, treeItem.id, treeItem);\n              treeItem = shiftParent;//ignore jslint\n            case ItemType.AdviserPartner://ignore jslint\n            case ItemType.Adviser://ignore jslint\n              visualParent = visualTree.parent(parentOrgItemId);\n              if (logicalParentItem.connectorPlacement & SideFlag.Right) {\n                leftSiblingIndex = findLeftSiblingIndex(visualTree, _data.navigationFamily, logicalParentItem);\n                visualTree.add(visualParent.id, treeItem.id, treeItem, leftSiblingIndex + 1);\n                treeItem.connectorPlacement = SideFlag.Right | SideFlag.Bottom;\n                treeItem.gravity = HorizontalAlignmentType.Right;\n              } else if (logicalParentItem.connectorPlacement & SideFlag.Left) {\n                rightSiblingIndex = findRightSiblingIndex(visualTree, _data.navigationFamily, logicalParentItem);\n                visualTree.add(visualParent.id, treeItem.id, treeItem, rightSiblingIndex);\n                treeItem.connectorPlacement = SideFlag.Left | SideFlag.Bottom;\n                treeItem.gravity = HorizontalAlignmentType.Left;\n              } else {\n                switch (orgItem.adviserPlacementType) {\n                  case AdviserPlacementType.Left:\n                    leftSiblingIndex = findLeftSiblingIndex(visualTree, _data.navigationFamily, logicalParentItem);\n                    visualTree.add(visualParent.id, treeItem.id, treeItem, leftSiblingIndex + 1);\n                    treeItem.connectorPlacement = SideFlag.Right | SideFlag.Bottom;\n                    treeItem.gravity = HorizontalAlignmentType.Right;\n                    break;\n                  default:\n                    rightSiblingIndex = findRightSiblingIndex(visualTree, _data.navigationFamily, logicalParentItem);\n                    visualTree.add(visualParent.id, treeItem.id, treeItem, rightSiblingIndex);\n                    treeItem.connectorPlacement = SideFlag.Left | SideFlag.Bottom;\n                    treeItem.gravity = HorizontalAlignmentType.Left;\n                    break;\n                }\n              }\n\n              switch (treeItem.actualItemType) {\n                case ItemType.SubAdviser:\n                  break;\n                case ItemType.AdviserPartner:\n                  if (logicalParentItem.parentId != null) {\n                    defineNavigationParent(visualTree.node(logicalParentItem.parentId), treeItem);\n                  } else {\n                    defineNavigationParent(logicalParentItem, treeItem, true);\n                  }\n                  break;\n                case ItemType.Adviser:\n                  defineNavigationParent(logicalParentItem, treeItem);\n                  break;\n              }\n              break;\n            case ItemType.SubAssistant:\n              defineNavigationParent(logicalParentItem, treeItem);\n              treeItem.connectorPlacement = SideFlag.Top | SideFlag.Bottom;\n              shiftParent = getNewTreeItem({ visibility: Visibility.Invisible });\n              visualTree.add(shiftParent.id, treeItem.id, treeItem);\n              treeItem = shiftParent;//ignore jslint\n            case ItemType.Assistant://ignore jslint\n              var parent = createNewVisualAggregatorWithGivenDepth(visualTree, logicalParentItem, false, false, orgItem.levelOffset || 0);\n              switch (orgItem.adviserPlacementType) {\n                case AdviserPlacementType.Left:\n                  visualTree.add(parent.id, treeItem.id, treeItem, 0);\n                  treeItem.connectorPlacement = SideFlag.Right | SideFlag.Bottom;\n                  treeItem.gravity = HorizontalAlignmentType.Right;\n                  break;\n                default:\n                  visualTree.add(parent.id, treeItem.id, treeItem);\n                  treeItem.connectorPlacement = SideFlag.Left | SideFlag.Bottom;\n                  treeItem.gravity = HorizontalAlignmentType.Left;\n                  break;\n              }\n              if (treeItem.actualItemType == ItemType.Assistant) {\n                defineNavigationParent(logicalParentItem, treeItem);\n              }\n              break;\n            case ItemType.Regular:\n              var levelOffset = orgItem.levelOffset || 0;\n              if (regularChildrenLevels[levelOffset] == null) {\n                regularChildrenLevels[levelOffset] = [treeItem];\n              } else {\n                regularChildrenLevels[levelOffset].push(treeItem);\n              }\n              defineNavigationParent(logicalParentItem, treeItem);\n              break;\n            case ItemType.LimitedPartner:\n            case ItemType.GeneralPartner:\n              visualParent = visualTree.parent(parentOrgItemId);\n              if (logicalParentItem.connectorPlacement & SideFlag.Right) {\n                visualTree.add(visualParent.id, treeItem.id, treeItem, leftSiblingOffset);\n                treeItem.connectorPlacement = SideFlag.Right | SideFlag.Bottom;\n                treeItem.gravity = HorizontalAlignmentType.Right;\n              } else if (logicalParentItem.connectorPlacement & SideFlag.Left) {\n                visualTree.add(visualParent.id, treeItem.id, treeItem, visualTree.countChildren(visualParent.id) - rightSiblingOffset);\n                treeItem.connectorPlacement = SideFlag.Left | SideFlag.Bottom;\n                treeItem.gravity = HorizontalAlignmentType.Left;\n              } else {\n                switch (orgItem.adviserPlacementType) {\n                  case AdviserPlacementType.Left:\n                    visualTree.add(visualParent.id, treeItem.id, treeItem, leftSiblingOffset);\n                    treeItem.gravity = HorizontalAlignmentType.Right;\n                    break;\n                  default:\n                    visualTree.add(visualParent.id, treeItem.id, treeItem, visualTree.countChildren(visualParent.id) - rightSiblingOffset);\n                    treeItem.gravity = HorizontalAlignmentType.Left;\n                    break;\n                }\n                switch (treeItem.actualItemType) {\n                  case ItemType.GeneralPartner:\n                    treeItem.connectorPlacement = SideFlag.Top | SideFlag.Bottom;\n                    break;\n                  case ItemType.LimitedPartner:\n                    treeItem.connectorPlacement = SideFlag.Bottom;\n                    break;\n                }\n              }\n              if (logicalParentItem.parentId != null) {\n                defineNavigationParent(visualTree.node(logicalParentItem.parentId), treeItem);\n              } else {\n                defineNavigationParent(logicalParentItem, treeItem, true);\n              }\n              break;\n          }\n        }\n      });\n\n      /* collect partners, add logicalParentItem into partners collection */\n      switch (logicalParentItem.actualItemType) {\n        case ItemType.LimitedPartner:\n        case ItemType.AdviserPartner:\n        case ItemType.GeneralPartner:\n          break;\n        default:\n          tempPartners = [];\n          if ((visualParent = visualTree.parent(parentOrgItemId)) != null) {\n            visualTree.loopChildrenRange(this, visualParent.id, leftSiblingOffset, visualTree.countChildren(visualParent.id) - rightSiblingOffset, function (childItemId, childItem, index) {\n              if (childItem.id == parentOrgItemId) {\n                tempPartners.push(childItem);\n              } else {\n                switch (childItem.actualItemType) {\n                  case ItemType.LimitedPartner:\n                  case ItemType.AdviserPartner:\n                  case ItemType.GeneralPartner:\n                    if (orgTree.parentid(childItem.id) == parentOrgItemId) {\n                      tempPartners.push(childItem);\n                    }\n                    break;\n                }\n              }\n            });\n          }\n          if (tempPartners.length > 1) {\n            partners[parentOrgItemId] = tempPartners;\n          }\n          break;\n      }\n\n      rowAggregators[parentOrgItemId] = [];\n      rowChildren[parentOrgItemId] = [];\n\n      var aggregators = [];\n      if (regularChildrenLevels.length > 0) {\n        visualParent = getLastVisualAggregator(visualTree, logicalParentItem);\n        for (var indexLevel = 0; indexLevel < regularChildrenLevels.length - 1; indexLevel += 1) {\n          var regularChildrenLevel = regularChildrenLevels[indexLevel] || [];\n          if (regularChildrenLevel != null) {\n            var hideChildConnector = (logicalParentItem.visibility == Visibility.Invisible) && (logicalParentItem.connectorPlacement === 0);\n            var nextVisualParent = createNewVisualAggregator(visualTree, visualParent, hideChildConnector);\n\n            aggregators.push([nextVisualParent]);\n\n\n            var medianIndex = 0;\n            switch (options.horizontalAlignment) {\n              case HorizontalAlignmentType.Center:\n                medianIndex = Math.ceil(regularChildrenLevel.length / 2) - 1;\n                break;\n              case HorizontalAlignmentType.Left:\n                medianIndex = -1;\n                break;\n              case HorizontalAlignmentType.Right:\n                medianIndex = regularChildrenLevel.length - 1;\n                break;\n            }\n\n            for (index = medianIndex; index >= 0; index -= 1) {\n              item = regularChildrenLevel[index];\n              visualTree.add(visualParent.id, item.id, item, 0);\n              item.connectorPlacement = SideFlag.Top | SideFlag.Bottom;\n              item.gravity = HorizontalAlignmentType.Right;\n            }\n\n            for (index = medianIndex + 1; index < regularChildrenLevel.length; index += 1) {\n              item = regularChildrenLevel[index];\n              visualTree.add(visualParent.id, item.id, item);\n              item.connectorPlacement = SideFlag.Top | SideFlag.Bottom;\n              item.gravity = HorizontalAlignmentType.Left;\n            }\n\n            visualParent = nextVisualParent;\n          }\n        }\n\n        /* add children */\n        var regularChildren = regularChildrenLevels[regularChildrenLevels.length - 1];\n        layoutChildren(orgTree, visualTree, options, logicalParentItem, regularChildren, parentOrgItem.childrenPlacementType, rowAggregators[parentOrgItemId], rowChildren[parentOrgItemId]);\n\n        rowAggregators[parentOrgItemId] = rowAggregators[parentOrgItemId].concat(aggregators);\n        rowChildren[parentOrgItemId] = rowChildren[parentOrgItemId].concat(regularChildrenLevels.slice(0, regularChildrenLevels.length - 1));\n      }\n    });\n\n    /* transform tree to place children sub branches inside of hierarchy */\n    orgTree.loopPostOrder(this, function (nodeid, node, parentid, parent) {\n      var logicalParentItem = visualTree.node(nodeid),\n        itemRowChildren,\n        itemRowAggregators,\n        hasChildren,\n        hasPartners = (partners[parentid] != null),\n        extendChildren;\n      if (logicalParentItem != null) {\n        itemRowChildren = rowChildren[nodeid];\n        itemRowAggregators = rowAggregators[nodeid];\n\n        /* Move assistants children inside */\n        if (parent != null) {\n          extendChildren = hasPartners;\n          switch (parent.placeAssistantsAboveChildren) {\n            case Enabled.Auto:\n              if (options.placeAssistantsAboveChildren) {\n                extendChildren = true;\n              }\n              break;\n            case Enabled.True:\n              extendChildren = true;\n              break;\n          }\n\n          if (extendChildren) {\n            depth = getAssistantsDepth(visualTree, logicalParentItem);\n            if (depth > 0) {\n              logicalParentItem.visualDepth = depth + 1;\n              if (logicalParentItem.visualAggregatorId !== null) {\n                visualAggregator = visualTree.node(logicalParentItem.visualAggregatorId);\n                hasChildren = visualTree.hasChildren(visualAggregator.id);\n                for (index = 0; index < depth - 1; index += 1) {\n                  visualAggregator = createNewVisualAggregator(visualTree, visualAggregator, !hasChildren);\n                }\n              }\n            }\n          }\n        }\n        /* Move advisers children inside */\n        if (parent != null) {\n          extendChildren = hasPartners;\n          switch (parent.placeAdvisersAboveChildren) {\n            case Enabled.Auto:\n              if (options.placeAdvisersAboveChildren) {\n                extendChildren = true;\n              }\n              break;\n            case Enabled.True:\n              extendChildren = true;\n              break;\n          }\n          if (extendChildren) {\n            depth = getAdvisersDepth(visualTree, logicalParentItem);\n            if (depth > 1) {\n              logicalParentItem.visualDepth += (depth - 1);\n              hasChildren = visualTree.hasChildren(nodeid);\n              visualAggregator = logicalParentItem;\n              for (index = 0; index < depth - 1; index += 1) {\n                visualAggregator = createNewVisualAggregator(visualTree, visualAggregator, !hasChildren);\n              }\n            }\n          }\n        }\n        /* Move children of children inside */\n        rowDepths = [];\n        for (index = 0, len = itemRowChildren.length; index < len; index += 1) {\n          children = itemRowChildren[index];\n          rowDepths[index] = 0;\n          if(children != null) {\n            for (childIndex = 0, childrenLen = children.length; childIndex < childrenLen; childIndex += 1) {\n              rowDepths[index] = Math.max(rowDepths[index], getItemDepth(visualTree, children[childIndex]));\n            }\n          }\n        }\n\n        for (index = 0, len = rowDepths.length; index < len; index += 1) {\n          rowDepth = rowDepths[index];\n          if (rowDepth > 1) {\n            for (childIndex = 0, childrenLen = itemRowAggregators[index].length; childIndex < childrenLen; childIndex += 1) {\n              rowAggregator = itemRowAggregators[index][childIndex];\n              if (visualTree.hasChildren(rowAggregator.id)) {\n                depth = rowDepth;\n                while (depth > 1) {\n                  rowAggregator = createNewVisualAggregator(visualTree, rowAggregator, false);\n                  depth -= 1;\n                }\n              }\n            }\n          }\n        }\n\n        /* Align heights of partner branches in order to draw connector lines between them and logical parent children */\n        if (partners[nodeid] != null) {\n          /* partners collection includes treeItem so we should have at least 2 items */\n          layoutPartners(visualTree, logicalParentItem, partners[nodeid]);\n        }\n      }\n    });\n  }\n\n  function layoutPartners(visualTree, treeItem, partners) {\n    var partner,\n      index, len,\n      depth,\n      maxDepth = 0,\n      visualPartners = [],\n      visualPartner,\n      visualParent,\n      visualAggregator,\n      leftSiblingIndex,\n      gravity;\n\n    /* Find maximum depth required to enclose partners branches */\n    for (index = 0, len = partners.length; index < len; index += 1) {\n      partner = partners[index];\n      maxDepth = Math.max(maxDepth, partner.visualDepth);\n    }\n\n    /* Extend visual aggregators lines and ensure that connector lines are visible */\n    for (index = 0, len = partners.length; index < len; index += 1) {\n      partner = partners[index];\n      visualPartner = getLastVisualAggregator(visualTree, partner);\n      depth = 1;\n      visualAggregator = partner;\n      while (visualAggregator.visualAggregatorId != null) {\n        visualAggregator = visualTree.node(visualAggregator.visualAggregatorId);\n        visualAggregator.connectorPlacement = SideFlag.Top | SideFlag.Bottom;\n        depth += 1;\n      }\n      while (depth < maxDepth) {\n        visualPartner = createNewVisualAggregator(visualTree, visualPartner, false);\n        depth += 1;\n      }\n      visualPartners.push(getLastVisualAggregator(visualTree, visualPartner).id);\n    }\n\n\n    visualAggregator = getLastVisualAggregator(visualTree, treeItem);\n    if (visualTree.hasChildren(visualAggregator.id)) {\n      /* Select middle partner */\n      visualPartner = partners[Math.floor(partners.length / 2)];\n      if (partners.length > 1 && partners.length % 2 === 0) {\n        /* insert invisble partner for alignemnt */\n        visualParent = visualTree.parent(visualPartner.id);\n        leftSiblingIndex = findLeftSiblingIndex(visualTree, _data.navigationFamily, visualPartner);\n\n        gravity = visualTree.getChild(visualParent.id, leftSiblingIndex).gravity ||\n          visualTree.getChild(visualParent.id, leftSiblingIndex + 1).gravity;\n\n        // visualParent.id,\n        visualPartner = getNewTreeItem({\n          visibility: Visibility.Invisible,\n          connectorPlacement: visualPartner.connectorPlacement & (SideFlag.Left | SideFlag.Right),\n          gravity: gravity\n        });\n\n        visualTree.add(visualParent.id, visualPartner.id, visualPartner, leftSiblingIndex + 1);\n\n        depth = 1;\n        while (depth < maxDepth) {\n          visualPartner = createNewVisualAggregator(visualTree, visualPartner, false);\n          visualPartner.connectorPlacement = 0;\n          depth += 1;\n        }\n      }\n\n      /* every child logically belongs to every partner */\n      for (index = 0, len = partners.length; index < len; index += 1) {\n        partner = partners[index];\n        /* select all parents up to the root */\n        _data.navigationFamily.loopChildren(this, treeItem.id, function (childItemId, childItem, level) {\n          switch (childItem.actualItemType) {\n            case ItemType.SubAdviser:\n            case ItemType.Adviser:\n            case ItemType.SubAssistant:\n            case ItemType.Assistant:\n              break;\n            default:\n              /* partners share only regular items */\n              if (treeItem.id != partner.id) {\n                defineNavigationParent(partner, childItem);\n              }\n              break;\n          }\n          return _data.navigationFamily.SKIP;\n        }); //ignore jslint\n      }\n\n      /* Move children to new visual partner node */\n      visualPartner = getLastVisualAggregator(visualTree, visualPartner);\n      visualTree.moveChildren(visualAggregator.id, visualPartner.id);\n    }\n\n    /* Store collection of visual partners to draw connector lines*/\n    visualPartner.partners = visualPartners;\n  }\n\n  function getLastVisualAggregator(visualTree, treeItem) {\n    var result = treeItem;\n\n    while (result.visualAggregatorId != null) {\n      result = visualTree.node(result.visualAggregatorId);\n    }\n    return result;\n  }\n\n  function getAdvisersDepth(visualTree, treeItem) {\n    var result = 0,\n      parentItem = visualTree.parent(treeItem.id),\n      treeItemIndex,\n      position,\n      childItem;\n    if (parentItem !== null) {\n      treeItemIndex = visualTree.indexOf(treeItem.id);\n\n      position = 1;\n      while ((childItem = visualTree.getChild(parentItem.id, treeItemIndex + position)) != null) {\n        if (childItem.connectorPlacement & SideFlag.Left) {\n          result = Math.max(result, getItemDepth(visualTree, childItem));\n          position += 1;\n        }\n        else {\n          break;\n        }\n      }\n      position = 1;\n      while ((childItem = visualTree.getChild(parentItem.id, treeItemIndex - position)) != null) {\n        if (childItem.connectorPlacement & SideFlag.Right) {\n          result = Math.max(result, getItemDepth(visualTree, childItem));\n          position += 1;\n        }\n        else {\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n  function getAssistantsDepth(visualTree, treeItem) {\n    var result = 0;\n    if (treeItem.visualAggregatorId != null) {\n      visualTree.loopLevels(this, treeItem.id, function (childItemId, childItem, level) {\n        if (treeItem.visualAggregatorId == childItemId) {\n          return visualTree.SKIP;\n        }\n        result = level + 1;\n      });\n    }\n    return result;\n  }\n\n  function getItemDepth(visualTree, treeItem) {\n    var result = 0;\n    visualTree.loopLevels(this, treeItem.id, function (childid, child, level) {\n      result = level + 1;\n    });\n    return result + 1;\n  }\n\n  function layoutChildren(orgTree, visualTree, options, treeItem, regularChildren, childrenPlacementType, rowAggregators, rowChildren) {\n    var visualParent,\n      currentVisualParent,\n      leftChildItem,\n      rightChildItem,\n      newAggregatorItem,\n      childItem, orgChildItem,\n      width,\n      height,\n      twinColumns,\n      column,\n      row,\n      index, len,\n      singleItemPlacement,\n      hideParentConnector = (treeItem.visibility == Visibility.Invisible) && (treeItem.connectorPlacement === 0);\n\n    switch (options.horizontalAlignment) {\n      case HorizontalAlignmentType.Center:\n      case HorizontalAlignmentType.Left:\n        singleItemPlacement = AdviserPlacementType.Right;\n        break;\n      case HorizontalAlignmentType.Right:\n        singleItemPlacement = AdviserPlacementType.Left;\n        break;\n    }\n\n    if (childrenPlacementType === ChildrenPlacementType.Auto) {\n      if (hasRegularLeavesOnly(orgTree, treeItem)) {\n        childrenPlacementType = (options.leavesPlacementType === ChildrenPlacementType.Auto) ?\n          ChildrenPlacementType.Matrix : options.leavesPlacementType;\n      }\n      else {\n        childrenPlacementType = (options.childrenPlacementType === ChildrenPlacementType.Auto) ?\n          ChildrenPlacementType.Horizontal : options.childrenPlacementType;\n      }\n    }\n\n    visualParent = getLastVisualAggregator(visualTree, treeItem);\n\n    if (childrenPlacementType == ChildrenPlacementType.Matrix && regularChildren.length < 3) {\n      childrenPlacementType = ChildrenPlacementType.Horizontal;\n    }\n\n    switch (childrenPlacementType) {\n      case ChildrenPlacementType.Horizontal:\n        for (index = 0, len = regularChildren.length; index < len; index += 1) {\n          childItem = regularChildren[index];\n          orgChildItem = orgTree.node(childItem.id);\n          visualTree.add(visualParent.id, childItem.id, childItem);\n          childItem.connectorPlacement = (orgChildItem.hideParentConnection ? 0 : SideFlag.Top) | (orgChildItem.hideChildrenConnection ? 0 : SideFlag.Bottom);\n\n          if (index === 0) {\n            childItem.relationDegree = 1;\n          }\n        }\n        break;\n      case ChildrenPlacementType.Matrix:\n        width = Math.min(options.maximumColumnsInMatrix, Math.ceil(Math.sqrt(regularChildren.length)));\n        height = Math.ceil(regularChildren.length / width);\n        twinColumns = Math.ceil(width / 2.0);\n        for (column = 0; column < twinColumns; column += 1) {\n          currentVisualParent = visualParent;\n          for (row = 0; row < height; row += 1) {\n            leftChildItem = getMatrixItem(regularChildren, column * 2, row, width);\n            rightChildItem = getMatrixItem(regularChildren, column * 2 + 1, row, width);\n            if (rowAggregators[row] === undefined) {\n              rowAggregators[row] = [];\n              rowChildren[row] = [];\n            }\n            if (leftChildItem !== null) {\n              if (column === 0) {\n                leftChildItem.relationDegree = 1;\n              }\n              visualTree.add(currentVisualParent.id, leftChildItem.id, leftChildItem);\n              leftChildItem.connectorPlacement = (hideParentConnector ? 0 : SideFlag.Right) | SideFlag.Bottom;\n              leftChildItem.gravity = HorizontalAlignmentType.Right;\n\n              rowChildren[row].push(leftChildItem);\n            }\n            if (leftChildItem !== null || rightChildItem !== null) {\n              // currentVisualParent.id,\n              newAggregatorItem = getNewTreeItem({\n                visibility: Visibility.Invisible,\n                connectorPlacement: hideParentConnector ? 0 : SideFlag.Top | SideFlag.Bottom\n              });\n              visualTree.add(currentVisualParent.id, newAggregatorItem.id, newAggregatorItem);\n              rowAggregators[row].push(newAggregatorItem);\n            }\n            if (rightChildItem !== null) {\n              visualTree.add(currentVisualParent.id, rightChildItem.id, rightChildItem);\n              rightChildItem.connectorPlacement = (hideParentConnector ? 0 : SideFlag.Left) | SideFlag.Bottom;\n              rightChildItem.gravity = HorizontalAlignmentType.Left;\n\n              rowChildren[row].push(rightChildItem);\n            }\n\n            currentVisualParent = newAggregatorItem;\n          }\n        }\n        if (width > 2) {\n          // No center alignment to aggregator required\n          visualParent.visualAggregatorId = null;\n        }\n        break;\n      case ChildrenPlacementType.Vertical:\n        for (index = 0, len = regularChildren.length; index < len; index += 1) {\n          childItem = regularChildren[index];\n\n          // visualParent.id,\n          newAggregatorItem = getNewTreeItem({\n            visibility: Visibility.Invisible,\n            connectorPlacement: hideParentConnector ? 0 : SideFlag.Top | SideFlag.Bottom\n          });\n\n\n          switch (singleItemPlacement) {\n            case AdviserPlacementType.Left:\n              visualTree.add(visualParent.id, childItem.id, childItem);\n              visualTree.add(visualParent.id, newAggregatorItem.id, newAggregatorItem);\n              childItem.connectorPlacement = (hideParentConnector ? 0 : SideFlag.Right) | SideFlag.Bottom;\n              childItem.gravity = HorizontalAlignmentType.Right;\n              break;\n            case AdviserPlacementType.Right:\n              visualTree.add(visualParent.id, newAggregatorItem.id, newAggregatorItem);\n              visualTree.add(visualParent.id, childItem.id, childItem);\n              childItem.connectorPlacement = (hideParentConnector ? 0 : SideFlag.Left) | SideFlag.Bottom;\n              childItem.gravity = HorizontalAlignmentType.Left;\n              break;\n          }\n\n          rowAggregators[index] = [newAggregatorItem];\n          rowChildren[index] = [childItem];\n\n          visualParent = newAggregatorItem;\n        }\n        break;\n      default:\n        throw \"Children placement is undefined!\";\n    }\n  }\n\n  function getMatrixItem(items, x, y, width) {\n    var result,\n      isOdd = (width % 2 > 0),\n      index;\n\n    if (isOdd) {\n      if (x === width - 1) {\n        x = items.length;\n      }\n      else if (x === width) {\n        x = width - 1;\n      }\n    }\n    index = y * width + x;\n\n    result = (index > items.length - 1) ? null : items[index];\n\n    return result;\n  }\n\n  function hasRegularLeavesOnly(orgTree, treeItem) {\n    var hasChildren = false,\n      hasLeavesOnly = true;\n\n    orgTree.loopChildren(this, treeItem.id, function (nodeid, node, index) {\n      hasChildren = true;\n      if (node.itemType === ItemType.Regular &&\n        orgTree.hasChildren(nodeid)) {\n        hasLeavesOnly = false;\n        return true; // break\n      }\n    });\n    return hasChildren && hasLeavesOnly;\n  }\n\n  /* Sibling is the first item which does not belongs to items logical hierarchy */\n  function findLeftSiblingIndex(visualTree, navigationFamily, treeItem) {\n    var result = null,\n      ignore = {},\n      visualParent = visualTree.parent(treeItem.id);\n\n    visualTree.loopChildrenReversed(this, visualParent.id, function (childItemId, childItem, index) {\n      if (result === null) {\n        if (childItemId == treeItem.id) {\n          result = -1;\n          ignore[treeItem.id] = true;\n          navigationFamily.loopChildren(this, treeItem.id, function (childid, child, level) {\n            if (level > 0) {\n              return navigationFamily.BREAK;\n            }\n            ignore[childid] = true;\n          });\n        }\n      }\n      else {\n        if (!ignore.hasOwnProperty(childItemId)) {\n          result = index;\n          return true; //ignore jslint\n        } else {\n          navigationFamily.loopChildren(this, childItem.id, function (childid, child, level) {\n            if (level > 0) {\n              return navigationFamily.BREAK;\n            }\n            ignore[childid] = true;\n          });\n        }\n      }\n    });\n\n    return result;\n  }\n\n  /* Sibling is the first item which does not belongs to items logical hierarchy */\n  function findRightSiblingIndex(visualTree, navigationFamily, treeItem) {\n    var result = null,\n      ignore = {},\n      visualParent = visualTree.parent(treeItem.id);\n\n    visualTree.loopChildren(this, visualParent.id, function (childItemId, childItem, index, lastIndex) {\n      if (result === null) {\n        if (childItemId == treeItem.id) {\n          result = lastIndex + 1;\n          ignore[treeItem.id] = true;\n          navigationFamily.loopChildren(this, treeItem.id, function (childid, child, level) {\n            if (level > 0) {\n              return navigationFamily.BREAK;\n            }\n            ignore[childid] = true;\n          });\n        }\n      }\n      else {\n        if (!ignore.hasOwnProperty(childItemId)) {\n          result = index;\n          return true; //ignore jslint\n        } else {\n          navigationFamily.loopChildren(this, childItemId, function (childid, child, level) {\n            if (level > 0) {\n              return navigationFamily.BREAK;\n            }\n            ignore[childid] = true;\n          });\n        }\n      }\n    });\n    return result;\n  }\n\n  function createNewVisualAggregatorWithGivenDepth(visualTree, treeItem, hideParentConnector, hideChildrenConnector, depth) {\n    var result = null,\n      newAggregatorItem;\n    hideParentConnector = hideParentConnector || hideChildrenConnector;\n\n    var index = 0;\n    while (index <= depth) {\n      if (result == null) {\n        result = treeItem;\n      } else {\n        result = visualTree.node(result.visualAggregatorId);\n      }\n      if (result.visualAggregatorId == null) {\n        newAggregatorItem = getNewTreeItem({\n          visibility: Visibility.Invisible,\n          visualAggregatorId: null,\n          connectorPlacement: hideParentConnector ? 0 : (SideFlag.Top | SideFlag.Bottom)\n        });\n        visualTree.insert(result.id, newAggregatorItem.id, newAggregatorItem);\n        result.visualAggregatorId = newAggregatorItem.id;\n      }\n      index += 1;\n    }\n    return result;\n  }\n\n  function createNewVisualAggregator(visualTree, treeItem, hideChildrenConnector) {\n    var newAggregatorItem,\n      hideParentConnector = ((treeItem.visibility == Visibility.Invisible) && (treeItem.connectorPlacement === 0)) || hideChildrenConnector;\n\n    newAggregatorItem = getNewTreeItem({\n      visibility: Visibility.Invisible,\n      visualAggregatorId: treeItem.visualAggregatorId,\n      connectorPlacement: hideParentConnector ? 0 : (SideFlag.Top | SideFlag.Bottom)\n    });\n\n    visualTree.insert(treeItem.id, newAggregatorItem.id, newAggregatorItem);\n\n    treeItem.visualAggregatorId = newAggregatorItem.id;\n    return newAggregatorItem;\n  }\n\n  function getNewTreeItem(properties, orgItem) {\n    var result = new TreeItem(),\n      optionKey;\n\n    for (optionKey in properties) {\n      if (properties.hasOwnProperty(optionKey)) {\n        result[optionKey] = properties[optionKey];\n      }\n    }\n\n    if (orgItem != null) {\n      result.id = orgItem.id;\n      result.visibility = orgItem.isVisible ? Visibility.Auto : Visibility.Invisible;\n    } else {\n      _treeItemCounter += 1;\n      result.id = _treeItemCounter;\n    }\n\n    return result;\n  }\n\n  function defineNavigationParent(parentItem, treeItem, skipFirstParent) {\n    var parents = [];\n\n    /* take logicalParentItem when it is visible or collect all visible immidiate parents of logicalParentItem */\n    if (skipFirstParent || parentItem.visibility == Visibility.Invisible || !_activeItems.hasOwnProperty(parentItem.id)) {\n      if (!skipFirstParent) {\n        parents.push(parentItem.id);\n      }\n      _data.navigationFamily.loopParents(this, parentItem.id, function (parentid, parent, level) {\n        if (parent.visibility != Visibility.Invisible) {\n          parents.push(parentid);\n          if (_activeItems.hasOwnProperty(parentid)) {\n            return _data.navigationFamily.SKIP;\n          }\n        }\n      });\n    } else {\n      parents.push(parentItem.id);\n    }\n    if (_data.navigationFamily.node(treeItem.id) != null) {\n      _data.navigationFamily.adopt(parents, treeItem.id);\n    } else {\n      _data.navigationFamily.add(parents, treeItem.id, treeItem);\n    }\n  }\n\n  function updateVisualTreeMargins(visualTree, leftMargins, rightMargins) {\n    visualTree.loop(this, function (nodeid, node) {\n      leftMargins[nodeid] = [];\n      rightMargins[nodeid] = [];\n    });\n\n    visualTree.loopPostOrder(this, function (nodeid, node, parentid, parent) {\n      var parentLeftMargins = leftMargins[parentid],\n        parentRightMargins = rightMargins[parentid],\n        nodeLeftMargins = leftMargins[nodeid],\n        nodeRightMargins = rightMargins[nodeid],\n        index, len;\n\n      if (parentid != null) {\n        /* update parent left margins */\n        if (!parentLeftMargins[0]) {\n          parentLeftMargins[0] = nodeid;\n        }\n\n        for (index = 0, len = nodeLeftMargins.length; index < len; index += 1) {\n          if (!parentLeftMargins[index + 1]) {\n            parentLeftMargins[index + 1] = nodeLeftMargins[index];\n          }\n        }\n\n        /* update parent rights margins */\n        parentRightMargins[0] = nodeid;\n\n        for (index = 0, len = nodeRightMargins.length; index < len; index += 1) {\n          parentRightMargins[index + 1] = nodeRightMargins[index];\n        }\n      }\n    });\n  }\n\n  function getVisualTree() {\n    return _data.visualTree;\n  }\n\n  function getLogicalFamily() {\n    return _data.navigationFamily;\n  }\n\n  function getConnectionsFamily() {\n    return _data.connectionsFamily;\n  }\n\n  function getLeftMargins() {\n    return _data.leftMargins;\n  }\n\n  function getRightMargins() {\n    return _data.rightMargins;\n  }\n\n  return {\n    process: process,\n    getVisualTree: getVisualTree,\n    getLogicalFamily: getLogicalFamily,\n    getConnectionsFamily: getConnectionsFamily,\n    getLeftMargins: getLeftMargins,\n    getRightMargins: getRightMargins\n  };\n};"]},"metadata":{},"sourceType":"module"}