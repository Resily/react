{"ast":null,"code":"import binarySearch from './binarySearch';\n/**\n * Breaks collection of values into 3 intervals, so values stay close to each other within interval.\n * \n * @param {number[]} values Array of values\n * @returns {number[]} Returns array containing 3 indexes. The first 2 break values into 3 intervals, \n * the last index is actual index of the last element in the values collection. \n */\n\nexport default function getLiniarBreaks(values) {\n  var _leftTotal = [],\n      _len = values.length; // Sum up values from left to right\n\n  var total = 0;\n\n  for (var index = 0; index < _len; index += 1) {\n    total += values[index];\n    _leftTotal[index] = total;\n  }\n\n  function getLinearDeviation(leftIndex, rightIndex) {\n    var result = 0;\n    var avg = (_leftTotal[rightIndex] - _leftTotal[leftIndex] + values[leftIndex]) / (rightIndex - leftIndex + 1);\n    var median = binarySearch(values, function (item) {\n      return avg - item;\n    }, leftIndex, rightIndex);\n\n    if (median.item <= avg) {\n      result += avg * (median.index + 1 - leftIndex) - (_leftTotal[median.index] - _leftTotal[leftIndex] + values[leftIndex]);\n      result += _leftTotal[rightIndex] - _leftTotal[median.index] - avg * (rightIndex - median.index);\n    } else {\n      result += avg * (median.index - leftIndex) - (_leftTotal[median.index] - _leftTotal[leftIndex] - values[median.index] + values[leftIndex]);\n      result += _leftTotal[rightIndex] - _leftTotal[median.index] + values[median.index] - avg * (rightIndex - median.index + 1);\n    }\n\n    return result;\n  }\n\n  function getScore(leftIndex, rightIndex) {\n    var score = 0;\n    score += getLinearDeviation(0, leftIndex);\n\n    if (rightIndex > leftIndex + 1) {\n      score += getLinearDeviation(leftIndex + 1, rightIndex - 1);\n    }\n\n    score += getLinearDeviation(rightIndex, _len - 1);\n    return score;\n  }\n\n  var leftIndex = 0,\n      rightIndex = _len - 1;\n  var score = getScore(leftIndex, rightIndex);\n\n  while (leftIndex < rightIndex + 1) {\n    var leftScore = getScore(leftIndex + 1, rightIndex);\n    var rightScore = getScore(leftIndex, rightIndex - 1);\n\n    if (leftScore < rightScore) {\n      if (leftScore >= score) {\n        break;\n      }\n\n      leftIndex += 1;\n      score = leftScore;\n    } else {\n      if (rightScore >= score) {\n        break;\n      }\n\n      rightIndex -= 1;\n      score = rightScore;\n    }\n  }\n\n  return [leftIndex, rightIndex - 1, _len - 1];\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/getLiniarBreaks.js"],"names":["binarySearch","getLiniarBreaks","values","_leftTotal","_len","length","total","index","getLinearDeviation","leftIndex","rightIndex","result","avg","median","item","getScore","score","leftScore","rightScore"],"mappings":"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","sourcesContent":["import binarySearch from './binarySearch';\n/**\n * Breaks collection of values into 3 intervals, so values stay close to each other within interval.\n * \n * @param {number[]} values Array of values\n * @returns {number[]} Returns array containing 3 indexes. The first 2 break values into 3 intervals, \n * the last index is actual index of the last element in the values collection. \n */\nexport default function getLiniarBreaks(values) {\n  var _leftTotal = [],\n    _len = values.length;\n\n  // Sum up values from left to right\n  var total = 0;\n  for (var index = 0; index < _len; index += 1) {\n    total += values[index];\n    _leftTotal[index] = total;\n  }\n\n  function getLinearDeviation(leftIndex, rightIndex) {\n    var result = 0;\n\n    var avg = (_leftTotal[rightIndex] - _leftTotal[leftIndex] + values[leftIndex]) / (rightIndex - leftIndex + 1);\n\n    var median = binarySearch(values, function (item) {\n      return avg - item;\n    }, leftIndex, rightIndex);\n\n    if (median.item <= avg) {\n      result += (avg * (median.index + 1 - leftIndex) - (_leftTotal[median.index] - _leftTotal[leftIndex] + values[leftIndex]));\n      result += (_leftTotal[rightIndex] - _leftTotal[median.index] - avg * (rightIndex - median.index));\n    } else {\n      result += (avg * (median.index - leftIndex) - (_leftTotal[median.index] - _leftTotal[leftIndex] - values[median.index] + values[leftIndex]));\n      result += (_leftTotal[rightIndex] - _leftTotal[median.index] + values[median.index] - avg * (rightIndex - median.index + 1));\n    }\n\n    return result;\n  }\n\n  function getScore(leftIndex, rightIndex) {\n    var score = 0;\n\n    score += getLinearDeviation(0, leftIndex);\n    if (rightIndex > leftIndex + 1) {\n      score += getLinearDeviation(leftIndex + 1, rightIndex - 1);\n    }\n    score += getLinearDeviation(rightIndex, _len - 1);\n\n    return score;\n  }\n\n  var leftIndex = 0,\n    rightIndex = _len - 1;\n\n  var score = getScore(leftIndex, rightIndex);\n\n  while (leftIndex < rightIndex + 1) {\n    var leftScore = getScore(leftIndex + 1, rightIndex);\n    var rightScore = getScore(leftIndex, rightIndex - 1);\n\n    if (leftScore < rightScore) {\n      if (leftScore >= score) {\n        break;\n      }\n      leftIndex += 1;\n      score = leftScore;\n    } else {\n      if (rightScore >= score) {\n        break;\n      }\n      rightIndex -= 1;\n      score = rightScore;\n    }\n  }\n\n  return [leftIndex, rightIndex - 1, _len - 1];\n};\n\n"]},"metadata":{},"sourceType":"module"}