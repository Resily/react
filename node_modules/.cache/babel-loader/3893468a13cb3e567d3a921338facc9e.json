{"ast":null,"code":"import Rect from '../graphics/structs/Rect';\n/**\n * Creates Quad Tree data structure. It distributes points into equal quadrants. \n * So it is equivalent to 2 dimensional binary search tree. \n * @class QuadTree\n * \n * @param {number} minimalSize Defines minimal size of the quadrant. This protects structure against unnecessary depth.\n * @returns {QuadTree} Returns Quad Tree data structure.\n */\n\nexport default function QuadTree(minimalSize) {\n  var _minimalScale = Math.max(1, scale(minimalSize)),\n      _rootScale = 8,\n      _rootSize = 256,\n      _rootCell = null; // Create root cell\n\n\n  _rootCell = new Cell(0, 0, _rootScale, _rootSize);\n\n  function Cell(x, y, scale, size) {\n    this.x = x;\n    this.y = y;\n    this.scale = scale;\n    this.size = size;\n    this.quadrants = [];\n    this.points = [];\n  }\n\n  Cell.prototype.notEnclosed = function (rect) {\n    if (this.x < rect.x || this.x + this.size > rect.x + rect.width || this.y < rect.y || this.y + this.size > rect.y + rect.height) {\n      return true;\n    }\n\n    return false;\n  };\n\n  Cell.prototype.overlaps = function (rect) {\n    if (this.x + this.size < rect.x || rect.x + rect.width < this.x || this.y + this.size < rect.y || rect.y + rect.height < this.y) {\n      return false;\n    }\n\n    return true;\n  };\n\n  Cell.prototype.getQuadrantIndex = function (x, y) {\n    var shift = this.scale - 1;\n    return x >> shift & 1 | (y >> shift & 1) << 1;\n  };\n\n  function scale(value) {\n    return Math.floor(Math.log(value) / Math.log(2));\n  }\n  /**\n   * Adds point\n   * \n   * @param {Point} point Point\n   */\n\n\n  function addPoint(point) {\n    var x = Math.floor(point.x),\n        y = Math.floor(point.y),\n        size = Math.max(x, y);\n\n    while (_rootSize <= size) {\n      _rootScale += 1;\n      _rootSize *= 2;\n      var parent = new Cell(0, 0, _rootScale, _rootSize);\n\n      _splitCell(parent);\n\n      parent.quadrants[0] = _rootCell;\n      _rootCell = parent;\n    }\n\n    _addPoint(point);\n  }\n\n  function _addPoint(point) {\n    var x = Math.floor(point.x),\n        y = Math.floor(point.y),\n        cell = _rootCell;\n\n    if (x < 0 || y < 0) {\n      throw \"Negative values are not supported in the quad tree.\";\n    }\n\n    while (cell.points == null || cell.points.length > 0) {\n      if (cell.scale == _minimalScale && cell.points != null) {\n        break;\n      }\n\n      if (cell.points != null && cell.points.length > 0) {\n        _splitCell(cell);\n      }\n\n      cell = cell.quadrants[cell.getQuadrantIndex(x, y)];\n    }\n\n    cell.points.push(point);\n  }\n\n  function _splitCell(parent) {\n    var size = parent.size / 2;\n    parent.quadrants = [new Cell(parent.x, parent.y, parent.scale - 1, size), new Cell(parent.x + size, parent.y, parent.scale - 1, size), new Cell(parent.x, parent.y + size, parent.scale - 1, size), new Cell(parent.x + size, parent.y + size, parent.scale - 1, size)];\n\n    for (var index = 0, len = parent.points.length; index < len; index += 1) {\n      var point = parent.points[index],\n          x = Math.floor(point.x),\n          y = Math.floor(point.y);\n      parent.quadrants[parent.getQuadrantIndex(x, y)].points.push(point);\n    } // indicates that cell has quadrants\n\n\n    parent.points = null;\n  }\n  /**\n   * Callback function for iteration of points\n   * \n   * @callback onQuadTreePointCallback\n   * @param {Point} point Rectangle\n   * @returns {boolean} Returns true to break iteration process.\n   */\n\n  /**\n   * Loops rectangular area of quad tree structure\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {Rect} rect Rectangular search area\n   * @param {onQuadTreePointCallback} onItem Callback function to call for every point within the search area\n   */\n\n\n  function loopArea(thisArg, rect, onItem) {\n    var cell, index, len;\n\n    if (onItem != null) {\n      var check = [_rootCell],\n          nocheck = [];\n\n      while (check.length > 0 || nocheck.length > 0) {\n        var newCheck = [],\n            newNocheck = [];\n\n        for (index = 0, len = check.length; index < len; index += 1) {\n          cell = check[index];\n\n          if (cell.overlaps(rect)) {\n            if (cell.notEnclosed(rect)) {\n              if (cell.points == null) {\n                for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\n                  newCheck.push(cell.quadrants[quadrantIndex]);\n                }\n              } else {\n                for (var pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {\n                  var point = cell.points[pointIndex];\n\n                  if (rect.contains(point)) {\n                    if (onItem.call(thisArg, point)) {\n                      return;\n                    }\n                  }\n                }\n              }\n            } else {\n              nocheck.push(cell);\n            }\n          }\n        }\n\n        for (index = 0, len = nocheck.length; index < len; index += 1) {\n          cell = nocheck[index];\n\n          if (cell.points == null) {\n            for (quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\n              newNocheck.push(cell.quadrants[quadrantIndex]);\n            }\n          } else {\n            for (pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {\n              if (onItem.call(thisArg, cell.points[pointIndex])) {\n                return;\n              }\n            }\n          }\n        }\n\n        check = newCheck;\n        nocheck = newNocheck;\n      }\n    }\n  }\n  /**\n   * Validates internal data consistency of quad tree data structure\n   * \n   * @returns {boolean} Returns true if structure pass validation\n   */\n\n\n  function validate() {\n    var level = [_rootCell];\n\n    while (level.length > 0) {\n      var newLevel = [];\n\n      for (var index = 0, len = level.length; index < len; index += 1) {\n        var cell = level[index];\n        var rect = new Rect(cell.x, cell.y, cell.size, cell.size);\n\n        if (cell.points != null && cell.quadrants.length > 0) {\n          return false;\n        }\n\n        if (cell.points == null) {\n          for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\n            newLevel.push(cell.quadrants[quadrantIndex]);\n          }\n        } else {\n          for (var pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {\n            var point = cell.points[pointIndex];\n\n            if (!rect.contains(point)) {\n              return false;\n            }\n          }\n        }\n      }\n\n      level = newLevel;\n    }\n\n    return true;\n  }\n  /**\n   * Returns collection of quadrants created in the data structure\n   * Quadrants exists only when elements exists in them.\n   * This method is used for visual debugging of the structure.\n   * \n   * @param {React} selection Rectangular test area to highlight quadrants\n   * @returns {Rect[]} Returns collection of available quadrants.\n   * Quadrants containing points within selection area have context.highlight property set to true.\n   */\n\n\n  function getPositions(selection) {\n    var result = [];\n    var count = 0;\n    var level = [_rootCell];\n\n    while (level.length > 0) {\n      var newLevel = [];\n\n      for (var index = 0, len = level.length; index < len; index += 1) {\n        var cell = level[index];\n        var rect = new Rect(cell.x, cell.y, cell.size, cell.size);\n        rect.context = {\n          isHighlighted: false\n        };\n        count += 1;\n\n        if (selection != null && selection.overlaps(rect) && cell.points != null && cell.points.length > 0) {\n          rect.context.isHighlighted = true;\n        }\n\n        result.push(rect);\n\n        for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\n          var quadrant = cell.quadrants[quadrantIndex];\n\n          if (quadrant != null) {\n            newLevel.push(quadrant);\n          }\n        }\n      }\n\n      level = newLevel;\n    }\n\n    return result;\n  }\n\n  return {\n    addPoint: addPoint,\n    loopArea: loopArea,\n    validate: validate,\n    getPositions: getPositions\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/QuadTree.js"],"names":["Rect","QuadTree","minimalSize","_minimalScale","Math","max","scale","_rootScale","_rootSize","_rootCell","Cell","x","y","size","quadrants","points","prototype","notEnclosed","rect","width","height","overlaps","getQuadrantIndex","shift","value","floor","log","addPoint","point","parent","_splitCell","_addPoint","cell","length","push","index","len","loopArea","thisArg","onItem","check","nocheck","newCheck","newNocheck","quadrantIndex","pointIndex","pointsLen","contains","call","validate","level","newLevel","getPositions","selection","result","count","context","isHighlighted","quadrant"],"mappings":"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","sourcesContent":["import Rect from '../graphics/structs/Rect';\n/**\n * Creates Quad Tree data structure. It distributes points into equal quadrants. \n * So it is equivalent to 2 dimensional binary search tree. \n * @class QuadTree\n * \n * @param {number} minimalSize Defines minimal size of the quadrant. This protects structure against unnecessary depth.\n * @returns {QuadTree} Returns Quad Tree data structure.\n */\nexport default function QuadTree(minimalSize) {\n  var _minimalScale = Math.max(1, scale(minimalSize)),\n    _rootScale = 8,\n    _rootSize = 256,\n    _rootCell = null;\n\n  // Create root cell\n  _rootCell = new Cell(0, 0, _rootScale, _rootSize);\n\n  function Cell(x, y, scale, size) {\n    this.x = x;\n    this.y = y;\n    this.scale = scale;\n    this.size = size;\n    this.quadrants = [];\n    this.points = [];\n  }\n\n  Cell.prototype.notEnclosed = function (rect) {\n    if (this.x < rect.x || this.x + this.size > rect.x + rect.width || this.y < rect.y || this.y + this.size > rect.y + rect.height) {\n      return true;\n    }\n    return false;\n  };\n\n  Cell.prototype.overlaps = function (rect) {\n    if (this.x + this.size < rect.x || rect.x + rect.width < this.x || this.y + this.size < rect.y || rect.y + rect.height < this.y) {\n      return false;\n    }\n    return true;\n  };\n\n  Cell.prototype.getQuadrantIndex = function (x, y) {\n    var shift = this.scale - 1;\n    return ((x >> shift) & 1) | (((y >> shift) & 1) << 1);\n  };\n\n  function scale(value) {\n    return Math.floor(Math.log(value) / Math.log(2));\n  }\n\n  /**\n   * Adds point\n   * \n   * @param {Point} point Point\n   */\n  function addPoint(point) {\n    var x = Math.floor(point.x),\n      y = Math.floor(point.y),\n      size = Math.max(x, y);\n\n    while (_rootSize <= size) {\n      _rootScale += 1;\n      _rootSize *= 2;\n      var parent = new Cell(0, 0, _rootScale, _rootSize);\n      _splitCell(parent);\n      parent.quadrants[0] = _rootCell;\n      _rootCell = parent;\n    }\n    _addPoint(point);\n  }\n\n  function _addPoint(point) {\n    var x = Math.floor(point.x),\n      y = Math.floor(point.y),\n      cell = _rootCell;\n    if (x < 0 || y < 0) {\n      throw \"Negative values are not supported in the quad tree.\";\n    }\n    while (cell.points == null || cell.points.length > 0) {\n      if (cell.scale == _minimalScale && cell.points != null) {\n        break;\n      }\n      if (cell.points != null && cell.points.length > 0) {\n        _splitCell(cell);\n      }\n      cell = cell.quadrants[cell.getQuadrantIndex(x, y)];\n    }\n    cell.points.push(point);\n  }\n\n  function _splitCell(parent) {\n    var size = parent.size / 2;\n    parent.quadrants = [\n      new Cell(parent.x, parent.y, parent.scale - 1, size),\n      new Cell(parent.x + size, parent.y, parent.scale - 1, size),\n      new Cell(parent.x, parent.y + size, parent.scale - 1, size),\n      new Cell(parent.x + size, parent.y + size, parent.scale - 1, size)\n    ];\n    for (var index = 0, len = parent.points.length; index < len; index += 1) {\n      var point = parent.points[index],\n        x = Math.floor(point.x),\n        y = Math.floor(point.y);\n\n      parent.quadrants[parent.getQuadrantIndex(x, y)].points.push(point);\n    }\n\n    // indicates that cell has quadrants\n    parent.points = null;\n  }\n\n  /**\n   * Callback function for iteration of points\n   * \n   * @callback onQuadTreePointCallback\n   * @param {Point} point Rectangle\n   * @returns {boolean} Returns true to break iteration process.\n   */\n\n  /**\n   * Loops rectangular area of quad tree structure\n   * \n   * @param {object} thisArg The callback function invocation context\n   * @param {Rect} rect Rectangular search area\n   * @param {onQuadTreePointCallback} onItem Callback function to call for every point within the search area\n   */\n  function loopArea(thisArg, rect, onItem) {\n    var cell,\n      index, len;\n    if (onItem != null) {\n      var check = [_rootCell],\n        nocheck = [];\n      while (check.length > 0 || nocheck.length > 0) {\n        var newCheck = [],\n          newNocheck = [];\n        for (index = 0, len = check.length; index < len; index += 1) {\n          cell = check[index];\n          if (cell.overlaps(rect)) {\n            if (cell.notEnclosed(rect)) {\n              if (cell.points == null) {\n                for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\n                  newCheck.push(cell.quadrants[quadrantIndex]);\n                }\n              } else {\n                for (var pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {\n                  var point = cell.points[pointIndex];\n                  if (rect.contains(point)) {\n                    if (onItem.call(thisArg, point)) {\n                      return;\n                    }\n                  }\n                }\n              }\n            } else {\n              nocheck.push(cell);\n            }\n          }\n        }\n        for (index = 0, len = nocheck.length; index < len; index += 1) {\n          cell = nocheck[index];\n          if (cell.points == null) {\n            for (quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\n              newNocheck.push(cell.quadrants[quadrantIndex]);\n            }\n          } else {\n            for (pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {\n              if (onItem.call(thisArg, cell.points[pointIndex])) {\n                return;\n              }\n            }\n          }\n        }\n        check = newCheck;\n        nocheck = newNocheck;\n      }\n    }\n  }\n\n  /**\n   * Validates internal data consistency of quad tree data structure\n   * \n   * @returns {boolean} Returns true if structure pass validation\n   */\n  function validate() {\n    var level = [_rootCell];\n    while (level.length > 0) {\n      var newLevel = [];\n      for (var index = 0, len = level.length; index < len; index += 1) {\n        var cell = level[index];\n        var rect = new Rect(cell.x, cell.y, cell.size, cell.size);\n        if (cell.points != null && cell.quadrants.length > 0) {\n          return false;\n        }\n        if (cell.points == null) {\n          for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\n            newLevel.push(cell.quadrants[quadrantIndex]);\n          }\n        } else {\n          for (var pointIndex = 0, pointsLen = cell.points.length; pointIndex < pointsLen; pointIndex += 1) {\n            var point = cell.points[pointIndex];\n            if (!rect.contains(point)) {\n              return false;\n            }\n          }\n        }\n      }\n      level = newLevel;\n    }\n    return true;\n  }\n\n  /**\n   * Returns collection of quadrants created in the data structure\n   * Quadrants exists only when elements exists in them.\n   * This method is used for visual debugging of the structure.\n   * \n   * @param {React} selection Rectangular test area to highlight quadrants\n   * @returns {Rect[]} Returns collection of available quadrants.\n   * Quadrants containing points within selection area have context.highlight property set to true.\n   */\n  function getPositions(selection) {\n    var result = [];\n    var count = 0;\n    var level = [_rootCell];\n    while (level.length > 0) {\n      var newLevel = [];\n      for (var index = 0, len = level.length; index < len; index += 1) {\n        var cell = level[index];\n        var rect = new Rect(cell.x, cell.y, cell.size, cell.size);\n        rect.context = {\n          isHighlighted: false\n        };\n        count += 1;\n        if (selection != null && selection.overlaps(rect) && cell.points != null && cell.points.length > 0) {\n          rect.context.isHighlighted = true;\n        }\n\n        result.push(rect);\n        for (var quadrantIndex = 0; quadrantIndex < 4; quadrantIndex += 1) {\n          var quadrant = cell.quadrants[quadrantIndex];\n          if (quadrant != null) {\n            newLevel.push(quadrant);\n          }\n        }\n      }\n      level = newLevel;\n    }\n    return result;\n  }\n\n  return {\n    addPoint: addPoint,\n    loopArea: loopArea,\n    validate: validate,\n    getPositions: getPositions\n  };\n};"]},"metadata":{},"sourceType":"module"}