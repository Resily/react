{"ast":null,"code":"import { Enabled, ShapeType, AdviserPlacementType, TextOrientationType, PlacementType, Colors } from '../enums';\n/**\n * @class FamItemConfig\n * @classdesc Item Configuration Object defines properties of individual node in the family chart hierarchy. See `items` collection property\n * of family control configuration object. \n * \n * @param {FamItemConfig} arg0 Item config properties\n * \n * @param {string} arg0 Item id\n * @param {string[]|undefined} arg1 Parents ids\n * @param {string} arg2 Title\n * @param {string} arg3 Description \n * @param {string} arg4 Image\n */\n\nexport default function FamItemConfig(arg0, arg1, arg2, arg3, arg4) {\n  var property;\n  /**\n   * Item id. It should be unique per chart.\n   * \n   * @type {string}\n   */\n\n  this.id = null;\n  /**\n   * Parents items ids. If this collection is empty then item considered as a root item.\n   * @type {string[]}\n   */\n\n  this.parents = [];\n  /**\n   * Spouses items ids. The nodes of this collection create fake invisible child node, \n   * so all of them are being connected with common child connection line.\n   * \n   * @type {string[]}\n   */\n\n  this.spouses = [];\n  /**\n   * Relative item id. This property is used to control items mutual placement in order to keep consistent ordering within levels. Relative item is used \n   * for placing given item in diagram. We can place item on left or right side of relative item via setting placementType type property.\n   * In case when multiple items use the same relative item then their order can be customized with position property.\n   * \n   * If this property set to null, family layout algorithm will try to choose elements order via placing connected \n   * nodes as close to each other as possible.\n   * \n   * @group Order\n   * @type {string}\n   */\n\n  this.relativeItem = null;\n  /**\n   * Relative placement type defines Left ot Right side placement of the node relative to the `relativeItem`.\n   * \n   * @group Order\n   * @type {AdviserPlacementType}\n   */\n\n  this.placementType = AdviserPlacementType.Right;\n  /**\n   * Relative position defines order of elements placed relative to the same relative item on the same side.\n   * \n   * @group Order\n   * @type {number}\n   */\n\n  this.position = null;\n  /**\n   * Primary parents id. Set this property to place item close to the selected primary parent in `parents` collection.\n   * If property set to null or referenced parent does not exists then this property is ignored.\n   * \n   * @group Order\n   * @type {string}\n   */\n\n  this.primaryParent = null;\n  /**\n   * Title\n   * \n   * @group Template\n   * @type {string}\n   */\n\n  this.title = null;\n  /**\n   * Description\n   * \n   * @group Template\n   * @type {string}\n   */\n\n  this.description = null;\n  /**\n   * Image\n   * \n   * @group Template\n   * @type {string}\n   */\n\n  this.image = null;\n  /**\n   * Context object\n   * \n   * @group Template\n   * @type {object}\n   */\n\n  this.context = null;\n  /**\n   * Title background color. The same color is used for node marker when control has enabled auto fit mode.\n   * \n   * @group Template\n   * @type {string}\n   */\n\n  this.itemTitleColor = Colors.RoyalBlue;\n  /**\n   * Marker type. The shape of the marker when node is minimized by auto fit. The control supports auto fit of diagram into available screen space.\n   * When diagram size significantly larger than available screen space, its scrolling and navigation becomes problematic,\n   * so control supports automatic diagram fit into the screen space via rendering some of its nodes in form of small markers.\n   * So this option sets marker shape for individual node.\n   * \n   * @group Template\n   * @type {ShapeType}\n   */\n\n  this.minimizedItemShapeType = null;\n  /**\n   * Group Title. The group title on the side of the diagram node is one of controls default easy to use features.\n   * It gives extra dimension for nodes visual grouping in the diagram.\n   * \n   * @group Group Title\n   * @type {string}\n   */\n\n  this.groupTitle = null;\n  /**\n   * The group title background color.\n   * \n   * @group Group Title\n   * @type {string}\n   */\n\n  this.groupTitleColor = Colors.RoyalBlue;\n  /**\n   * If true it makes item inactive in the diagram layout. Inactive items are regular items excluded from navigation, that means \n   * when diagram uses auto fit mode, selection of the neighboring nodes goes through inactive items, so all nodes next to inactive item\n   * become selected and shown in full size as well. Inactive items play a role of in layout annotations having no user interaction\n   * and templated with HTML. For example they can be used to add titles into family diagram layout or terminator items\n   * indicating that upon reaching them diagram would load extra nodes into layout.\n   * \n   * @type {boolean}\n   */\n\n  this.isActive = true;\n  /**\n   * Shows selection check box for the node.\n   * If Auto then selection check box visibility depends on control's configuration.\n   * \n   * Auto - depends on `hasSelectorCheckbox` property of the control\n   * True - shown\n   * False - hidden\n   * \n   * @type {Enabled}\n   */\n\n  this.hasSelectorCheckbox = Enabled.Auto;\n  /**\n   * Shows context buttons panel for the node.\n   * If Auto then context buttons panel visibility depends on control's configuration.\n   * \n   * Auto - depends on `hasButtons` property of the control\n   * True - shown\n   * False - hidden\n   * \n   * @group Template\n   * @type {Enabled}\n   */\n\n  this.hasButtons = Enabled.Auto;\n  /**\n   * Template name. Templates are HTML fragments containing layout and styles used to render diagram nodes.\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\n   * This option lets individually assign rendering template per individual node of the diagram.\n   * \n   * @group Template\n   * @type {string}\n   */\n\n  this.templateName = null;\n  /**\n   * Sets callout annotation visibility for individual node. The callout annotation is one of easy to use features of the control.\n   * By default it is displayed for markers in order to preview their node's content. The content is displayed using\n   * current template of the node it is rendered for.\n   * \n   * The callout can be forced to be displayed for regular nodes as well. In that case use `calloutTemplateName` property\n   * to change their template.\n   * \n   * Auto - depends on `showCallout` property of the control\n   * True - shown regardless of node's visibility\n   * False - hidden\n   * \n   * @group Callout\n   * @type {Enabled}\n   */\n\n  this.showCallout = Enabled.Auto;\n  /**\n   * Callout annotation template name. This option lets individually assign rendering callout annotation template\n   * per individual node of the diagram.\n   * \n   * Templates are HTML fragments containing layout and styles used to render diagram nodes.\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\n   * \n   * @group Callout\n   * @type {string}\n   */\n\n  this.calloutTemplateName = null;\n  /**\n   * Marker label.\n   * \n   * @group Label\n   * @type {string}\n   */\n\n  this.label = null;\n  /**\n   * Sets label visibility for individual nodes. Labels are only rendered for a node's markers. \n   * \n   * The control does not preserve space for labels in the diagram layout, since that would contradict the purpose of minimizing the nodes\n   * into markers. Use controls `dotLevelShift`, `dotItemsInterval` properties to preserve space between nodes for labels.\n   * \n   * Labels are displayed inside of `div`s of the fixed size, see `labelSize` property, and control provides simple conflict\n   * resolution to avoid labels overlapping. If two labels overlap each other with their bounding rectangles then only one of them\n   * is going to stay visible.\n   * \n   * Auto - displays label only when it has space to be rendered.\n   * True - shows label regardless, even if it overlaps other labels and nodes.\n   * False - hidden.\n   * \n   * @group Label\n   * @type {Enabled}\n   */\n\n  this.showLabel = Enabled.Auto;\n  /**\n   * Label size. Sets label's placeholder `div` size and controls conflict resolution if labels overlap each other.\n   * If `null` then it is set to `labelSize` property of the control configuration.\n   * \n   * @group Label\n   * @type {Size}\n   */\n\n  this.labelSize = null;\n  /**\n   * Label orientation.\n   * If `Auto` then it is set to `labelOrientation` property of the control configuration.\n   * \n   * @group Label\n   * @type {TextOrientationType}\n   */\n\n  this.labelOrientation = TextOrientationType.Auto;\n  /**\n   * Label placement. Sets label placement relative to the marker bounding rectangle.\n   * If `Auto` then it is set to `labelPlacement` of the control configuration.\n   * \n   * @group Label\n   * @type {PlacementType}\n   */\n\n  this.labelPlacement = PlacementType.Auto;\n\n  switch (arguments.length) {\n    case 1:\n      for (property in arg0) {\n        if (arg0.hasOwnProperty(property)) {\n          this[property] = arg0[property];\n        }\n      }\n\n      break;\n\n    case 5:\n      this.id = arg0;\n      this.parents = arg1;\n      this.title = arg2;\n      this.description = arg3;\n      this.image = arg4;\n      break;\n  }\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/configs/FamItemConfig.js"],"names":["Enabled","ShapeType","AdviserPlacementType","TextOrientationType","PlacementType","Colors","FamItemConfig","arg0","arg1","arg2","arg3","arg4","property","id","parents","spouses","relativeItem","placementType","Right","position","primaryParent","title","description","image","context","itemTitleColor","RoyalBlue","minimizedItemShapeType","groupTitle","groupTitleColor","isActive","hasSelectorCheckbox","Auto","hasButtons","templateName","showCallout","calloutTemplateName","label","showLabel","labelSize","labelOrientation","labelPlacement","arguments","length","hasOwnProperty"],"mappings":"AAAA,SAAQA,OAAR,EAAiBC,SAAjB,EAA4BC,oBAA5B,EAAkDC,mBAAlD,EAAuEC,aAAvE,EAAsFC,MAAtF,QAAoG,UAApG;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,aAAT,CAAuBC,IAAvB,EAA6BC,IAA7B,EAAmCC,IAAnC,EAAyCC,IAAzC,EAA+CC,IAA/C,EAAqD;AAClE,MAAIC,QAAJ;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,EAAL,GAAU,IAAV;AAEA;AACF;AACA;AACA;;AACE,OAAKC,OAAL,GAAe,EAAf;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,OAAL,GAAe,EAAf;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,YAAL,GAAoB,IAApB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,aAAL,GAAqBf,oBAAoB,CAACgB,KAA1C;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,QAAL,GAAgB,IAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,aAAL,GAAqB,IAArB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,KAAL,GAAa,IAAb;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,WAAL,GAAmB,IAAnB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,KAAL,GAAa,IAAb;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,OAAL,GAAe,IAAf;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,cAAL,GAAsBpB,MAAM,CAACqB,SAA7B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,sBAAL,GAA8B,IAA9B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkB,IAAlB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,eAAL,GAAuBxB,MAAM,CAACqB,SAA9B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKI,QAAL,GAAgB,IAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,mBAAL,GAA2B/B,OAAO,CAACgC,IAAnC;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkBjC,OAAO,CAACgC,IAA1B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKE,YAAL,GAAoB,IAApB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,WAAL,GAAmBnC,OAAO,CAACgC,IAA3B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKI,mBAAL,GAA2B,IAA3B;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,KAAL,GAAa,IAAb;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,SAAL,GAAiBtC,OAAO,CAACgC,IAAzB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKO,SAAL,GAAiB,IAAjB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,gBAAL,GAAwBrC,mBAAmB,CAAC6B,IAA5C;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKS,cAAL,GAAsBrC,aAAa,CAAC4B,IAApC;;AAEA,UAAQU,SAAS,CAACC,MAAlB;AACE,SAAK,CAAL;AACE,WAAK/B,QAAL,IAAiBL,IAAjB,EAAuB;AACrB,YAAIA,IAAI,CAACqC,cAAL,CAAoBhC,QAApB,CAAJ,EAAmC;AACjC,eAAKA,QAAL,IAAiBL,IAAI,CAACK,QAAD,CAArB;AACD;AACF;;AACD;;AACF,SAAK,CAAL;AACE,WAAKC,EAAL,GAAUN,IAAV;AACA,WAAKO,OAAL,GAAeN,IAAf;AACA,WAAKa,KAAL,GAAaZ,IAAb;AACA,WAAKa,WAAL,GAAmBZ,IAAnB;AACA,WAAKa,KAAL,GAAaZ,IAAb;AACA;AAdJ;AAgBD;AAAA","sourcesContent":["import {Enabled, ShapeType, AdviserPlacementType, TextOrientationType, PlacementType, Colors } from '../enums';\n\n/**\n * @class FamItemConfig\n * @classdesc Item Configuration Object defines properties of individual node in the family chart hierarchy. See `items` collection property\n * of family control configuration object. \n * \n * @param {FamItemConfig} arg0 Item config properties\n * \n * @param {string} arg0 Item id\n * @param {string[]|undefined} arg1 Parents ids\n * @param {string} arg2 Title\n * @param {string} arg3 Description \n * @param {string} arg4 Image\n */\nexport default function FamItemConfig(arg0, arg1, arg2, arg3, arg4) {\n  var property;\n  /**\n   * Item id. It should be unique per chart.\n   * \n   * @type {string}\n   */\n  this.id = null;\n\n  /**\n   * Parents items ids. If this collection is empty then item considered as a root item.\n   * @type {string[]}\n   */\n  this.parents = [];\n\n  /**\n   * Spouses items ids. The nodes of this collection create fake invisible child node, \n   * so all of them are being connected with common child connection line.\n   * \n   * @type {string[]}\n   */\n  this.spouses = [];\n\n  /**\n   * Relative item id. This property is used to control items mutual placement in order to keep consistent ordering within levels. Relative item is used \n   * for placing given item in diagram. We can place item on left or right side of relative item via setting placementType type property.\n   * In case when multiple items use the same relative item then their order can be customized with position property.\n   * \n   * If this property set to null, family layout algorithm will try to choose elements order via placing connected \n   * nodes as close to each other as possible.\n   * \n   * @group Order\n   * @type {string}\n   */\n  this.relativeItem = null;\n\n  /**\n   * Relative placement type defines Left ot Right side placement of the node relative to the `relativeItem`.\n   * \n   * @group Order\n   * @type {AdviserPlacementType}\n   */\n  this.placementType = AdviserPlacementType.Right;\n\n  /**\n   * Relative position defines order of elements placed relative to the same relative item on the same side.\n   * \n   * @group Order\n   * @type {number}\n   */\n  this.position = null;\n\n  /**\n   * Primary parents id. Set this property to place item close to the selected primary parent in `parents` collection.\n   * If property set to null or referenced parent does not exists then this property is ignored.\n   * \n   * @group Order\n   * @type {string}\n   */\n  this.primaryParent = null;\n\n  /**\n   * Title\n   * \n   * @group Template\n   * @type {string}\n   */\n  this.title = null;\n\n  /**\n   * Description\n   * \n   * @group Template\n   * @type {string}\n   */\n  this.description = null;\n\n  /**\n   * Image\n   * \n   * @group Template\n   * @type {string}\n   */\n  this.image = null;\n\n  /**\n   * Context object\n   * \n   * @group Template\n   * @type {object}\n   */\n  this.context = null;\n\n  /**\n   * Title background color. The same color is used for node marker when control has enabled auto fit mode.\n   * \n   * @group Template\n   * @type {string}\n   */\n  this.itemTitleColor = Colors.RoyalBlue;\n\n  /**\n   * Marker type. The shape of the marker when node is minimized by auto fit. The control supports auto fit of diagram into available screen space.\n   * When diagram size significantly larger than available screen space, its scrolling and navigation becomes problematic,\n   * so control supports automatic diagram fit into the screen space via rendering some of its nodes in form of small markers.\n   * So this option sets marker shape for individual node.\n   * \n   * @group Template\n   * @type {ShapeType}\n   */\n  this.minimizedItemShapeType = null;\n\n  /**\n   * Group Title. The group title on the side of the diagram node is one of controls default easy to use features.\n   * It gives extra dimension for nodes visual grouping in the diagram.\n   * \n   * @group Group Title\n   * @type {string}\n   */\n  this.groupTitle = null;\n\n  /**\n   * The group title background color.\n   * \n   * @group Group Title\n   * @type {string}\n   */\n  this.groupTitleColor = Colors.RoyalBlue;\n\n  /**\n   * If true it makes item inactive in the diagram layout. Inactive items are regular items excluded from navigation, that means \n   * when diagram uses auto fit mode, selection of the neighboring nodes goes through inactive items, so all nodes next to inactive item\n   * become selected and shown in full size as well. Inactive items play a role of in layout annotations having no user interaction\n   * and templated with HTML. For example they can be used to add titles into family diagram layout or terminator items\n   * indicating that upon reaching them diagram would load extra nodes into layout.\n   * \n   * @type {boolean}\n   */\n  this.isActive = true;\n\n  /**\n   * Shows selection check box for the node.\n   * If Auto then selection check box visibility depends on control's configuration.\n   * \n   * Auto - depends on `hasSelectorCheckbox` property of the control\n   * True - shown\n   * False - hidden\n   * \n   * @type {Enabled}\n   */\n  this.hasSelectorCheckbox = Enabled.Auto;\n\n  /**\n   * Shows context buttons panel for the node.\n   * If Auto then context buttons panel visibility depends on control's configuration.\n   * \n   * Auto - depends on `hasButtons` property of the control\n   * True - shown\n   * False - hidden\n   * \n   * @group Template\n   * @type {Enabled}\n   */\n  this.hasButtons = Enabled.Auto;\n\n  /**\n   * Template name. Templates are HTML fragments containing layout and styles used to render diagram nodes.\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\n   * This option lets individually assign rendering template per individual node of the diagram.\n   * \n   * @group Template\n   * @type {string}\n   */\n  this.templateName = null;\n\n  /**\n   * Sets callout annotation visibility for individual node. The callout annotation is one of easy to use features of the control.\n   * By default it is displayed for markers in order to preview their node's content. The content is displayed using\n   * current template of the node it is rendered for.\n   * \n   * The callout can be forced to be displayed for regular nodes as well. In that case use `calloutTemplateName` property\n   * to change their template.\n   * \n   * Auto - depends on `showCallout` property of the control\n   * True - shown regardless of node's visibility\n   * False - hidden\n   * \n   * @group Callout\n   * @type {Enabled}\n   */\n  this.showCallout = Enabled.Auto;\n\n  /**\n   * Callout annotation template name. This option lets individually assign rendering callout annotation template\n   * per individual node of the diagram.\n   * \n   * Templates are HTML fragments containing layout and styles used to render diagram nodes.\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\n   * \n   * @group Callout\n   * @type {string}\n   */\n  this.calloutTemplateName = null;\n\n  /**\n   * Marker label.\n   * \n   * @group Label\n   * @type {string}\n   */\n  this.label = null;\n\n  /**\n   * Sets label visibility for individual nodes. Labels are only rendered for a node's markers. \n   * \n   * The control does not preserve space for labels in the diagram layout, since that would contradict the purpose of minimizing the nodes\n   * into markers. Use controls `dotLevelShift`, `dotItemsInterval` properties to preserve space between nodes for labels.\n   * \n   * Labels are displayed inside of `div`s of the fixed size, see `labelSize` property, and control provides simple conflict\n   * resolution to avoid labels overlapping. If two labels overlap each other with their bounding rectangles then only one of them\n   * is going to stay visible.\n   * \n   * Auto - displays label only when it has space to be rendered.\n   * True - shows label regardless, even if it overlaps other labels and nodes.\n   * False - hidden.\n   * \n   * @group Label\n   * @type {Enabled}\n   */\n  this.showLabel = Enabled.Auto;\n\n  /**\n   * Label size. Sets label's placeholder `div` size and controls conflict resolution if labels overlap each other.\n   * If `null` then it is set to `labelSize` property of the control configuration.\n   * \n   * @group Label\n   * @type {Size}\n   */\n  this.labelSize = null;\n\n  /**\n   * Label orientation.\n   * If `Auto` then it is set to `labelOrientation` property of the control configuration.\n   * \n   * @group Label\n   * @type {TextOrientationType}\n   */\n  this.labelOrientation = TextOrientationType.Auto;\n\n  /**\n   * Label placement. Sets label placement relative to the marker bounding rectangle.\n   * If `Auto` then it is set to `labelPlacement` of the control configuration.\n   * \n   * @group Label\n   * @type {PlacementType}\n   */\n  this.labelPlacement = PlacementType.Auto;\n\n  switch (arguments.length) {\n    case 1:\n      for (property in arg0) {\n        if (arg0.hasOwnProperty(property)) {\n          this[property] = arg0[property];\n        }\n      }\n      break;\n    case 5:\n      this.id = arg0;\n      this.parents = arg1;\n      this.title = arg2;\n      this.description = arg3;\n      this.image = arg4;\n      break;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}