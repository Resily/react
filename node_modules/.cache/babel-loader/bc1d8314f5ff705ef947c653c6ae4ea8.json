{"ast":null,"code":"import { ItemType } from '../../enums';\nimport getMergedIntervals from '../../algorithms/getMergedIntervals';\nimport Interval from '../../graphics/structs/Interval';\nexport default function OrgLogicalLevelsPlacementTask(orgTreeTask, alignDiagramTask) {\n  var _data = {\n    positions: []\n  };\n\n  function process() {\n    _data.positions = null;\n    return true;\n  }\n\n  function createPositions() {\n    var intervals = [],\n        orgTree = orgTreeTask.getOrgTree(),\n        itemsPositions = alignDiagramTask.getItemsPositions(),\n        visited = {};\n    orgTree.loopLevels(this, function (nodeId, node, levelIndex) {\n      if (node.itemType == ItemType.Regular) {\n        if (node.isVisible) {\n          var itemPosition = itemsPositions[nodeId];\n\n          if (itemPosition) {\n            var interval = new Interval(itemPosition.topConnectorShift, itemPosition.bottomConnectorShift - 1, levelIndex + node.levelOffset);\n            var key = interval.toString();\n\n            if (!visited[key]) {\n              visited[key] = true;\n              intervals.push(interval);\n            }\n          }\n        }\n\n        return;\n      }\n\n      return orgTree.SKIP;\n    });\n    var mergedIntervals = [];\n    getMergedIntervals(this, intervals, function (interval) {\n      mergedIntervals.push(interval);\n    });\n    intervals = mergedIntervals;\n    /* merge intervals having equal logical levels */\n\n    mergedIntervals = [];\n    var currentInterval = null;\n\n    for (var index = 0, len = intervals.length; index < len; index += 1) {\n      var interval = intervals[index];\n\n      if (!currentInterval) {\n        currentInterval = interval;\n        mergedIntervals.push(interval);\n      } else {\n        if (currentInterval.context === interval.context) {\n          currentInterval.to = interval.to;\n        } else {\n          currentInterval = interval;\n          mergedIntervals.push(interval);\n        }\n      }\n    }\n\n    intervals = mergedIntervals;\n    /* extend first level to the top */\n\n    if (intervals.length > 0) {\n      intervals[0].from = 0;\n    }\n    /* fill gaps between levels */\n\n\n    for (var index = 0, len = intervals.length - 1; index < len; index += 1) {\n      var prev = intervals[index];\n      var next = intervals[index + 1];\n      prev.to = next.from;\n    }\n    /* find minimal level */\n\n\n    var minLevelIndex = null;\n\n    for (var index = 0, len = intervals.length; index < len; index += 1) {\n      var interval = intervals[index];\n      minLevelIndex = minLevelIndex === null ? interval.context : Math.min(minLevelIndex, interval.context);\n    }\n    /* group intervals by logical levels */\n\n\n    var result = {};\n\n    for (var index = 0, len = intervals.length; index < len; index += 1) {\n      var interval = intervals[index];\n      var levelIndex = interval.context - minLevelIndex;\n      var logicalLevelPosition = result[levelIndex];\n\n      if (!logicalLevelPosition) {\n        result[levelIndex] = [interval];\n      } else {\n        logicalLevelPosition.push(interval);\n      }\n    }\n\n    return result;\n  }\n\n  function getPositions() {\n    if (!_data.positions) {\n      _data.positions = createPositions();\n    }\n\n    return _data.positions;\n  }\n\n  return {\n    getPositions: getPositions,\n    process: process\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/tasks/layout/OrgLogicalLevelsPlacementTask.js"],"names":["ItemType","getMergedIntervals","Interval","OrgLogicalLevelsPlacementTask","orgTreeTask","alignDiagramTask","_data","positions","process","createPositions","intervals","orgTree","getOrgTree","itemsPositions","getItemsPositions","visited","loopLevels","nodeId","node","levelIndex","itemType","Regular","isVisible","itemPosition","interval","topConnectorShift","bottomConnectorShift","levelOffset","key","toString","push","SKIP","mergedIntervals","currentInterval","index","len","length","context","to","from","prev","next","minLevelIndex","Math","min","result","logicalLevelPosition","getPositions"],"mappings":"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","sourcesContent":["import { ItemType } from '../../enums';\nimport getMergedIntervals from '../../algorithms/getMergedIntervals';\nimport Interval from '../../graphics/structs/Interval';\n\nexport default function OrgLogicalLevelsPlacementTask(orgTreeTask, alignDiagramTask) {\n  var _data = {\n    positions: []\n  };\n\n  function process() {\n    _data.positions = null;\n    return true;\n  }\n\n  function createPositions() {\n    var intervals = [],\n      orgTree = orgTreeTask.getOrgTree(),\n      itemsPositions = alignDiagramTask.getItemsPositions(),\n      visited = {};\n    orgTree.loopLevels(this, function(nodeId, node, levelIndex) {\n      if(node.itemType == ItemType.Regular) {\n        if(node.isVisible) {\n          var itemPosition = itemsPositions[nodeId];\n          if(itemPosition) {\n            var interval = new Interval(itemPosition.topConnectorShift, itemPosition.bottomConnectorShift - 1, levelIndex + node.levelOffset)\n            var key = interval.toString();\n            if(!visited[key]) {\n              visited[key] = true;\n              intervals.push(interval);\n            }\n          }\n        }\n        return;\n      }\n      return orgTree.SKIP;\n    });\n\n    var mergedIntervals = [];\n    getMergedIntervals(this, intervals, function(interval) {\n      mergedIntervals.push(interval);\n    });\n    intervals = mergedIntervals;\n\n    /* merge intervals having equal logical levels */\n    mergedIntervals = [];\n    var currentInterval = null;\n    for(var index = 0, len = intervals.length; index < len; index+=1) {\n      var interval = intervals[index];\n      if(!currentInterval) {\n        currentInterval = interval;\n        mergedIntervals.push(interval);\n      } else {\n        if(currentInterval.context === interval.context) {\n          currentInterval.to = interval.to;\n        } else {\n          currentInterval = interval;\n          mergedIntervals.push(interval);\n        }\n      }\n    }\n    intervals = mergedIntervals;\n\n    /* extend first level to the top */\n    if(intervals.length > 0) {\n      intervals[0].from = 0;\n    }\n\n    /* fill gaps between levels */\n    for(var index = 0, len = intervals.length - 1; index < len; index+=1) {\n      var prev = intervals[index];\n      var next = intervals[index + 1];\n\n      prev.to = next.from;\n    }\n\n    /* find minimal level */\n    var minLevelIndex = null;\n    for(var index = 0, len = intervals.length; index < len; index+=1) {\n      var interval = intervals[index];\n      minLevelIndex = (minLevelIndex === null) ? interval.context : Math.min(minLevelIndex, interval.context);\n    }\n\n    /* group intervals by logical levels */ \n    var result = {};\n    for(var index = 0, len = intervals.length; index < len; index+=1) {\n      var interval = intervals[index];\n      var levelIndex = interval.context - minLevelIndex;\n      var logicalLevelPosition = result[levelIndex];\n      if(!logicalLevelPosition) {\n        result[levelIndex] = [interval];\n      } else {\n        logicalLevelPosition.push(interval);\n      }\n    }\n    return result;\n  }\n\n\n  function getPositions() {\n    if(!_data.positions) {\n      _data.positions = createPositions();\n    }\n    return _data.positions;\n  }\n\n  return {\n    getPositions:getPositions,\n    process: process\n  };\n};"]},"metadata":{},"sourceType":"module"}