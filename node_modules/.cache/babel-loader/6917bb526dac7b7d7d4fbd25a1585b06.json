{"ast":null,"code":"/**\n * Creates range minimum query structure\n * @class RMQ\n * \n * @param {number[]} items Collection of numbers\n * @returns {RMQ} Returns range minimum query structure\n */\nexport default function RMQ(items) {\n  var _lookup = [];\n\n  var _log2 = Math.log(2);\n\n  preprocess();\n\n  function preprocess() {\n    var power;\n\n    for (var index = 0, len = items.length; index < len; index += 1) {\n      _lookup[index] = [index];\n    }\n\n    for (power = 1, len = items.length; 1 << power < len; power += 1) {\n      for (index = 0; index + (1 << power) - 1 < len; index += 1) {\n        if (items[_lookup[index][power - 1]] < items[_lookup[index + (1 << power - 1)][power - 1]]) {\n          _lookup[index][power] = _lookup[index][power - 1];\n        } else {\n          _lookup[index][power] = _lookup[index + (1 << power - 1)][power - 1];\n        }\n      }\n    }\n  }\n  /**\n   * Returns index of minimum item for the given range of items\n   * \n   * @param {number} from The left margin index\n   * @param {number} to The right margin index\n   * @returns {number} Returns index of the minimum item\n   */\n\n\n  function getRangeMinimumIndex(from, to) {\n    var power = Math.floor(Math.log(to - from + 1) / _log2);\n\n    if (items[_lookup[from][power]] <= items[_lookup[to - (1 << power) + 1][power]]) {\n      return _lookup[from][power];\n    } else {\n      return _lookup[to - (1 << power) + 1][power];\n    }\n  }\n  /**\n   * Return minimum value for the given range\n   * \n   * @param {number} from The left index of the range\n   * @param {number} to The right index of the range\n   * @returns {number} Returns minimum value in the range\n   */\n\n\n  function getRangeMinimum(from, to) {\n    return items[getRangeMinimumIndex(from, to)];\n  }\n\n  return {\n    getRangeMinimumIndex: getRangeMinimumIndex,\n    getRangeMinimum: getRangeMinimum\n  };\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/algorithms/RMQ.js"],"names":["RMQ","items","_lookup","_log2","Math","log","preprocess","power","index","len","length","getRangeMinimumIndex","from","to","floor","getRangeMinimum"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,GAAT,CAAaC,KAAb,EAAoB;AACjC,MAAIC,OAAO,GAAG,EAAd;;AACA,MAAIC,KAAK,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,CAAZ;;AAEAC,EAAAA,UAAU;;AAEV,WAASA,UAAT,GAAsB;AACpB,QAAIC,KAAJ;;AAEA,SAAK,IAAIC,KAAK,GAAG,CAAZ,EAAeC,GAAG,GAAGR,KAAK,CAACS,MAAhC,EAAwCF,KAAK,GAAGC,GAAhD,EAAqDD,KAAK,IAAI,CAA9D,EAAiE;AAC/DN,MAAAA,OAAO,CAACM,KAAD,CAAP,GAAiB,CAACA,KAAD,CAAjB;AACD;;AACD,SAAKD,KAAK,GAAG,CAAR,EAAWE,GAAG,GAAGR,KAAK,CAACS,MAA5B,EAAqC,KAAKH,KAAN,GAAeE,GAAnD,EAAwDF,KAAK,IAAI,CAAjE,EAAoE;AAClE,WAAKC,KAAK,GAAG,CAAb,EAAiBA,KAAK,IAAI,KAAKD,KAAT,CAAL,GAAuB,CAAxB,GAA6BE,GAA7C,EAAkDD,KAAK,IAAI,CAA3D,EAA8D;AAC5D,YAAIP,KAAK,CAACC,OAAO,CAACM,KAAD,CAAP,CAAeD,KAAK,GAAG,CAAvB,CAAD,CAAL,GAAmCN,KAAK,CAACC,OAAO,CAACM,KAAK,IAAI,KAAMD,KAAK,GAAG,CAAlB,CAAN,CAAP,CAAoCA,KAAK,GAAG,CAA5C,CAAD,CAA5C,EAA8F;AAC5FL,UAAAA,OAAO,CAACM,KAAD,CAAP,CAAeD,KAAf,IAAwBL,OAAO,CAACM,KAAD,CAAP,CAAeD,KAAK,GAAG,CAAvB,CAAxB;AACD,SAFD,MAEO;AACLL,UAAAA,OAAO,CAACM,KAAD,CAAP,CAAeD,KAAf,IAAwBL,OAAO,CAACM,KAAK,IAAI,KAAMD,KAAK,GAAG,CAAlB,CAAN,CAAP,CAAoCA,KAAK,GAAG,CAA5C,CAAxB;AACD;AACF;AACF;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASI,oBAAT,CAA8BC,IAA9B,EAAoCC,EAApC,EAAwC;AACtC,QAAIN,KAAK,GAAGH,IAAI,CAACU,KAAL,CAAWV,IAAI,CAACC,GAAL,CAASQ,EAAE,GAAGD,IAAL,GAAY,CAArB,IAA0BT,KAArC,CAAZ;;AAEA,QAAIF,KAAK,CAACC,OAAO,CAACU,IAAD,CAAP,CAAcL,KAAd,CAAD,CAAL,IAA+BN,KAAK,CAACC,OAAO,CAACW,EAAE,IAAI,KAAKN,KAAT,CAAF,GAAoB,CAArB,CAAP,CAA+BA,KAA/B,CAAD,CAAxC,EAAiF;AAC/E,aAAOL,OAAO,CAACU,IAAD,CAAP,CAAcL,KAAd,CAAP;AACD,KAFD,MAEO;AACL,aAAOL,OAAO,CAACW,EAAE,IAAI,KAAKN,KAAT,CAAF,GAAoB,CAArB,CAAP,CAA+BA,KAA/B,CAAP;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASQ,eAAT,CAAyBH,IAAzB,EAA+BC,EAA/B,EAAmC;AACjC,WAAOZ,KAAK,CAACU,oBAAoB,CAACC,IAAD,EAAOC,EAAP,CAArB,CAAZ;AACD;;AAED,SAAO;AACLF,IAAAA,oBAAoB,EAAEA,oBADjB;AAELI,IAAAA,eAAe,EAAEA;AAFZ,GAAP;AAID;AAAA","sourcesContent":["/**\n * Creates range minimum query structure\n * @class RMQ\n * \n * @param {number[]} items Collection of numbers\n * @returns {RMQ} Returns range minimum query structure\n */\nexport default function RMQ(items) {\n  var _lookup = [];\n  var _log2 = Math.log(2);\n\n  preprocess();\n\n  function preprocess() {\n    var power;\n\n    for (var index = 0, len = items.length; index < len; index += 1) {\n      _lookup[index] = [index];\n    }\n    for (power = 1, len = items.length; (1 << power) < len; power += 1) {\n      for (index = 0; (index + (1 << power) - 1) < len; index += 1) {\n        if (items[_lookup[index][power - 1]] < items[_lookup[index + (1 << (power - 1))][power - 1]]) {\n          _lookup[index][power] = _lookup[index][power - 1];\n        } else {\n          _lookup[index][power] = _lookup[index + (1 << (power - 1))][power - 1];\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns index of minimum item for the given range of items\n   * \n   * @param {number} from The left margin index\n   * @param {number} to The right margin index\n   * @returns {number} Returns index of the minimum item\n   */\n  function getRangeMinimumIndex(from, to) {\n    var power = Math.floor(Math.log(to - from + 1) / _log2);\n\n    if (items[_lookup[from][power]] <= items[_lookup[to - (1 << power) + 1][power]]) {\n      return _lookup[from][power];\n    } else {\n      return _lookup[to - (1 << power) + 1][power];\n    }\n  }\n\n  /**\n   * Return minimum value for the given range\n   * \n   * @param {number} from The left index of the range\n   * @param {number} to The right index of the range\n   * @returns {number} Returns minimum value in the range\n   */\n  function getRangeMinimum(from, to) {\n    return items[getRangeMinimumIndex(from, to)];\n  }\n\n  return {\n    getRangeMinimumIndex: getRangeMinimumIndex,\n    getRangeMinimum: getRangeMinimum\n  };\n};"]},"metadata":{},"sourceType":"module"}