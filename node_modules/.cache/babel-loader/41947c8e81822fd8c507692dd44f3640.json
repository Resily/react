{"ast":null,"code":"import Size from '../graphics/structs/Size';\nimport { Colors, Enabled, ItemType, AdviserPlacementType, ChildrenPlacementType, TextOrientationType, PlacementType } from '../enums';\n/**\n * @class OrgItemConfig\n * @classdesc Item Configuration Object defines properties of individual node in the organizational chart hierarchy. See `items` collection property\n * of organizational chart control configuration object. \n * \n * @param {OrgItemConfig} arg0 Item config properties\n * \n * @param {string} arg0 Item id\n * @param {string} arg1 Parent id\n * @param {string} arg2 Title\n * @param {string} arg3 Description \n * @param {string} arg4 Image\n */\n\nexport default function OrgItemConfig(arg0, arg1, arg2, arg3, arg4) {\n  var property;\n  /**\n   * Item id. It should be unique per chart.\n   * \n   * @type {string}\n   */\n\n  this.id = null;\n  /**\n   * Parent item id. If `null` then node is the root item of the hierarchy.\n   * @type {string}\n   */\n\n  this.parent = null;\n  /**\n   * Title\n   * \n   * @group Template\n   * @type {string}\n   */\n\n  this.title = null;\n  /**\n   * Description\n   * \n   * @group Template\n   * @type {string}\n   */\n\n  this.description = null;\n  /**\n   * Image\n   * \n   * @group Template\n   * @type {string}\n   */\n\n  this.image = null;\n  /**\n   * Context object\n   * \n   * @group Template\n   * @type {object}\n   */\n\n  this.context = null;\n  /**\n   * Title background color. The same color is used for node marker when control has enabled auto fit mode.\n   * \n   * @group Template\n   * @type {string}\n   */\n\n  this.itemTitleColor = Colors.RoyalBlue;\n  /**\n   * Marker type. The shape of the marker when node is minimized by auto fit. The control supports auto fit of diagram into available screen space.\n   * When diagram size significantly larger than available screen space, its scrolling and navigation becomes problematic,\n   * so control supports automatic diagram fit into the screen space via rendering some of its nodes in form of small markers.\n   * So this option sets marker shape for individual node.\n   * \n   * @group Template\n   * @type {ShapeType}\n   */\n\n  this.minimizedItemShapeType = null;\n  /**\n   * Group Title. The group title on the side of the diagram node is one of controls default easy to use features.\n   * It gives extra dimension for nodes visual grouping in the diagram.\n   * \n   * @group Group Title\n   * @type {string}\n   */\n\n  this.groupTitle = null;\n  /**\n   * The group title background color.\n   * \n   * @group Group Title\n   * @type {string}\n   */\n\n  this.groupTitleColor = Colors.RoyalBlue;\n  /**\n   * If `false` it makes item invisible in the layout. If item has no visible parents then its connections are hidden as well.\n   * From navigation perspective invisible items make all their children to be children of their parents.\n   * \n   * @type {boolean}\n   */\n\n  this.isVisible = true;\n  /**\n   * If true it makes item inactive in the diagram layout. Inactive items are regular items excluded from navigation, that means \n   * when diagram uses auto fit mode, selection of the neighboring nodes goes through inactive items, so all nodes next to inactive item\n   * become selected and shown in full size as well. Inactive items play a role of in layout annotations having no user interaction\n   * and templated with HTML. For example they can be used to add titles into family diagram layout or terminator items\n   * indicating that upon reaching them diagram would load extra nodes into layout.\n   * \n   * @type {boolean}\n   */\n\n  this.isActive = true;\n  /**\n   * Shows selection check box for the node.\n   * If Auto then selection check box visibility depends on control's configuration.\n   * \n   * Auto - depends on `hasSelectorCheckbox` property of the control\n   * True - shown\n   * False - hidden\n   * \n   * @type {Enabled}\n   */\n\n  this.hasSelectorCheckbox = Enabled.Auto;\n  /**\n   * Shows context buttons panel for the node.\n   * If Auto then context buttons panel visibility depends on control's configuration.\n   * \n   * Auto - depends on `hasButtons` property of the control\n   * True - shown\n   * False - hidden\n   * \n   * @group Template\n   * @type {Enabled}\n   */\n\n  this.hasButtons = Enabled.Auto;\n  /**\n   * Item type. This property defines child node placement relative to its parent node. By default all children that belong \n   * to a parent node are of the same rank and status between each other and due to that, are always aligned below\n   * the parent and are organized in the same way. However for special cases were the end user wishes to have a child\n   * that is separate from the rest of it's siblings, we provide custom child types that the end user can use to\n   * place different ranking nodes anywhere around the parent node. These placement options give a lot of space for\n   * the creation of roles such as an Assistant, Adviser, various Partners and co-heads that may be in the organization.\n   * Additionally, by default `Regular` children are always placed in a horizontal line below the parent node.\n   * \n   * @type {ItemType}\n   */\n\n  this.itemType = ItemType.Regular;\n  /**\n   * Sets node level offset relative to parent node. This property is ignored if it is not applicable.\n   * \n   * @type {number}\n   */\n\n  this.levelOffset = null;\n  /**\n   * Defines leftward or rightward item placement relative to the parent item.\n   * By default it is `Auto` and depends on general diagram layout orientation.\n   *  \n   * @type {AdviserPlacementType}\n   */\n\n  this.adviserPlacementType = AdviserPlacementType.Auto;\n  /**\n   * Defines shape of children formation. By default a node's children are always placed in a horizontal line \n   * below the parent node. On a large scale this may result in the end user having to scroll screens \n   * in order to view all of the nodes. To compensate for this, we provide the option of placing all \n   * of the children of a parent node in a square/matrix formation. This will reduce sideways screen \n   * scrolling by compacting the child nodes into a much smaller area on the screen.\n   *  \n   * @type {ChildrenPlacementType}\n   */\n\n  this.childrenPlacementType = ChildrenPlacementType.Auto;\n  /**\n   * Sets default placement of assistants hierarchies relative to the regular children of the node.\n   * If assistant node has its own children then control adds extra levels, so assistants children are placed\n   * above level of the regular children.\n   * \n   * @type {Enabled}\n   */\n\n  this.placeAssistantsAboveChildren = Enabled.Auto;\n  /**\n  * Sets default placement of advisers hierarchies relative to the regular children of the node.\n  * If adviser node has its own children then control adds extra levels, so advisers children are placed\n  * above level of the regular children.\n  * \n  * @type {Enabled}\n  */\n\n  this.placeAdvisersAboveChildren = Enabled.Auto;\n  /**\n   * Template name. Templates are HTML fragments containing layout and styles used to render diagram nodes.\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\n   * This option lets individually assign rendering template per individual node of the diagram.\n   * \n   * @group Template\n   * @type {string}\n   */\n\n  this.templateName = null;\n  /**\n   * Sets callout annotation visibility for individual node. The callout annotation is one of easy to use features of the control.\n   * By default it is displayed for markers in order to preview their node's content. The content is displayed using\n   * current template of the node it is rendered for.\n   * \n   * The callout can be forced to be displayed for regular nodes as well. In that case use `calloutTemplateName` property\n   * to change their template.\n   * \n   * Auto - depends on `showCallout` property of the control\n   * True - shown regardless of node's visibility\n   * False - hidden\n   * \n   * @group Callout\n   * @type {Enabled}\n   */\n\n  this.showCallout = Enabled.Auto;\n  /**\n   * Callout annotation template name. This option lets individually assign rendering callout annotation template\n   * per individual node of the diagram.\n   * \n   * Templates are HTML fragments containing layout and styles used to render diagram nodes.\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\n   * \n   * @group Callout\n   * @type {string}\n   */\n\n  this.calloutTemplateName = null;\n  /**\n   * Marker label.\n   * \n   * @group Label\n   * @type {string}\n   */\n\n  this.label = null;\n  /**\n   * Sets label visibility for individual nodes. Labels are only rendered for a node's markers. \n   * \n   * The control does not preserve space for labels in the diagram layout, since that would contradict the purpose of minimizing the nodes\n   * into markers. Use controls `dotLevelShift`, `dotItemsInterval` properties to preserve space between nodes for labels.\n   * \n   * Labels are displayed inside of `div`s of the fixed size, see `labelSize` property, and control provides simple conflict\n   * resolution to avoid labels overlapping. If two labels overlap each other with their bounding rectangles then only one of them\n   * is going to stay visible.\n   * \n   * Auto - displays label only when it has space to be rendered.\n   * True - shows label regardless, even if it overlaps other labels and nodes.\n   * False - hidden.\n   * \n   * @group Label\n   * @type {Enabled}\n   */\n\n  this.showLabel = Enabled.Auto;\n  /**\n   * Label size. Sets label's placeholder `div` size and controls conflict resolution if labels overlap each other.\n   * If `null` then it is set to `labelSize` property of the control configuration.\n   * \n   * @group Label\n   * @type {Size}\n   */\n\n  this.labelSize = null;\n  /**\n   * Label orientation.\n   * If `Auto` then it is set to `labelOrientation` property of the control configuration.\n   * \n   * @group Label\n   * @type {TextOrientationType}\n   */\n\n  this.labelOrientation = TextOrientationType.Auto;\n  /**\n   * Label placement. Sets label placement relative to the marker bounding rectangle.\n   * If `Auto` then it is set to `labelPlacement` of the control configuration.\n   * \n   * @group Label\n   * @type {PlacementType}\n   */\n\n  this.labelPlacement = PlacementType.Auto;\n\n  switch (arguments.length) {\n    case 1:\n      for (property in arg0) {\n        if (arg0.hasOwnProperty(property)) {\n          this[property] = arg0[property];\n        }\n      }\n\n      break;\n\n    case 5:\n      this.id = arg0;\n      this.parent = arg1;\n      this.title = arg2;\n      this.description = arg3;\n      this.image = arg4;\n      break;\n  }\n}\n;","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/configs/OrgItemConfig.js"],"names":["Size","Colors","Enabled","ItemType","AdviserPlacementType","ChildrenPlacementType","TextOrientationType","PlacementType","OrgItemConfig","arg0","arg1","arg2","arg3","arg4","property","id","parent","title","description","image","context","itemTitleColor","RoyalBlue","minimizedItemShapeType","groupTitle","groupTitleColor","isVisible","isActive","hasSelectorCheckbox","Auto","hasButtons","itemType","Regular","levelOffset","adviserPlacementType","childrenPlacementType","placeAssistantsAboveChildren","placeAdvisersAboveChildren","templateName","showCallout","calloutTemplateName","label","showLabel","labelSize","labelOrientation","labelPlacement","arguments","length","hasOwnProperty"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,0BAAjB;AACA,SAASC,MAAT,EAAiBC,OAAjB,EAA0BC,QAA1B,EAAoCC,oBAApC,EAA0DC,qBAA1D,EAAiFC,mBAAjF,EAAsGC,aAAtG,QAA2H,UAA3H;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,aAAT,CAAuBC,IAAvB,EAA6BC,IAA7B,EAAmCC,IAAnC,EAAyCC,IAAzC,EAA+CC,IAA/C,EAAqD;AAClE,MAAIC,QAAJ;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,EAAL,GAAU,IAAV;AAEA;AACF;AACA;AACA;;AACE,OAAKC,MAAL,GAAc,IAAd;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,KAAL,GAAa,IAAb;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,WAAL,GAAmB,IAAnB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,KAAL,GAAa,IAAb;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,OAAL,GAAe,IAAf;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,cAAL,GAAsBpB,MAAM,CAACqB,SAA7B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,sBAAL,GAA8B,IAA9B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkB,IAAlB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,eAAL,GAAuBxB,MAAM,CAACqB,SAA9B;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKI,SAAL,GAAiB,IAAjB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,QAAL,GAAgB,IAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,mBAAL,GAA2B1B,OAAO,CAAC2B,IAAnC;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkB5B,OAAO,CAAC2B,IAA1B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKE,QAAL,GAAgB5B,QAAQ,CAAC6B,OAAzB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,WAAL,GAAmB,IAAnB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,oBAAL,GAA4B9B,oBAAoB,CAACyB,IAAjD;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKM,qBAAL,GAA6B9B,qBAAqB,CAACwB,IAAnD;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKO,4BAAL,GAAoClC,OAAO,CAAC2B,IAA5C;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKQ,0BAAL,GAAkCnC,OAAO,CAAC2B,IAA1C;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKS,YAAL,GAAoB,IAApB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,WAAL,GAAmBrC,OAAO,CAAC2B,IAA3B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKW,mBAAL,GAA2B,IAA3B;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,KAAL,GAAa,IAAb;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,SAAL,GAAiBxC,OAAO,CAAC2B,IAAzB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKc,SAAL,GAAiB,IAAjB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,gBAAL,GAAwBtC,mBAAmB,CAACuB,IAA5C;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKgB,cAAL,GAAsBtC,aAAa,CAACsB,IAApC;;AAEA,UAAQiB,SAAS,CAACC,MAAlB;AACE,SAAK,CAAL;AACE,WAAKjC,QAAL,IAAiBL,IAAjB,EAAuB;AACrB,YAAIA,IAAI,CAACuC,cAAL,CAAoBlC,QAApB,CAAJ,EAAmC;AACjC,eAAKA,QAAL,IAAiBL,IAAI,CAACK,QAAD,CAArB;AACD;AACF;;AACD;;AACF,SAAK,CAAL;AACE,WAAKC,EAAL,GAAUN,IAAV;AACA,WAAKO,MAAL,GAAcN,IAAd;AACA,WAAKO,KAAL,GAAaN,IAAb;AACA,WAAKO,WAAL,GAAmBN,IAAnB;AACA,WAAKO,KAAL,GAAaN,IAAb;AACA;AAdJ;AAgBD;AAAA","sourcesContent":["import Size from '../graphics/structs/Size';\nimport { Colors, Enabled, ItemType, AdviserPlacementType, ChildrenPlacementType, TextOrientationType, PlacementType } from '../enums';\n\n/**\n * @class OrgItemConfig\n * @classdesc Item Configuration Object defines properties of individual node in the organizational chart hierarchy. See `items` collection property\n * of organizational chart control configuration object. \n * \n * @param {OrgItemConfig} arg0 Item config properties\n * \n * @param {string} arg0 Item id\n * @param {string} arg1 Parent id\n * @param {string} arg2 Title\n * @param {string} arg3 Description \n * @param {string} arg4 Image\n */\nexport default function OrgItemConfig(arg0, arg1, arg2, arg3, arg4) {\n  var property;\n  /**\n   * Item id. It should be unique per chart.\n   * \n   * @type {string}\n   */\n  this.id = null;\n\n  /**\n   * Parent item id. If `null` then node is the root item of the hierarchy.\n   * @type {string}\n   */\n  this.parent = null;\n\n  /**\n   * Title\n   * \n   * @group Template\n   * @type {string}\n   */\n  this.title = null;\n\n  /**\n   * Description\n   * \n   * @group Template\n   * @type {string}\n   */\n  this.description = null;\n\n  /**\n   * Image\n   * \n   * @group Template\n   * @type {string}\n   */\n  this.image = null;\n\n  /**\n   * Context object\n   * \n   * @group Template\n   * @type {object}\n   */\n  this.context = null;\n\n  /**\n   * Title background color. The same color is used for node marker when control has enabled auto fit mode.\n   * \n   * @group Template\n   * @type {string}\n   */\n  this.itemTitleColor = Colors.RoyalBlue;\n\n  /**\n   * Marker type. The shape of the marker when node is minimized by auto fit. The control supports auto fit of diagram into available screen space.\n   * When diagram size significantly larger than available screen space, its scrolling and navigation becomes problematic,\n   * so control supports automatic diagram fit into the screen space via rendering some of its nodes in form of small markers.\n   * So this option sets marker shape for individual node.\n   * \n   * @group Template\n   * @type {ShapeType}\n   */\n  this.minimizedItemShapeType = null;\n\n  /**\n   * Group Title. The group title on the side of the diagram node is one of controls default easy to use features.\n   * It gives extra dimension for nodes visual grouping in the diagram.\n   * \n   * @group Group Title\n   * @type {string}\n   */\n  this.groupTitle = null;\n\n  /**\n   * The group title background color.\n   * \n   * @group Group Title\n   * @type {string}\n   */\n  this.groupTitleColor = Colors.RoyalBlue;\n\n  /**\n   * If `false` it makes item invisible in the layout. If item has no visible parents then its connections are hidden as well.\n   * From navigation perspective invisible items make all their children to be children of their parents.\n   * \n   * @type {boolean}\n   */\n  this.isVisible = true;\n\n  /**\n   * If true it makes item inactive in the diagram layout. Inactive items are regular items excluded from navigation, that means \n   * when diagram uses auto fit mode, selection of the neighboring nodes goes through inactive items, so all nodes next to inactive item\n   * become selected and shown in full size as well. Inactive items play a role of in layout annotations having no user interaction\n   * and templated with HTML. For example they can be used to add titles into family diagram layout or terminator items\n   * indicating that upon reaching them diagram would load extra nodes into layout.\n   * \n   * @type {boolean}\n   */\n  this.isActive = true;\n\n  /**\n   * Shows selection check box for the node.\n   * If Auto then selection check box visibility depends on control's configuration.\n   * \n   * Auto - depends on `hasSelectorCheckbox` property of the control\n   * True - shown\n   * False - hidden\n   * \n   * @type {Enabled}\n   */\n  this.hasSelectorCheckbox = Enabled.Auto;\n\n  /**\n   * Shows context buttons panel for the node.\n   * If Auto then context buttons panel visibility depends on control's configuration.\n   * \n   * Auto - depends on `hasButtons` property of the control\n   * True - shown\n   * False - hidden\n   * \n   * @group Template\n   * @type {Enabled}\n   */\n  this.hasButtons = Enabled.Auto;\n\n  /**\n   * Item type. This property defines child node placement relative to its parent node. By default all children that belong \n   * to a parent node are of the same rank and status between each other and due to that, are always aligned below\n   * the parent and are organized in the same way. However for special cases were the end user wishes to have a child\n   * that is separate from the rest of it's siblings, we provide custom child types that the end user can use to\n   * place different ranking nodes anywhere around the parent node. These placement options give a lot of space for\n   * the creation of roles such as an Assistant, Adviser, various Partners and co-heads that may be in the organization.\n   * Additionally, by default `Regular` children are always placed in a horizontal line below the parent node.\n   * \n   * @type {ItemType}\n   */\n  this.itemType = ItemType.Regular;\n\n  /**\n   * Sets node level offset relative to parent node. This property is ignored if it is not applicable.\n   * \n   * @type {number}\n   */\n  this.levelOffset = null;\n\n  /**\n   * Defines leftward or rightward item placement relative to the parent item.\n   * By default it is `Auto` and depends on general diagram layout orientation.\n   *  \n   * @type {AdviserPlacementType}\n   */\n  this.adviserPlacementType = AdviserPlacementType.Auto;\n\n  /**\n   * Defines shape of children formation. By default a node's children are always placed in a horizontal line \n   * below the parent node. On a large scale this may result in the end user having to scroll screens \n   * in order to view all of the nodes. To compensate for this, we provide the option of placing all \n   * of the children of a parent node in a square/matrix formation. This will reduce sideways screen \n   * scrolling by compacting the child nodes into a much smaller area on the screen.\n   *  \n   * @type {ChildrenPlacementType}\n   */\n  this.childrenPlacementType = ChildrenPlacementType.Auto;\n\n  /**\n   * Sets default placement of assistants hierarchies relative to the regular children of the node.\n   * If assistant node has its own children then control adds extra levels, so assistants children are placed\n   * above level of the regular children.\n   * \n   * @type {Enabled}\n   */\n  this.placeAssistantsAboveChildren = Enabled.Auto;\n\n  /**\n * Sets default placement of advisers hierarchies relative to the regular children of the node.\n * If adviser node has its own children then control adds extra levels, so advisers children are placed\n * above level of the regular children.\n * \n * @type {Enabled}\n */\n  this.placeAdvisersAboveChildren = Enabled.Auto;\n\n  /**\n   * Template name. Templates are HTML fragments containing layout and styles used to render diagram nodes.\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\n   * This option lets individually assign rendering template per individual node of the diagram.\n   * \n   * @group Template\n   * @type {string}\n   */\n  this.templateName = null;\n\n  /**\n   * Sets callout annotation visibility for individual node. The callout annotation is one of easy to use features of the control.\n   * By default it is displayed for markers in order to preview their node's content. The content is displayed using\n   * current template of the node it is rendered for.\n   * \n   * The callout can be forced to be displayed for regular nodes as well. In that case use `calloutTemplateName` property\n   * to change their template.\n   * \n   * Auto - depends on `showCallout` property of the control\n   * True - shown regardless of node's visibility\n   * False - hidden\n   * \n   * @group Callout\n   * @type {Enabled}\n   */\n  this.showCallout = Enabled.Auto;\n\n  /**\n   * Callout annotation template name. This option lets individually assign rendering callout annotation template\n   * per individual node of the diagram.\n   * \n   * Templates are HTML fragments containing layout and styles used to render diagram nodes.\n   * They are defined with a named configuration objects. See `templates` property of control's configuration object.\n   * \n   * @group Callout\n   * @type {string}\n   */\n  this.calloutTemplateName = null;\n\n  /**\n   * Marker label.\n   * \n   * @group Label\n   * @type {string}\n   */\n  this.label = null;\n\n  /**\n   * Sets label visibility for individual nodes. Labels are only rendered for a node's markers. \n   * \n   * The control does not preserve space for labels in the diagram layout, since that would contradict the purpose of minimizing the nodes\n   * into markers. Use controls `dotLevelShift`, `dotItemsInterval` properties to preserve space between nodes for labels.\n   * \n   * Labels are displayed inside of `div`s of the fixed size, see `labelSize` property, and control provides simple conflict\n   * resolution to avoid labels overlapping. If two labels overlap each other with their bounding rectangles then only one of them\n   * is going to stay visible.\n   * \n   * Auto - displays label only when it has space to be rendered.\n   * True - shows label regardless, even if it overlaps other labels and nodes.\n   * False - hidden.\n   * \n   * @group Label\n   * @type {Enabled}\n   */\n  this.showLabel = Enabled.Auto;\n\n  /**\n   * Label size. Sets label's placeholder `div` size and controls conflict resolution if labels overlap each other.\n   * If `null` then it is set to `labelSize` property of the control configuration.\n   * \n   * @group Label\n   * @type {Size}\n   */\n  this.labelSize = null;\n\n  /**\n   * Label orientation.\n   * If `Auto` then it is set to `labelOrientation` property of the control configuration.\n   * \n   * @group Label\n   * @type {TextOrientationType}\n   */\n  this.labelOrientation = TextOrientationType.Auto;\n\n  /**\n   * Label placement. Sets label placement relative to the marker bounding rectangle.\n   * If `Auto` then it is set to `labelPlacement` of the control configuration.\n   * \n   * @group Label\n   * @type {PlacementType}\n   */\n  this.labelPlacement = PlacementType.Auto;\n\n  switch (arguments.length) {\n    case 1:\n      for (property in arg0) {\n        if (arg0.hasOwnProperty(property)) {\n          this[property] = arg0[property];\n        }\n      }\n      break;\n    case 5:\n      this.id = arg0;\n      this.parent = arg1;\n      this.title = arg2;\n      this.description = arg3;\n      this.image = arg4;\n      break;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}