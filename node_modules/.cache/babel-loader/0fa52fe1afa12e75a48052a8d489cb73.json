{"ast":null,"code":"import BaseShape from './BaseShape';\nimport Point from '../structs/Point';\nimport Rect from '../structs/Rect';\nimport MoveSegment from '../structs/MoveSegment';\nimport LineSegment from '../structs/LineSegment';\nimport QuadraticArcSegment from '../structs/QuadraticArcSegment';\nimport PaletteItem from '../structs/PaletteItem';\nimport PolylinesBuffer from '../structs/PolylinesBuffer';\nimport { PlacementType, Colors, LineType } from '../../enums';\nexport default function Callout(graphics) {\n  this.m_graphics = graphics;\n  this.pointerPlacement = PlacementType.Auto;\n  this.cornerRadius = \"10%\";\n  this.offset = 0;\n  this.opacity = 1;\n  this.lineWidth = 1;\n  this.pointerWidth = \"10%\";\n  this.borderColor = Colors.Black;\n  this.lineType = LineType.Solid;\n  this.fillColor = Colors.LightGray;\n  this.m_map = [[PlacementType.TopLeft, PlacementType.Left, PlacementType.BottomLeft], [PlacementType.Top, null, PlacementType.Bottom], [PlacementType.TopRight, PlacementType.Right, PlacementType.BottomRight]];\n}\n;\nCallout.prototype = new BaseShape();\n\nCallout.prototype.draw = function (snapPoint, position) {\n  position = new Rect(position).offset(this.offset);\n  var pointA = new Point(position.x, position.y),\n      pointB = new Point(position.right(), position.y),\n      pointC = new Point(position.right(), position.bottom()),\n      pointD = new Point(position.left(), position.bottom()),\n      snapPoints = [null, null, null, null, null, null, null, null],\n      points = [pointA, pointB, pointC, pointD],\n      radius = this.m_graphics.getPxSize(this.cornerRadius, Math.min(pointA.distanceTo(pointB), pointB.distanceTo(pointC))),\n      placementType,\n      point,\n      index,\n      attr,\n      linePaletteItem,\n      buffer,\n      polyline;\n  attr = {};\n\n  if (this.fillColor !== null) {\n    attr.fillColor = this.fillColor;\n    attr.opacity = this.opacity;\n  }\n\n  if (this.lineColor !== null) {\n    attr.lineColor = this.borderColor;\n  }\n\n  attr.lineWidth = this.lineWidth;\n  attr.lineType = this.lineType;\n  linePaletteItem = new PaletteItem(attr);\n  buffer = new PolylinesBuffer();\n  polyline = buffer.getPolyline(linePaletteItem);\n\n  if (snapPoint !== null) {\n    placementType = this.pointerPlacement === PlacementType.Auto ? this._getPlacement(snapPoint, pointA, pointC) : this.pointerPlacement;\n\n    if (placementType !== null) {\n      snapPoints[placementType] = snapPoint;\n    }\n  }\n\n  for (index = 0; index < points.length; index += 1) {\n    this._drawSegment(polyline, points[0], points[1], points[2], this.pointerWidth, radius, snapPoints[1], snapPoints[2]);\n\n    point = points.shift();\n    points.push(point);\n    point = snapPoints.shift();\n    snapPoints.push(point);\n    point = snapPoints.shift();\n    snapPoints.push(point);\n  }\n\n  this.m_graphics.polylinesBuffer(buffer);\n};\n\nCallout.prototype._getPlacement = function (point, point1, point2) {\n  var row = null,\n      column = null;\n\n  if (point.x < point1.x) {\n    row = 0;\n  } else if (point.x > point2.x) {\n    row = 2;\n  } else {\n    row = 1;\n  }\n\n  if (point.y < point1.y) {\n    column = 0;\n  } else if (point.y > point2.y) {\n    column = 2;\n  } else {\n    column = 1;\n  }\n\n  return this.m_map[row][column];\n};\n\nCallout.prototype._drawSegment = function (polyline, pointA, pointB, pointC, base, radius, sideSnapPoint, cornerSnapPoint) {\n  var pointA1 = this._offsetPoint(pointA, pointB, radius),\n      pointB1 = this._offsetPoint(pointB, pointA, radius),\n      pointB2 = this._offsetPoint(pointB, pointC, radius),\n      pointS,\n      pointS1,\n      pointS2;\n\n  base = this.m_graphics.getPxSize(base, pointA.distanceTo(pointB) / 2.0);\n\n  if (polyline.length() === 0) {\n    polyline.addSegment(new MoveSegment(pointA1));\n  }\n\n  if (sideSnapPoint !== null) {\n    pointS = this._betweenPoint(pointA, pointB);\n    pointS1 = this._offsetPoint(pointS, pointA, base);\n    pointS2 = this._offsetPoint(pointS, pointB, base);\n    polyline.addSegment(new LineSegment(pointS1));\n    polyline.addSegment(new LineSegment(sideSnapPoint));\n    polyline.addSegment(new LineSegment(pointS2));\n  }\n\n  polyline.addSegment(new LineSegment(pointB1));\n\n  if (cornerSnapPoint !== null) {\n    polyline.addSegment(new LineSegment(cornerSnapPoint));\n    polyline.addSegment(new LineSegment(pointB2));\n  } else {\n    polyline.addSegment(new QuadraticArcSegment(pointB, pointB2));\n  }\n};","map":{"version":3,"sources":["/Users/01005901/go/src/github.com/Resily/react/node_modules/basicprimitives/src/graphics/shapes/Callout.js"],"names":["BaseShape","Point","Rect","MoveSegment","LineSegment","QuadraticArcSegment","PaletteItem","PolylinesBuffer","PlacementType","Colors","LineType","Callout","graphics","m_graphics","pointerPlacement","Auto","cornerRadius","offset","opacity","lineWidth","pointerWidth","borderColor","Black","lineType","Solid","fillColor","LightGray","m_map","TopLeft","Left","BottomLeft","Top","Bottom","TopRight","Right","BottomRight","prototype","draw","snapPoint","position","pointA","x","y","pointB","right","pointC","bottom","pointD","left","snapPoints","points","radius","getPxSize","Math","min","distanceTo","placementType","point","index","attr","linePaletteItem","buffer","polyline","lineColor","getPolyline","_getPlacement","length","_drawSegment","shift","push","polylinesBuffer","point1","point2","row","column","base","sideSnapPoint","cornerSnapPoint","pointA1","_offsetPoint","pointB1","pointB2","pointS","pointS1","pointS2","addSegment","_betweenPoint"],"mappings":"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","sourcesContent":["import BaseShape from './BaseShape';\nimport Point from '../structs/Point';\nimport Rect from '../structs/Rect';\nimport MoveSegment from '../structs/MoveSegment';\nimport LineSegment from '../structs/LineSegment';\nimport QuadraticArcSegment from '../structs/QuadraticArcSegment';\nimport PaletteItem from '../structs/PaletteItem';\nimport PolylinesBuffer from '../structs/PolylinesBuffer';\nimport { PlacementType, Colors, LineType } from '../../enums';\n\n\nexport default function Callout(graphics) {\n  this.m_graphics = graphics;\n\n  this.pointerPlacement = PlacementType.Auto;\n  this.cornerRadius = \"10%\";\n  this.offset = 0;\n  this.opacity = 1;\n  this.lineWidth = 1;\n  this.pointerWidth = \"10%\";\n  this.borderColor = Colors.Black;\n  this.lineType = LineType.Solid;\n  this.fillColor = Colors.LightGray;\n\n  this.m_map = [[PlacementType.TopLeft, PlacementType.Left, PlacementType.BottomLeft],\n  [PlacementType.Top, null, PlacementType.Bottom],\n  [PlacementType.TopRight, PlacementType.Right, PlacementType.BottomRight]\n  ];\n};\n\nCallout.prototype = new BaseShape();\n\nCallout.prototype.draw = function (snapPoint, position) {\n  position = new Rect(position).offset(this.offset);\n\n  var pointA = new Point(position.x, position.y),\n    pointB = new Point(position.right(), position.y),\n    pointC = new Point(position.right(), position.bottom()),\n    pointD = new Point(position.left(), position.bottom()),\n    snapPoints = [null, null, null, null, null, null, null, null],\n    points = [pointA, pointB, pointC, pointD],\n    radius = this.m_graphics.getPxSize(this.cornerRadius, Math.min(pointA.distanceTo(pointB), pointB.distanceTo(pointC))),\n    placementType,\n    point,\n    index,\n    attr,\n    linePaletteItem,\n    buffer,\n    polyline;\n\n  attr = {};\n  if (this.fillColor !== null) {\n    attr.fillColor = this.fillColor;\n    attr.opacity = this.opacity;\n  }\n  if (this.lineColor !== null) {\n    attr.lineColor = this.borderColor;\n  }\n  attr.lineWidth = this.lineWidth;\n  attr.lineType = this.lineType;\n\n  linePaletteItem = new PaletteItem(attr);\n  buffer = new PolylinesBuffer();\n  polyline = buffer.getPolyline(linePaletteItem);\n\n  if (snapPoint !== null) {\n    placementType = (this.pointerPlacement === PlacementType.Auto) ? this._getPlacement(snapPoint, pointA, pointC) : this.pointerPlacement;\n    if (placementType !== null) {\n      snapPoints[placementType] = snapPoint;\n    }\n  }\n\n  for (index = 0; index < points.length; index += 1) {\n    this._drawSegment(polyline, points[0], points[1], points[2], this.pointerWidth, radius, snapPoints[1], snapPoints[2]);\n    point = points.shift();\n    points.push(point);\n    point = snapPoints.shift();\n    snapPoints.push(point);\n    point = snapPoints.shift();\n    snapPoints.push(point);\n  }\n\n  this.m_graphics.polylinesBuffer(buffer);\n};\n\nCallout.prototype._getPlacement = function (point, point1, point2) {\n  var row = null,\n    column = null;\n  if (point.x < point1.x) {\n    row = 0;\n  }\n  else if (point.x > point2.x) {\n    row = 2;\n  }\n  else {\n    row = 1;\n  }\n  if (point.y < point1.y) {\n    column = 0;\n  }\n  else if (point.y > point2.y) {\n    column = 2;\n  }\n  else {\n    column = 1;\n  }\n  return this.m_map[row][column];\n};\n\nCallout.prototype._drawSegment = function (polyline, pointA, pointB, pointC, base, radius, sideSnapPoint, cornerSnapPoint) {\n  var pointA1 = this._offsetPoint(pointA, pointB, radius),\n    pointB1 = this._offsetPoint(pointB, pointA, radius),\n    pointB2 = this._offsetPoint(pointB, pointC, radius),\n    pointS,\n    pointS1,\n    pointS2;\n\n  base = this.m_graphics.getPxSize(base, pointA.distanceTo(pointB) / 2.0);\n\n  if (polyline.length() === 0) {\n    polyline.addSegment(new MoveSegment(pointA1));\n  }\n  if (sideSnapPoint !== null) {\n    pointS = this._betweenPoint(pointA, pointB);\n    pointS1 = this._offsetPoint(pointS, pointA, base);\n    pointS2 = this._offsetPoint(pointS, pointB, base);\n    polyline.addSegment(new LineSegment(pointS1));\n    polyline.addSegment(new LineSegment(sideSnapPoint));\n    polyline.addSegment(new LineSegment(pointS2));\n  }\n\n  polyline.addSegment(new LineSegment(pointB1));\n  if (cornerSnapPoint !== null) {\n    polyline.addSegment(new LineSegment(cornerSnapPoint));\n    polyline.addSegment(new LineSegment(pointB2));\n  }\n  else {\n    polyline.addSegment(new QuadraticArcSegment(pointB, pointB2));\n  }\n};\n"]},"metadata":{},"sourceType":"module"}